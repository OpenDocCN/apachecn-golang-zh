# 使用系统文件

在上一章中，我们讨论了 Go 中的文件输入和输出，并创建了`wc(1)`、`dd(1)`和`cp(1)`实用程序的 Go 版本。

虽然本章的主要主题是 Unix 系统文件和日志文件，但您还将学习许多其他内容，包括模式匹配、文件权限、与用户和组协作以及处理 Go 中的日期和时间。对于所有这些主题，您将看到方便的 Go 代码，这些代码将解释所介绍的技术，并且这些代码可以在您自己的 Go 程序中使用，而无需进行太多更改。

因此，本章将讨论以下主题：

*   将数据追加到现有文件
*   读取文件并更改其每一行
*   Go 中的正则表达式与模式匹配
*   将信息发送到 Unix 日志文件
*   在围棋中使用日期和时间
*   使用 Unix 文件权限
*   使用用户 ID 和组 ID
*   了解有关文件和目录的更多信息
*   处理日志文件并从中提取有用信息
*   使用随机数生成难以猜测的密码

# 哪些文件被视为系统文件？

每个 Unix 操作系统都包含负责配置系统及其各种服务的文件。这些文件大部分位于`/etc`目录中。我也喜欢将日志文件视为系统文件，尽管有些人可能不同意。通常，大多数系统日志文件都可以在`/var/log`中找到。但是，Apache 和 nginx web 服务器的日志文件可以在其他地方找到，具体取决于它们的配置。

# 登录 Go

`log`包提供了在 Unix 机器上记录信息的一般方法，而`log/syslog`Go 包允许您使用所需的记录级别和记录工具将信息发送到系统记录服务。此外，`time`软件包可以帮助您处理日期和时间。

# 将数据放在文件末尾

如[第 6 章](06.html)、*文件输入和输出*所述，在本章中，我们将讨论在不破坏现有数据的情况下打开文件进行写入。

演示该技术的 Go 程序`appendData.go`将接受两个命令行参数：要附加的消息和将存储文本的文件名。该计划将分三部分介绍。

`appendData.go`的第一部分包含以下 Go 代码：

```go
package main 

import ( 
   "fmt" 
   "os" 
   "path/filepath" 
) 
```

正如预期的那样，程序的第一部分包含将在程序中使用的 Go 包。

第二部分如下：

```go
func main() { 
   arguments := os.Args 
   if len(arguments) != 3 { 
         fmt.Printf("usage: %s message filename\n", filepath.Base(arguments[0])) 
         os.Exit(1) 
   } 
   message := arguments[1] 
   filename := arguments[2] 

   f, err := os.OpenFile(filename, 
os.O_RDWR|os.O_APPEND|os.O_CREATE, 0660) 
```

所需的任务由`os.OpenFile()`函数的`os.O_APPEND`标志完成，该标志在文件末尾告知 Go to write。此外，`os.O_CREATE`标志将使`os.OpenFile()`在文件不存在时创建该文件，这非常方便，因为它不必编写测试文件是否已经存在的 Go 代码。

计划的最后一部分如下：

```go
   if err != nil { 
         fmt.Println(err) 
         os.Exit(-1) 
   } 
   defer f.Close() 

   fmt.Fprintf(f, "%s\n", message) 
} 
```

此处使用`fmt.Fprintf()`函数将消息以纯文本形式写入文件。如您所见，`appendData.go`是一个相对较小的 Go 程序，不包含任何惊喜。

执行`appendData.go`不会产生任何输出，但它会完成它的工作，从`appendData.go`执行前后`cat(1)`实用程序的输出中可以看出：

```go
$ cat test
[test]: test
: test
$ go run appendData.go test test
$ cat test
[test]: test
: test
test 
```

# 更改现有数据

本节将教您如何修改文件的内容。将要开发的程序做了一项非常方便的工作：它在文本文件的每一行前面添加一个行号。这意味着您需要逐行读取输入文件，保留一个保存行号值的变量，并使用原始名称保存它。此外，可以在启动程序时定义保存行号值的变量的初始值。围棋项目名称为`insertLineNumber.go`，分四个部分介绍。

首先，您将看到预期的序言：

```go
package main 

import ( 
   "flag" 
   "fmt" 
   "io/ioutil" 
   "os" 
   "strings" 
) 
```

第二部分主要是`flag`包的配置：

```go
func main() { 
   minusINIT := flag.Int("init", 1, "Initial Value") 
   flag.Parse() 
   flags := flag.Args() 

   if len(flags) == 0 { 
         fmt.Printf("usage: insertLineNumber <files>\n") 
         os.Exit(1) 
   } 

   lineNumber := *minusINIT
   for _, filename := range flags { 
         fmt.Println("Processing:", filename) 
```

`lineNumber`变量由`minusINIT`标志的值启动。此外，该实用程序可以使用`for`循环处理多个文件。

该计划的第三部分如下：

```go
         input, err := ioutil.ReadFile(filename) 
         if err != nil { 
               fmt.Println(err) 
               os.Exit(-1) 
         } 

         lines := strings.Split(string(input), "\n") 
```

如您所见，`insertLineNumber.go`使用`ioutil.ReadFile()`一次读取其输入文件，这在处理大型文本文件时可能没有那么高效。然而，对于今天的计算机，这应该不是一个问题。更好的方法是逐行读取输入文件，将更改后的每一行写入临时文件，然后用临时文件替换原始文件。

该实用程序的最后一部分如下所示：

```go
         for i, line := range lines { 
               lines[i] = fmt.Sprintf("%d: %s ", lineNumber, line) 
               lineNumber = lineNumber + 1
         } 

         lines[len(lines)-1] = "" 
         output := strings.Join(lines, "\n") 
         err = ioutil.WriteFile(filename, []byte(output), 0644) 
         if err != nil { 
               fmt.Println(err) 
               os.Exit(-1) 
         } 
   } 
   fmt.Println("Processed", lineNumber-*minusINIT, "lines!") 
}
```

由于`range`循环将在文件末尾引入一个额外的行，因此必须使用`lines[len(lines)-1] = ""`语句删除行切片中的最后一行，这意味着程序假定它处理的所有文件都以新行结尾。如果您的文本文件没有这样做，那么您可能需要更改`insertLineNumber.go`的代码或在文本文件的末尾添加新行。

运行`insertLineNumber.go`时，除了处理的每个文件的文件名和处理的总行数外，不会产生任何可见的输出。但是，您可以通过查看所处理文件的内容来查看其执行结果：

```go
$ cat test
a

b
$ go run insertLineNumber.go -init=10 test
Processing: test
Processed 4 lines!
$ cat test
10: a
11:
12: b
```

如果您尝试多次处理同一输入文件，如以下示例所示，将发生一件有趣的事情：

```go
$ cat test
a

b
$ go run insertLineNumber.go -init=10 test test test
Processing: test
Processing: test
Processing: test
Processed 12 lines!
$ cat test
18: 14: 10: a
19: 15: 11:
20: 16: 12: b
```

# 关于日志文件

本部分将教您如何将信息从 Go 程序发送到日志服务，从而发送到系统日志文件。尽管保存信息很好，但日志文件对于服务器进程来说是必要的，因为服务器进程没有其他方式向外部世界发送信息，因为它没有终端来发送任何输出。

日志文件很重要，您不应低估其中存储的信息的价值。当 Unix 机器上开始发生奇怪的事情时，日志文件应该是第一个寻求帮助的地方。

一般来说，使用日志文件比在屏幕上显示输出要好，原因有二：第一，输出不会丢失，因为它存储在一个文件中；第二，您可以使用 Unix 工具搜索和处理日志文件，如`grep(1)`、`awk(1)`、`sed(1)`，在终端窗口上打印消息时无法执行此操作。

# 关于伐木

所有 Unix 计算机都有一个单独的服务器进程来记录日志文件。在 macOS 机器上，进程的名称为`syslogd(8)`。另一方面，大多数 Linux 机器使用`rsyslogd(8)`，这是`syslogd(8)`的改进版和更可靠的版本，后者是最初用于消息记录的 Unix 系统实用程序。

但是，不管您使用的是 Unix 变体，还是用于记录的服务器进程的名称，记录在每台 Unix 机器上的工作方式都是相同的，因此不会影响您将要编写的 Go 代码。

查看一个或多个日志文件的最佳方法是借助`tail(1)`实用程序，然后是`-f`标志和要查看的日志文件的名称。`-f`标志告诉`tail(1)`等待其他数据。您需要通过按*Ctrl*+*C*来终止此`tail(1)`命令。

# 伐木设施

日志记录功能类似于用于记录信息的类别。日志设施部分的值可以是*auth*、*authpriv*、*cron*、*daemon*、*kern*、*lpr*、*mail*、*mark*、*news*、【T20 syslog、*中的任意一个用户*、*UUCP*、*local0*、*local1*、*local2*、*local3*、*local4*、*local5*、*local6*、*local7*；这是在`/etc/syslog.conf`、`/etc/rsyslog.conf`或其他适当的文件中定义的，具体取决于 Unix 机器上用于系统登录的服务器进程。这意味着，如果没有定义日志记录功能并因此进行处理，则发送给它的日志消息可能会丢失。

# 日志记录级别

**日志记录级别**或**优先级**是指定日志条目严重性的值。存在不同的日志级别，包括*调试*、*信息*、*通知*、*警告*、*错误*、*临界*、*警报*和【T18 紧急情况】，按严重程度的相反顺序。

查看 Linux 机器的`/etc/rsyslog.conf`文件，了解有关如何控制日志记录设施和日志记录级别的更多信息。

# syslog Go 包

本小节将介绍一个在所有 Unix 机器上运行的 Go 程序，并以各种方式将数据发送到日志服务。节目名称为`useSyslog.go`，分四部分介绍。

首先，您将看到预期的序言：

```go
package main 

import ( 
   "fmt" 
   "log" 
   "log/syslog" 
   "os" 
   "path/filepath" 
) 
```

您必须使用`log`包进行日志记录，使用`log/syslog`包定义程序的日志记录功能和日志记录级别。

第二部分如下：

```go
func main() { 
   programName := filepath.Base(os.Args[0]) 
   sysLog, e := syslog.New(syslog.LOG_INFO|syslog.LOG_LOCAL7, programName) 
   if e != nil { 
         log.Fatal(e) 
   } 
   sysLog.Crit("Crit: Logging in Go!") 
```

返回 writer 的`syslog.New()`函数调用告诉程序将所有日志消息定向到何处。好在你已经知道如何使用作家了！

请注意，开发人员应该定义程序使用的优先级和功能。

然而，即使具有定义的优先级和功能，`log/syslog`包也允许您使用`sysLog.Crit()`等功能向其他优先级发送直接日志消息。

该计划的第三部分如下：

```go
   sysLog, e = syslog.New(syslog.LOG_ALERT|syslog.LOG_LOCAL7, "Some program!") 
   if e != nil { 
         log.Fatal(sysLog) 
   } 
sysLog.Emerg("Emerg: Logging in Go!") 
```

这部分说明您可以在同一个程序中多次调用`syslog.New()`。再次，调用`Emerg()`函数允许您绕过`syslog.New()`函数定义的内容。

最后一部分是以下内容：

```go
   fmt.Fprintf(sysLog, "log.Print: Logging in Go!") 
} 
```

这是唯一一个使用`syslog.New()`定义的日志优先级和日志设施的调用，直接写入`sysLog`编写器。

执行`useLog.go`将在屏幕上生成一些输出，但也会将数据写入相应的日志文件。在 macOS Sierra 或 Mac OS X 机器上，您将看到以下内容：

```go
$ go run useSyslog.go

Broadcast Message from _iconservices@iMac.local
        (no tty) at 18:01 EEST...

Emerg: Logging in Go!
$ grep "Logging in Go" /var/log/* 2>/dev/null
/var/log/system.log:May 19 18:01:31 iMac useSyslog[22608]: Crit: Logging in Go!
/var/log/system.log:May 19 18:01:31 iMac Some program![22608]: Emerg: Logging in Go!
/var/log/system.log:May 19 18:01:31 iMac Some program![22608]: log.Print: Logging in Go!
```

在 Debian Linux 机器上，您将看到以下结果：

```go
$ go run useSyslog.go

Message from syslogd@mail at May 19 18:03:00 ...
Some program![1688]: Emerg: Logging in Go!
$
Broadcast message from systemd-journald@mail (Fri 2017-05-19 18:03:00 EEST):

useSyslog[1688]: Some program![1688]: Emerg: Logging in Go!
$ tail -5 /var/log/syslog
May 19 18:03:00 mail useSyslog[1688]: Crit: Logging in Go!
May 19 18:03:00 mail Some program![1688]: Emerg: Logging in Go!
May 19 18:03:00 mail Some program![1688]: log.Print: Logging in Go!
$ grep "Logging in Go" /var/log/* 2>/dev/null
/var/log/cisco.log:May 19 18:03:00 mail useSyslog[1688]: Crit: Logging in Go!
/var/log/cisco.log:May 19 18:03:00 mail Some program![1688]: Emerg: Logging in Go!
/var/log/cisco.log:May 19 18:03:00 mail Some program![1688]: log.Print: Logging in Go!
/var/log/syslog:May 19 18:03:00 mail useSyslog[1688]: Crit: Logging in Go!
/var/log/syslog:May 19 18:03:00 mail Some program![1688]: Emerg: Logging in Go!
/var/log/syslog:May 19 18:03:00 mail Some program![1688]: log.Print: Logging in Go!
```

两台机器的输出表明 Linux 机器具有不同的`syslog`配置，这就是`useLog.go`的消息也被写入`/var/log/cisco.log`的原因。

但是，您主要关心的不应该是日志消息是否会写入太多的文件；而是你是否能找到它们！

# 处理日志文件

本小节将处理包含客户端 IP 地址的日志文件，以便创建这些地址的摘要。Go 文件的名称为`countIP.go`，分为四个部分。注意，`countIP.go`需要两个参数：日志文件的名称和包含所需信息的字段。由于`countIP.go`不检查给定字段是否包含 IP 地址，因此如果您删除其部分代码，它也可以用于其他类型的数据。

首先，您将看到计划的预期前言：

```go
package main 

import ( 
   "bufio" 
   "flag" 
   "fmt" 
   "io" 
   "net" 
   "os" 
   "path/filepath" 
   "strings" 
) 
```

第二部分附带以下 Go 代码，这是`main()`功能实现的开始：

```go
func main() { 
   minusCOL := flag.Int("COL", 1, "Column") 
   flag.Parse() 
   flags := flag.Args() 

   if len(flags) == 0 { 
         fmt.Printf("usage: %s <file1> [<file2> [... <fileN]]\n", filepath.Base(os.Args[0])) 
         os.Exit(1) 
   } 

   column := *minusCOL 
   if column < 0 {
         fmt.Println("Invalid Column number!") 
         os.Exit(1) 
   } 
```

`countIP.go`实用程序使用`flag`包，可以处理多个文件。

该计划的第三部分如下：

```go
   myIPs := make(map[string]int) 
   for _, filename := range flags { 
         fmt.Println("\t\t", filename) 
         f, err := os.Open(filename) 
         if err != nil { 
               fmt.Printf("error opening file %s\n", err) 
               continue 
         } 
         defer f.Close() 

         r := bufio.NewReader(f) 
         for { 
               line, err := r.ReadString('\n') 

               if err == io.EOF { 
                     break 
               } else if err != nil { 
                     fmt.Printf("error reading file %s", err) 
                     continue 
               } 
```

每个输入文件逐行读取，而`myIPs`map 变量用于保存每个 IP 地址的计数。

`countIP.go`的最后一部分如下：

```go
               data := strings.Fields(line) 
               ip := data[column-1] 
               trial := net.ParseIP(ip) 
               if trial.To4() == nil { 
                     continue 
               } 

               _, ok := myIPs[ip] 
               if ok { 
                     myIPs[ip] = myIPs[ip] + 1 
               } else { 
                     myIPs[ip] = 1 
               } 
         } 
   } 

   for key, _ := range myIPs { 
         fmt.Printf("%s %d\n", key, myIPs[key]) 
   } 
} 
```

这里是魔术发生的地方：首先，从工作行中提取所需的字段。然后，使用`net.ParseIP()`函数确保您处理的是有效的 IP 地址：如果您希望程序处理其他类型的数据，则应删除使用`net.ParseIP()`函数的 Go 代码。之后，您会根据是否在地图中找到当前 IP 地址来更新`myIPs`地图的内容：您在[第 2 章](02.html)*中看到了该代码，在 Go*中编写程序。最后，在屏幕上打印`myIPs`地图的内容，就完成了！

执行`countIP.go`生成以下输出：

```go
$ go run countIP.go /tmp/log.1 /tmp/log.2
             /tmp/log.1
             /tmp/log.2
164.132.161.85 4
66.102.8.135 17
5.248.196.10 15
180.76.15.10 12
66.249.69.40 142
51.255.65.35 7
95.158.53.56 1
64.183.178.218 31
$ go run countIP.go /tmp/log.1 /tmp/log.2 | wc
    1297    2592   21266
```

但是，如果按照与每个 IP 地址相关联的计数对输出进行排序会更好，这可以在`sort(1)`Unix 实用程序的帮助下轻松完成：

```go
$ go run countIP.go /tmp/log.1 /tmp/log.2 | sort -rn -k2
45.55.38.245 979
159.203.126.63 976
130.193.51.27 698
5.9.63.149 370
77.121.238.13 340
46.4.116.197 308
51.254.103.60 302
51.255.194.31 277
195.74.244.47 201
61.14.225.57 179
69.30.198.242 152
66.249.69.40 142
2.86.9.124 140
2.86.27.46 127
66.249.69.18 125
```

如果您想要前 10 个 IP 地址，可以使用`head(1)`实用程序过滤之前的输出，如下所示：

```go
$ go run countIP.go /tmp/log.1 /tmp/log.2 | sort -rn -k2 | head
45.55.38.245 979
159.203.126.63 976
130.193.51.27 698
5.9.63.149 370
77.121.238.13 340
46.4.116.197 308
51.254.103.60 302
51.255.194.31 277
195.74.244.47 201
61.14.225.57 179
```

# 重新访问文件权限

有时我们需要查找有关文件的 Unix 权限的详细信息。`filePerm.go`Go 实用程序将教您如何读取文件或目录的 Unix 文件权限，并将其打印为二进制数、十进制数和字符串。该计划将分三部分介绍。第一部分如下：

```go
package main 

import ( 
   "fmt" 
   "os" 
   "path/filepath" 
) 
```

第二部分内容如下：

```go
func tripletToBinary(triplet string) string { 
   if triplet == "rwx" { 
         return "111" 
   } 
   if triplet == "-wx" { 
         return "011" 
   } 
   if triplet == "--x" { 
         return "001" 
   } 
   if triplet == "---" { 
         return "000" 
   } 
   if triplet == "r-x" { 
         return "101" 
   } 
   if triplet == "r--" { 
         return "100" 
   } 
   if triplet == "--x" { 
         return "001" 
   } 
   if triplet == "rw-" { 
         return "110" 
   } 
   if triplet == "-w-" { 
         return "010" 
   } 
   return "unknown" 
} 

func convertToBinary(permissions string) string { 
   binaryPermissions := permissions[1:] 
   p1 := binaryPermissions[0:3] 
   p2 := binaryPermissions[3:6] 
   p3 := binaryPermissions[6:9] 
   return tripletToBinary(p1) + tripletToBinary(p2) + tripletToBinary(p3) 
} 
```

在这里，您实现了两个函数，这两个函数将帮助您将一个包含九个字符的字符串转换为二进制数，该字符串包含文件的权限。例如，`rwxr-x---`字符串将转换为`111101000`。初始字符串从`os.Stat()`函数调用中提取。

最后一部分包含以下 Go 代码：

```go
func main() { 
   arguments := os.Args 
   if len(arguments) == 1 { 
         fmt.Printf("usage: %s filename\n", filepath.Base(arguments[0])) 
         os.Exit(1) 
   } 

   filename := arguments[1] 
   info, _ := os.Stat(filename) 
   mode := info.Mode() 

   fmt.Println(filename, "mode is", mode) 
   fmt.Println("As string is", mode.String()[1:10]) 
   fmt.Println("As binary is", convertToBinary(mode.String())) 
} 
```

执行`filePerm.go`将生成以下输出：

```go
$ go run filePerm.go .
. mode is drwxr-xr-x
As string is rwxr-xr-x
As binary is 111101101
$ go run filePerm.go /tmp/swtag.log
/tmp/swtag.log mode is -rw-rw-rw-
As string is rw-rw-rw-
As binary is 110110110
```

# 更改文件权限

本节将解释如何将文件或目录的 Unix 权限更改为所需的值；但是，它不会处理粘性位、设置用户 ID 位或设置组 ID 位：这不是因为它们难以实现，而是因为在处理系统文件时通常不需要这些。

本实用程序的名称为`setFilePerm.go`，分为四个部分。新文件权限将以九个字符的字符串形式授予，如`rwxrw-rw-`。

`setFilePerm.go`的第一部分包含预期的前导 Go 代码：

```go
package main 

import ( 
   "fmt" 
   "os" 
   "path/filepath" 
   "strconv" 
) 
```

第二部分是您在上一节中看到的`tripletToBinary()`功能的实现：

```go
func tripletToBinary(triplet string) string { 
   if triplet == "rwx" { 
         return "111" 
   } 
   if triplet == "-wx" { 
         return "011" 
   } 
   if triplet == "--x" { 
         return "001" 
   } 
   if triplet == "---" { 
         return "000" 
   } 
   if triplet == "r-x" { 
         return "101" 
   } 
   if triplet == "r--" { 
         return "100" 
   } 
   if triplet == "--x" { 
         return "001" 
   } 
   if triplet == "rw-" { 
         return "110" 
   } 
   if triplet == "-w-" { 
         return "010" 
   } 
   return "unknown" 
} 
```

第三部分包含以下 Go 代码：

```go
func convertToBinary(permissions string) string { 
   p1 := permissions[0:3] 
   p2 := permissions[3:6] 
   p3 := permissions[6:9] 

   p1 = tripletToBinary(p1) 
   p2 = tripletToBinary(p2) 
   p3 = tripletToBinary(p3) 

   p1Int, _ := strconv.ParseInt(p1, 2, 64) 
   p2Int, _ := strconv.ParseInt(p2, 2, 64) 
   p3Int, _ := strconv.ParseInt(p3, 2, 64) 

   returnValue := p1Int*100 + p2Int*10 + p3Int 
   tempReturnValue := int(returnValue) 
   returnString := "0" + strconv.Itoa(tempReturnValue) 
   return returnString 
} 
```

在这里，函数名有误导性，因为它不返回二进制数：这是我的错。

最后一部分包含以下 Go 代码：

```go
func main() { 
   arguments := os.Args 
   if len(arguments) != 3 { 
         fmt.Printf("usage: %s filename permissions\n",  
filepath.Base(arguments[0])) 
         os.Exit(1) 
   } 

   filename, _ := filepath.EvalSymlinks(arguments[1]) 
   permissions := arguments[2] 
   if len(permissions) != 9 { 
         fmt.Println("Permissions should be 9 characters  
(rwxrwxrwx):", permissions) 
         os.Exit(-1) 
   } 

   bin := convertToBinary(permissions) 
   newPerms, _ := strconv.ParseUint(bin, 0, 32) 
   newMode := os.FileMode(newPerms) 
   os.Chmod(filename, newMode) 
} 
```

在这里，您得到返回值`convertToBinary()`并将其转换为`os.FileMode()`变量，以便与`os.Chmod()`函数一起使用。

运行`setFilePerm.go`会产生以下结果：

```go
$ go run setFilePerm.go /tmp/swtag.log rwxrwxrwx
$ ls -l /tmp/swtag.log
-rwxrwxrwx  1 mtsouk  wheel  7066 May 22 19:17 /tmp/swtag.log
$ go run setFilePerm.go /tmp/swtag.log rwxrwx---
$ ls -l /tmp/swtag.log
-rwxrwx---  1 mtsouk  wheel  7066 May 22 19:17 /tmp/swtag.log
```

# 查找有关文件的其他类型的信息

有关 Unix 文件的最重要信息是其所有者和组，本节将教您如何使用 Go 代码查找这两个文件。`findOG.go`实用程序接受文件列表作为其命令行参数，并返回每个文件的所有者和组。其 Go 代码将分为三个部分。

第一部分如下：

```go
package main 

import ( 
   "fmt" 
   "os" 
   "path/filepath" 
   "syscall" 
) 
```

第二部分如下：

```go
func main() { 
   arguments := os.Args 
   if len(arguments) == 1 { 
         fmt.Printf("usage: %s <files>\n", filepath.Base(arguments[0])) 
         os.Exit(1) 
   } 

   for _, filename := range arguments[1:] { 
         fileInfo, err := os.Stat(filename) 
         if err != nil { 
               fmt.Println(err) 
               continue 
         } 
```

在本部分中，您将调用`os.Stat()`函数以确保要处理的文件存在。

`findOG.go`的最后一部分带有以下 Go 代码：

```go
         fmt.Printf("%+v\n", fileInfo.Sys()) 
         fmt.Println(fileInfo.Sys().(*syscall.Stat_t).Uid) 
         fmt.Println(fileInfo.Sys().(*syscall.Stat_t).Gid) 
   } 
} 
```

是的，这是您在本书中看到的最神秘的代码，它使用返回值`os.Stat()`提取所需信息。此外，它既不是可移植的，这意味着它可能无法在您的 Unix 变体上工作，也不能确保它将在即将发布的 Go 版本中继续工作！

有时，看似简单的任务可能会占用你比预期更多的时间。其中一项任务是`findOG.go`程序。这主要是因为 Go 没有一种简单且可移植的方法来查找文件的所有者和组。希望这在未来会有所改变。

在 macOS Sierra 或 macOS X 上执行`findOG.go`将生成以下输出：

```go
$ go run findOG.go /tmp/swtag.log
&{Dev:16777218 Mode:33206 Nlink:1 Ino:50547755 Uid:501 Gid:0 Rdev:0 Pad_cgo_0:[0 0 0 0] Atimespec:{Sec:1495297106 Nsec:0} Mtimespec:{Sec:1495297106 Nsec:0} Ctimespec:{Sec:1495297106 Nsec:0} Birthtimespec:{Sec:1495044975 Nsec:0} Size:2586 Blocks:8 Blksize:4096 Flags:0 Gen:0 Lspare:0 Qspare:[0 0]}
501
0
$ ls -l /tmp/swtag.log
-rw-rw-rw-  1 mtsouk  wheel  2586 May 20 19:18 /tmp/swtag.log
$ grep wheel /etc/group
wheel:*:0:root 
```

在这里，您可以看到，`fileInfo.Sys()`调用以某种令人费解的格式从文件返回大量信息：这些信息类似于对`stat(2)`的 C 调用。输出的第一行是`os.Stat.Sys()`调用的内容，第二行是文件所有者的用户 ID（`501`），第三行是文件所有者的组 ID（`0`）。

在 Debian Linux 机器上执行`findOG.go`将生成以下输出：

```go
$ go run findOG.go /home/mtsouk/connections.data
&{Dev:2048 Ino:1196167 Nlink:1 Mode:33188 Uid:1000 Gid:1000 X__pad0:0 Rdev:0 Size:9626800 Blksize:4096 Blocks:18840 Atim:{Sec:1412623801 Nsec:0} Mtim:{Sec:1495307521 Nsec:929812185} Ctim:{Sec:1495307521 Nsec:929812185} X__unused:[0 0 0]}
1000
1000
$ ls -l /home/mtsouk/connections.data
-rw-r--r-- 1 mtsouk mtsouk 9626800 May 20 22:12 /home/mtsouk/connections.data
code$ grep ^mtsouk /etc/group
mtsouk:x:1000:
```

好消息是`findOG.go`在 macOS Sierra 和 Debian Linux 上都能工作，尽管 macOS Sierra 使用的是 Go 版本 1.8.1，Debian Linux 使用的是 Go 版本 1.3.3！

本章后面将使用所提供的大部分 Go 代码来实现`userFiles.go`实用程序。

# 更多模式匹配示例

本节将介绍正则表达式，这些正则表达式比您在本书中看到的更难匹配的模式。请记住，正则表达式和模式匹配是实用的主题，您应该通过实验来学习，有时失败，而不是阅读它们。

如果您非常小心地使用 Go 中的正则表达式，您可以轻松地读取或更改 Unix 系统中几乎所有纯文本格式的系统文件。修改系统文件时要格外小心！

# 一个简单的模式匹配示例

本节的示例将通过开发一个自动检测具有 IP 地址的字段的程序来改进`countIP.go`实用程序的功能；因此，它不需要用户定义包含 IP 地址的每个日志条目的字段。为了简化操作，创建的程序将只处理每行的第一个 IP 地址：`findIP.go`采用单个命令行参数，这是要处理的日志文件的名称。该计划将分为四个部分。

`findIP.go`的第一部分如下：

```go
package main 

import ( 
   "bufio" 
   "fmt" 
   "io" 
   "net" 
   "os" 
   "path/filepath" 
   "regexp" 
) 
```

第二部分是在函数的帮助下实现大部分魔法的地方：

```go
func findIP(input string) string { 
   partIP := "(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])" 
   grammar := partIP + "\\." + partIP + "\\." + partIP + "\\." + partIP 
   matchMe := regexp.MustCompile(grammar) 
   return matchMe.FindString(input) 
} 
```

正则表达式非常复杂，因为我们只想匹配 0-255 范围内由点分隔的四个十进制数，这主要表明正则表达式在需要有条理的时候可能非常复杂。

但让我更详细地解释一下。IP 地址有四个部分，用点分隔。这些部分中的每一部分都可以有一个介于 0 和 255 之间的值，这意味着数字 257 不是一个可接受的值：这是正则表达式如此复杂的主要原因。第一种情况是 250 到 255 之间的数字。第二种情况适用于 200 和 249 之间的数字，第三种情况适用于 100 和 199 之间的数字。最后一种情况是捕捉 0 到 99 之间的值。

`findIP.go`的第三部分如下：

```go
func main() { 
   if len(os.Args) != 2 { 
         fmt.Printf("usage: %s logFile\n", filepath.Base(os.Args[0])) 
         os.Exit(1) 
   } 
   filename := os.Args[1] 

   f, err := os.Open(filename) 
   if err != nil { 
         fmt.Printf("error opening file %s\n", err) 
         os.Exit(-1) 
   } 
   defer f.Close() 

   myIPs := make(map[string]int) 
   r := bufio.NewReader(f) 
   for { 
         line, err := r.ReadString('\n') 
         if err == io.EOF { 
               break 
         } else if err != nil { 
               fmt.Printf("error reading file %s", err) 
               break 
         } 
```

在这里，您使用`bufio.NewReader()`逐行读取输入日志文件。

最后一部分包含以下 Go 代码，用于处理正则表达式的匹配：

```go
         ip := findIP(line) 
         trial := net.ParseIP(ip) 
         if trial.To4() == nil { 
               continue 
         } else { 
               _, ok := myIPs[ip] 
               if ok { 
                     myIPs[ip] = myIPs[ip] + 1 
               } else { 
                     myIPs[ip] = 1 
               } 
         } 
   } 
   for key, _ := range myIPs { 
         fmt.Printf("%s %d\n", key, myIPs[key]) 
   } 
} 
```

如您所见，`findIP.go`使用`net.ParseIP()`对执行模式匹配操作的函数找到的 IP 执行附加检查；这主要是因为 IP 地址非常棘手，并且反复检查它们被认为是一种良好的做法！此外，这捕获了以下情况：`findIP()`因为在处理的行中找不到有效的 IP 而不返回任何内容。程序在退出之前做的最后一件事是打印`myIPs`地图的内容。

考虑一下你能用少量 GO 代码开发出多少难以置信和有用的工具：它真是太神奇了！

在 Linux 机器上执行`findIP.go`以处理`/var/log/auth.log`日志文件将创建以下输出：

```go
$ wc /var/log/auth.log
  1499647  20313719 155224677 /var/log/auth.log
$ go run findIP.go /var/log/auth.log
39.114.101.107 1003
111.224.233.41 10
189.41.147.179 306
55.31.112.181 1
5.141.131.102 10
171.60.251.143 30
218.237.65.48 1
24.16.210.120 8
199.115.116.50 3
139.160.113.181 1
```

您可以按找到 IP 的次数对以前的输出进行排序，并显示 10 个最常用的 IP 地址，如下所示：

```go
$ go run findIP.go /var/log/auth.log | sort -nr -k2 | head
218.65.30.156 102533
61.177.172.27 37746
218.65.30.43 34640
109.74.11.18 32870
61.177.172.55 31968
218.65.30.124 31649
59.63.188.3 30970
61.177.172.28 30023
116.31.116.30 29314
61.177.172.14 28615
```

因此，在本例中，`findIP.go`实用程序用于检查 Linux 机器的安全性！

# 模式匹配的高级示例

在本节中，您将学习如何交换文本文件每行的两个字段的值，前提是它们的格式正确。这主要发生在日志文件或其他文本文件中，在这些文件中，您希望扫描一行以查找特定类型的数据，如果找到数据，您可能需要对其进行处理：在这种情况下，您将更改这两个值的位置。

节目名称为`swapRE.go`，分四部分介绍。同样，程序将逐行读取文本文件，并在交换字符串之前尝试匹配所需字符串。该实用程序将在屏幕上打印新文件的内容；用户有责任将结果保存到新文件中。`swapRE.go`希望处理的日志条目的格式如下：

```go
127.0.0.1 - - [24/May/2017:06:41:11 +0300] "GET /contact HTTP/1.1" 200 6048 "http://www.mtsoukalos.eu/" "Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko" 132953
```

程序将交换的前一行中的条目是[`24/May/2017:06:41:11 +0300`和`132953`，分别是日期和时间以及浏览器获取所需信息所花费的时间；程序希望在每一行的末尾找到这个。但是，正则表达式还检查日期和时间的格式是否正确，以及每个日志条目的最后一个字段是否确实是一个数字。

正如您将看到的，在 Go 中使用正则表达式有时会令人困惑，主要是因为一般来说，正则表达式的构建相对比较困难。

`swapRE.go`的第一部分将是预期的序言：

```go
package main 

import ( 
   "bufio" 
   "flag" 
   "fmt" 
   "io" 
   "os" 
   "regexp" 
) 
```

第二部分包含以下 Go 代码：

```go
func main() { 
   flag.Parse() 
   if flag.NArg() != 1 { 
         fmt.Println("Please provide one log file to process!") 
         os.Exit(-1) 
   } 
   numberOfLines := 0 
   numberOfLinesMatched := 0 

   filename := flag.Arg(0) 
   f, err := os.Open(filename) 
   if err != nil { 
         fmt.Printf("error opening file %s", err) 
         os.Exit(1) 
   } 
   defer f.Close() 
```

这里没有什么特别有趣或新鲜的东西。

第三部分如下：

```go
   r := bufio.NewReader(f) 
   for { 
         line, err := r.ReadString('\n') 
         if err == io.EOF { 
               break 
         } else if err != nil { 
               fmt.Printf("error reading file %s", err) 
         } 
```

下面是允许您逐行处理输入文件的 Go 代码。

`swapRE.go`的最后一部分如下：

```go
         numberOfLines++ 
         r := regexp.MustCompile(`(.*) (\[\d\d\/(\w+)/\d\d\d\d:\d\d:\d\d:\d\d(.*)\]) (.*) (\d+)`) 
         if r.MatchString(line) { 
               numberOfLinesMatched++ 
               match := r.FindStringSubmatch(line) 
               fmt.Println(match[1], match[6], match[5], match[2]) 
         } 
   } 
   fmt.Println("Line processed:", numberOfLines) 
   fmt.Println("Line matched:", numberOfLinesMatched) 
} 
```

正如您所想象的，复杂的正则表达式（如本文所示）是一步一步构建的，而不是一次完成的。即使在这种情况下，您仍然可能会在这个过程中失败很多次，因为即使是复杂正则表达式中最微小的错误也会导致它无法达到预期的效果：广泛的测试是这里的关键！

正则表达式中使用的括号允许您在以后引用每个匹配项，并且在您想要处理已匹配项时非常方便。你想在这里找到一个`[`字符，然后是两位数字，表示月份的日期，然后是一个单词，表示月份的名称，然后是四位数字，表示年份。接下来，匹配任何其他字符，直到找到一个`]`字符。然后匹配每行末尾的所有数字。

请注意，可能存在编写相同正则表达式的替代方法。这里的一般建议是用一种清晰易懂的方式来写。

执行`swapRE.gowith`时，一个小的测试日志文件将生成以下输出：

```go
$ go run swapRE.go /tmp/log.log
127.0.0.1 - - 28787 "GET /taxonomy/term/35/feed HTTP/1.1" 200 2360 "-" "Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)" [24/May/2017:07:04:48 +0300]
- - 32145 HTTP/1.1" 200 2616 "http://www.mtsoukalos.eu/" "Mozilla/5.0 (compatible; inoreader.com-like FeedFetcher-Google)" [24/May/2017:07:09:24 +0300]
Line processed: 3
Line matched: 2
```

# 使用正则表达式重命名多个文件

关于模式匹配和正则表达式的最后一节将讨论文件名，并允许您重命名多个文件。正如您所猜测的，程序中将使用 walk 函数，而正则表达式将匹配您要重命名的文件名。

在处理文件时，你应该格外小心，因为你可能会意外地破坏东西！简单地说，不要在生产服务器上测试这些实用程序。

实用程序的名称为`multipleMV.go`，将分三部分介绍。`multipleMV.go`将在每个与给定正则表达式匹配的文件名前面插入一个字符串。

第一部分是预期的序言：

```go
package main 

import ( 
   "flag" 
   "fmt" 
   "os" 
   "path/filepath" 
   "regexp" 
) 

var RE string
var renameString string 
```

这两个全局变量使您不必在函数中使用许多参数。此外，由于`walk()`函数的签名在一段时间内无法更改，因此无法将其作为参数传递给`walk()`。因此，在这种情况下，有两个全局参数会使事情变得更简单。

第二部分包含以下 Go 代码：

```go
func walk(path string, f os.FileInfo, err error) error { 
   regex, err := regexp.Compile(RE) 
   if err != nil { 
         fmt.Printf("Error in RE: %s\n", RE) 
         return err 
   } 

   if path == "." { 
         return nil 
   } 
   nameOfFile := filepath.Base(path) 
   if regex.MatchString(nameOfFile) { 
         newName := filepath.Dir(path) + "/" + renameString + "_" + nameOfFile 
         os.Rename(path, newName) 
   } 
   return nil 
} 
```

程序的所有功能都嵌入到`walk()`函数中。成功匹配后，在执行`os.Rename()`函数之前，新文件名存储在`newName`变量中。

`multipleMV.go`的最后一部分是`main()`功能的实现：

```go
func main() { 
   flag.Parse() 
   if flag.NArg() != 3 { 
         fmt.Printf("Usage: %s REGEXP RENAME Path", filepath.Base(os.Args[0])) 
         os.Exit(-1) 
   } 

   RE = flag.Arg(0) 
   renameString = flag.Arg(1) 
   Path := flag.Arg(2) 
   Path, _ = filepath.EvalSymlinks(Path) 
   filepath.Walk(Path, walk) 
} 
```

在这里，没有什么是你以前没有见过的：唯一有趣的事情是调用`filepath.EvalSymlinks()`，以便不必处理符号链接。

使用`multipleMV.go`与运行以下命令一样简单：

```go
$ ls -l /tmp/swtag.log
-rw-rw-rw-  1 mtsouk  wheel  446 May 22 09:18 /tmp/swtag.log
$ go run multipleMV.go 'log$' new /tmp
$ ls -l /tmp/new_swtag.log
-rw-rw-rw-  1 mtsouk  wheel  446 May 22 09:18 /tmp/new_swtag.log
$ go run multipleMV.go 'log$' new /tmp
$ ls -l /tmp/new_new_swtag.log
-rw-rw-rw-  1 mtsouk  wheel  446 May 22 09:18 /tmp/new_new_swtag.log
$ go run multipleMV.go 'log$' new /tmp
$ ls -l /tmp/new_new_new_swtag.log
-rw-rw-rw-  1 mtsouk  wheel  446 May 22 09:18 /tmp/new_new_new_swtag.log 
```

# 重新搜索文件

本节将教您如何使用用户 ID、组 ID 和文件权限等条件查找文件。虽然这一部分可能包含在[第 5 章](05.html)*文件和目录*中，但我还是决定将其放在这里，因为有时您会想使用此类信息来通知系统管理员系统有问题。

# 查找用户的用户 ID

本小节将提供一个程序，显示给定用户名的用户 ID，该用户名或多或少是`id -u`实用程序的输出：

```go
$ id -u
33
$ id -u root
0
```

事实上，存在一个名为`user`的 Go 包，可以在`os`包下找到，它可以帮助您实现所需的任务，这一点不应该让您感到惊讶。节目名称为`userID.go`，分两部分呈现。如果`userID.go`没有命令行参数，则打印当前用户的用户 ID；否则，它将打印给定用户名的用户 ID。

`userID.go`的第一部分如下：

```go
package main 

import ( 
   "fmt" 
   "os" 
   "os/user" 
) 

func main() { 
   arguments := os.Args 
   if len(arguments) == 1 { 
         uid := os.Getuid() 
         fmt.Println(uid) 
         return 
   } 
```

`os.Getuid()`函数返回当前用户的用户 ID。

`userID.go`的第二部分带有以下 Go 代码：

```go
   username := arguments[1] 
   u, err := user.Lookup(username) 
   if err != nil { 
         fmt.Println(err) 
         return 
   } 
   fmt.Println(u.Uid) 
}

```

给定用户名，`user.Lookup()`函数返回一个`user.User`复合值。我们将只使用该复合值的`Uid`字段来查找给定用户名的用户 ID。

执行`userID.go`将生成以下输出：

```go
$ go run userID.go
501
$ go run userID.go root
0
$ go run userID.go doesNotExist
user: unknown user doesNotExist
```

# 查找用户所属的所有组

每个用户可以属于多个组：本节将展示如何根据用户的用户名查找用户所属组的列表。

本实用程序的名称为`listGroups.go`，分为四个部分。`listGroups.go`的第一部分如下：

```go
package main 

import ( 
   "fmt" 
   "os" 
   "os/user" 
) 
```

第二部分具有以下 Go 代码：

```go
func main() { 
   arguments := os.Args 
   var u *user.User 
   var err error 
   if len(arguments) == 1 { 
         u, err = user.Current() 
         if err != nil { 
               fmt.Println(err) 
               return 
         } 
```

当没有命令行参数时，`listGroups.go`采用的方法与`userID.go`中的方法类似。但是，有一个很大的区别，因为这次您不需要当前用户的用户 ID，而是需要当前用户的用户名；所以你调用`user.Current()`，它返回一个`user.User`值。

第三部分包含以下 Go 代码：

```go
   } else { 
         username := arguments[1] 
         u, err = user.Lookup(username) 
         if err != nil { 
               fmt.Println(err) 
               return 
         } 
   } 
```

因此，如果向程序提供了一个命令行参数，那么它将由前面的代码在`user.Lookup()`函数的帮助下进行处理，该函数还返回一个`user.User`值。

最后一部分包含以下 Go 代码：

```go
   gids, _ := u.GroupIds() 
   for _, gid := range gids { 
         group, err := user.LookupGroupId(gid) 
         if err != nil { 
               fmt.Println(err) 
               continue 
         } 
         fmt.Printf("%s(%s) ", group.Gid, group.Name) 
   } 
   fmt.Println() 
} 
```

在这里，通过调用`u.GroupIds()`函数，您可以得到由`u`变量表示的用户是其成员的组 ID 列表。然后，您将需要一个`for`循环来迭代所有列表元素并打印它们。需要明确的是，该列表存储在`u`中；也就是一个`user.User`值。

执行`listGroups.go`将生成以下输出：

```go
$ go run listGroups.go
    20(staff) 701(com.apple.sharepoint.group.1) 12(everyone) 61(localaccounts) 79(_appserverusr) 80(admin) 81(_appserveradm) 98(_lpadmin) 33(_appstore) 100(_lpoperator) 204(_developer) 395(com.apple.access_ftp) 398(com.apple.access_screensharing) 399(com.apple.access_ssh)
$ go run listGroups.go www
70(_www) 12(everyone) 61(localaccounts) 701(com.apple.sharepoint.group.1) 100(_lpoperator)
```

`listGroups.go`的输出比`id -G -n`和`groups`命令的输出丰富得多：

```go
$ id -G -n
staff com.apple.sharepoint.group.1 everyone localaccounts _appserverusr admin _appserveradm _lpadmin _appstore _lpoperator _developer com.apple.access_ftp com.apple.access_screensharing com.apple.access_ssh
$ groups
staff com.apple.sharepoint.group.1 everyone localaccounts _appserverusr admin _appserveradm _lpadmin _appstore _lpoperator _developer com.apple.access_ftp com.apple.access_screensharing com.apple.access_ssh
```

# 查找属于或不属于给定用户的文件

本小节将创建一个 Go 程序，该程序扫描目录树并显示属于或不属于给定用户的文件。该程序的名称将为`userFiles.go`。在默认操作模式下，`userFiles.go`将显示属于给定用户名的所有文件；当与`-no`标志一起使用时，它将只显示不属于给定用户名的文件。

`userFiles.go`的代码将分为四个部分。

第一个是：

```go
package main 

import ( 
   "flag" 
   "fmt" 
   "os" 
   "os/user" 
   "path/filepath" 
   "strconv" 
   "syscall" 
) 

var uid int32 = 0
var INCLUDE bool = true 
```

将`INCLUDE`和`uid`声明为全局变量的原因是您希望它们都可以从程序的每个点访问。此外，由于`walkFunction()`的签名不能更改：只有其名称可以更改：使用全局变量使开发人员的工作更轻松。

第二部分包含以下 Go 代码：

```go
func userOfFIle(filename string) int32 { 
   fileInfo, err := os.Stat(filename) 
   if err != nil { 
         fmt.Println(err) 
         return 1000000 
   } 
   UID := fileInfo.Sys().(*syscall.Stat_t).Uid 
   return int32(UID) 
} 
```

考虑到有一个名为`uid`的全局变量，使用名为`UID`的局部变量可能是一个糟糕的选择！全局变量的更好名称应该是`gUID`。注意，为了解释返回`UID`变量的调用的工作方式，您应该在 Go 中搜索接口和类型转换，因为讨论它超出了本书的范围。

第三部分包含以下 Go 代码：

```go
func walkFunction(path string, info os.FileInfo, err error) error { 
   _, err = os.Lstat(path) 
   if err != nil { 
         return err 
   } 

   if userOfFIle(path) == uid && INCLUDE { 
         fmt.Println(path) 
   } else if userOfFIle(path) != uid && !(INCLUDE) { 
         fmt.Println(path) 
   } 

   return err 
} 
```

在这里，您可以看到 walk 函数的实现，该函数将访问给定目录树中的每个文件和目录，以便仅打印所需的文件名。

实用程序的最后一部分包含以下 Go 代码：

```go
func main() { 
   minusNO := flag.Bool("no", true, "Include") 
   minusPATH := flag.String("path", ".", "Path to Search") 
   flag.Parse() 
   flags := flag.Args() 

   INCLUDE = *minusNO 
   Path := *minusPATH 

   if len(flags) == 0 { 
         uid = int32(os.Getuid()) 
   } else { 
         u, err := user.Lookup(flags[0]) 
         if err != nil { 
               fmt.Println(err) 
               os.Exit(1) 
         } 
         temp, err := strconv.ParseInt(u.Uid, 10, 32) 
         uid = int32(temp) 
   } 

   err := filepath.Walk(Path, walkFunction) 
   if err != nil { 
         fmt.Println(err) 
   } 
} 
```

在这里，您将在调用`filepath.Walk()`函数之前处理`flag`包的配置。

执行`userFiles.go`生成以下输出：

```go
$ go run userFiles.go -path=/tmp www-data
/tmp/.htaccess
/tmp/update-cache-2a113cac
/tmp/update-extraction-2a113cac
```

如果您不提供任何命令行参数或标志，`userFiles.go`实用程序将假定您要在当前目录中搜索属于当前用户的文件：

```go
$ go run userFiles.go
.
appendData.go
countIP.go
```

因此，为了找到`/srv/www/www.highiso.net`目录中所有不属于`www-data`用户的文件，您应该执行以下命令：

```go
$ go run userFiles.go -no=false -path=/srv/www/www.highiso.net www-data
/srv/www/www.highiso.net/list.files
/srv/www/www.highiso.net/public_html/wp-content/.htaccess
/srv/www/www.highiso.net/public_html.UnderCon/.htaccess
```

# 基于权限查找文件

现在您已经知道如何查找文件的 Unix 权限，可以改进上一章中的`regExpFind.go`实用程序，以支持基于文件权限的搜索；但是，为了避免在没有任何实际原因的情况下在这里展示一个真正的大型围棋程序，展示的程序将是自主的，并且只支持基于权限查找文件。新实用程序的名称为`findPerm.go`，将分四个部分介绍。权限将在命令行中以字符串的形式给出，使用由`ls(1)`命令（`rwxr-xr--`命令）返回的格式。

该实用程序的第一部分如下所示：

```go
package main 

import ( 
   "fmt" 
   "os" 
   "path/filepath" 
) 

var PERMISSIONS string
```

`PERMISSIONS`变量被设置为全局变量，以便可以从程序中的任何位置访问，并且因为`walkFunction()`的签名不能更改。

`findPerm.go`的第二部分包含以下代码：

```go
func permissionsOfFIle(filename string) string { 
   info, err := os.Stat(filename) 
   if err != nil { 
         return "-1" 
   } 
   mode := info.Mode() 
   return mode.String()[1:10] 
} 
```

第三部分是`walkFunction()`的实施：

```go
func walkFunction(path string, info os.FileInfo, err error) error { 
   _, err = os.Lstat(path) 
   if err != nil { 
         return err 
   } 

   if permissionsOfFIle(path) == PERMISSIONS { 
         fmt.Println(path) 
   } 
   return err 
} 
```

`findPerm.go`的最后一部分如下：

```go
func main() { 
   arguments := os.Args 
   if len(arguments) != 3 { 
         fmt.Printf("usage: %s RootDirectory permissions\n",  
filepath.Base(arguments[0])) 
         os.Exit(1) 
   } 

   Path := arguments[1] 
   Path, _ = filepath.EvalSymlinks(Path) 
   PERMISSIONS = arguments[2] 

   err := filepath.Walk(Path, walkFunction) 
   if err != nil { 
         fmt.Println(err) 
   } 
} 
```

执行`findPerm.go`将生成以下输出：

```go
$ go run findPerm.go /tmp rw-------
/private/tmp/.adobeLockFile
$ ls -l /private/tmp/.adobeLockFile
-rw-------  1 mtsouk  wheel  0 May 19 14:36 /private/tmp/.adobeLockFile
```

# 日期和时间操作

本节将向您展示如何在围棋中使用日期和时间。此任务看起来可能无关紧要，但在您希望同步日志条目和错误消息等内容时，它可能非常重要。我们将从说明`time`包的一些功能开始。

# 玩弄日期和时间

本节将介绍一个名为`dateTime.go`的小型围棋程序，该程序演示如何在围棋中处理时间和日期。`dateTime.go`的代码将分三部分介绍。第一部分如下：

```go
package main 

import ( 
   "fmt" 
   "time" 
) 

func main() { 

   fmt.Println("Epoch time:", time.Now().Unix()) 
   t := time.Now() 
   fmt.Println(t, t.Format(time.RFC3339)) 
   fmt.Println(t.Weekday(), t.Day(), t.Month(), t.Year()) 
   time.Sleep(time.Second) 
   t1 := time.Now() 
   fmt.Println("Time difference:", t1.Sub(t)) 

   formatT := t.Format("01 January 2006") 
   fmt.Println(formatT) 
   loc, _ := time.LoadLocation("Europe/London") 
   londonTime := t.In(loc) 
   fmt.Println("London:", londonTime) 
```

在本部分中，您可以了解如何将日期从一种格式更改为另一种格式，以及如何在不同的时区中查找日期和时间。在`main()`函数开头使用的`time.Now()`函数返回当前时间。

第二部分如下：

```go
   myDate := "23 May 2017" 
   d, _ := time.Parse("02 January 2006", myDate) 
   fmt.Println(d) 

   myDate1 := "23 May 2016" 
   d1, _ := time.Parse("02 February 2006", myDate1) 
   fmt.Println(d1)

```

可用于创建您自己的解析格式的常量列表可在[中找到 https://golang.org/src/time/format.go](https://golang.org/src/time/format.go) 。Go 不像其他编程语言那样以 DDYYYYMM 或%D%Y%M 的形式定义日期或时间的格式，而是使用自己的方法。

在这里，您可以看到如何读取字符串并尝试将其转换为有效日期，成功（`d`）和失败（`d1`）。`d1`变量的问题在于`format`字符串中使用了`February`：您应该使用`January`。

`dateTime.go`的最后一部分带有以下 Go 代码：

```go
   myDT := "Tuesday 23 May 2017 at 23:36" 
   dt, _ := time.Parse("Monday 02 January 2006 at 15:04", myDT) 
   fmt.Println(dt) 
} 
```

这一部分还展示了如何将字符串转换为日期和时间，前提是该字符串采用预期的格式。

执行`dateTime.go`将生成以下输出：

```go
$ go run dateTime.go
Epoch time: 1495572122
2017-05-23 23:42:02.459713551 +0300 EEST 2017-05-23T23:42:02+03:00
Tuesday 23 May 2017
Time difference: 1.001749054s
05 May 2017
London: 2017-05-23 21:42:02.459713551 +0100 BST
2017-05-23 00:00:00 +0000 UTC
0001-01-01 00:00:00 +0000 UTC
2017-05-23 23:36:00 +0000 UTC
```

# 在日志文件中重新格式化时间

本节将介绍如何实现一个程序，该程序读取包含日期和时间信息的日志文件，以便转换每个日志条目中的时间格式。如果您有来自多个时区的不同服务器的日志文件，并且希望同步它们的时间，以便从它们的数据创建报告或将它们存储到数据库中，以便在其他时间处理它们，则可能需要此操作。

介绍的节目名称为`dateTimeLog.go`，分四部分介绍。

第一部分如下：

```go
package main 

import ( 
   "bufio" 
   "flag" 
   "fmt" 
   "io" 
   "os" 
   "regexp" 
   "strings" 
   "time" 
) 
```

第二部分包含以下 Go 代码：

```go
func main() { 
   flag.Parse() 
   if flag.NArg() != 1 { 
         fmt.Println("Please provide one log file to process!") 
         os.Exit(-1) 
   } 

   filename := flag.Arg(0) 
   f, err := os.Open(filename) 
   if err != nil { 
         fmt.Printf("error opening file %s", err) 
         os.Exit(1) 
   } 
   defer f.Close() 
```

在这里，您只需配置`flag`包并打开输入文件进行读取。

该计划的第三部分如下：

```go
   r := bufio.NewReader(f) 
   for { 
         line, err := r.ReadString('\n') 
         if err == io.EOF { 
               break 
         } else if err != nil { 
               fmt.Printf("error reading file %s", err) 
         } 
```

在这里，您逐行读取输入文件。

最后一部分是以下内容：

```go
         r := regexp.MustCompile(`.*\[(\d\d\/\w+/\d\d\d\d:\d\d:\d\d:\d\d.*)\] .*`) 
         if r.MatchString(line) { 
               match := r.FindStringSubmatch(line) 
               d1, err := time.Parse("02/Jan/2006:15:04:05 -0700", match[1]) 
               if err != nil { 
                     fmt.Println(err) 
               } 
               newFormat := d1.Format(time.RFC3339) 
               fmt.Print(strings.Replace(line, match[1], newFormat, 1)) 
         } 
   } 
} 
```

这里的总体思路是，一旦找到匹配项，就可以使用`time.Parse()`解析找到的日期和时间，然后使用`time.Format()`函数将其转换为所需的格式。此外，在使用`strings.Replace()`打印之前，您将初始匹配替换为`time.Format()`函数的输出。

执行`dateTimeLog.go`将生成以下输出：

```go
$ go run dateTimeLog.go /tmp/log.log
127.0.0.1 - - [2017-05-24T07:04:48+03:00] "GET /taxonomy/term/35/feed HTTP/1.1" 200 2360 "-" "Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)" 28787
- - [2017-05-24T07:09:24+03:00] HTTP/1.1" 200 2616 "http://www.mtsoukalos.eu/" "Mozilla/5.0 (compatible; inoreader.com-like FeedFetcher-Google)" 32145
[2017-05-24T07:38:08+03:00] "GET /tweets?page=181 HTTP/1.1" 200 8605 "-" "Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)" 100531
```

# 旋转日志文件

日志文件总是越来越大，因为数据总是被写入其中；最好有一种旋转它们的技术。本节将介绍这种技术。Go 计划的名称为`rotateLog.go`，分三部分介绍。请注意，对于要旋转日志文件的进程，该进程必须是打开该日志文件进行写入的进程。尝试旋转您不拥有的日志可能会在 Unix 计算机上产生问题，应该避免！

这里您还将看到另一种技术，您使用自己的日志文件来存储日志条目，借助于`log.SetOutput()`：成功调用`log.SetOutput()`后，对`log.Print()`的每个函数调用都将使输出转到用作`log.SetOutput()`参数的日志文件。

`rotateLog.go`的第一部分如下：

```go
package main 

import ( 
   "fmt" 
   "log" 
   "os" 
   "strconv" 
   "time" 
) 

var TOTALWRITES int = 0 
var ENTRIESPERLOGFILE int = 100 
var WHENTOSTOP int = 230 
var openLogFile os.File 
```

使用硬编码变量定义程序何时停止被认为是一种良好的做法：这种情况的发生是因为您没有任何其他方法来告诉`rotateLog.go`停止。但是，如果您在已编译程序中使用`rotateLog.go`实用程序的功能，那么这些变量应该作为命令行参数提供，因为您不必为了改变程序的行为方式而重新编译程序！

`rotateLog.go`的第二部分如下：

```go
func rotateLogFile(filename string) error { 
   openLogFile.Close() 
   os.Rename(filename, filename+"."+strconv.Itoa(TOTALWRITES)) 
   err := setUpLogFile(filename) 
   return err 
} 

func setUpLogFile(filename string) error { 
   openLogFile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644) 
   if err != nil { 
         return err 
   } 
   log.SetOutput(openLogFile) 
   return nil 
} 
```

在这里，您定义了名为`rotateLogFile()`的 Go 函数，用于旋转所需的日志文件，这是程序最重要的部分。`setUpLogFile()`功能帮助您在旋转日志文件后重新启动日志文件。这里还说明了如何使用`log.SetOutput()`来告诉程序在何处写入日志条目。请注意，您应该使用`os.OpenFile()`打开日志文件，因为`os.Open()`不适用于`log.SetOutput()`，而`os.Open()`会打开文件进行写入！

最后一部分是以下内容：

```go
func main() { 
   numberOfLogEntries := 0 
   filename := "/tmp/myLog.log" 
   err := setUpLogFile(filename) 
   if err != nil { 
         fmt.Println(err) 
         os.Exit(-1) 
   } 

   for { 
         log.Println(numberOfLogEntries, "This is a test log entry") 
         numberOfLogEntries++ 
         TOTALWRITES++ 
         if numberOfLogEntries > ENTRIESPERLOGFILE { 
               rotateLogFile(filename)
               numberOfLogEntries = 0 
         } 
         if TOTALWRITES > WHENTOSTOP { 
               rotateLogFile(filename)
               break 
         } 
         time.Sleep(time.Second) 
   } 
   fmt.Println("Wrote", TOTALWRITES, "log entries!") 
} 
```

在这一部分中，`main()`函数在计算到目前为止已写入的条目数的同时，不断将数据写入日志文件。当达到定义的条目数（`ENTRIESPERLOGFILE`时，`main()`函数将调用`rotateLogFile()`函数，该函数将为我们完成脏工作。在实际程序中，您很可能不需要调用`time.Sleep()`来延迟程序的执行。对于这个特殊的程序，`time.Sleep()`将给您时间使用`tail -f`检查日志文件，如果您选择这样做的话。

运行`rotateLog.go`将在屏幕上和`/tmp`目录内生成以下输出：

```go
$ go run rotateLog.go
Wrote 231 log entries!
$ wc /tmp/myLog.log*
   0       0       0 /tmp/myLog.log
 101     909    4839 /tmp/myLog.log.101
 101     909    4839 /tmp/myLog.log.202
  29     261    1382 /tmp/myLog.log.231
 231    2079   11060 total
```

[第 8 章](08.html)*进程和信号*将介绍一种基于 Unix 信号的更好的日志旋转方法。

# 创建好的随机密码

本节将说明如何在 Go 中创建良好的随机密码，以保护 Unix 机器的安全。将其包含在此处而不是另一章的主要原因是，所介绍的 Go 程序将使用`/dev/random`设备（由 Unix 系统定义的文件）获取随机数生成器的种子。
Go 程序名称为`goodPass.go`，只需要一个可选参数，即生成密码的长度：生成密码的默认大小为 10 个字符。此外，程序将生成从`!`到`z`的 ASCII 字符。感叹号的 ASCII 码是 33，而小 z 的 ASCII 码是 122。

`goodPass.go`的第一部分是必要的序言：

```go
package main 

import ( 
   "encoding/binary" 
   "fmt" 
   "math/rand" 
   "os" 
   "path/filepath" 
   "strconv" 
) 
```

计划的第二部分如下：

```go
var MAX int = 90 
var MIN int = 0 
var seedSize int = 10 

func random(min, max int) int { 
   return rand.Intn(max-min) + min 
} 
```

您已经在[第二章](02.html)**编写 Go*中的程序中看到了`random()`函数，所以这里没有什么特别有趣的。*

 *`goodPass.go`的第三部分是`main()`功能开始执行的地方：

```go
func main() { 
   if len(os.Args) != 2 { 
         fmt.Printf("usage: %s length\n", filepath.Base(os.Args[0])) 
         os.Exit(1) 
   } 

   LENGTH, _ := strconv.ParseInt(os.Args[1], 10, 64) 
   f, _ := os.Open("/dev/random") 
   var seed int64 
   binary.Read(f, binary.LittleEndian, &seed) 
   rand.Seed(seed) 
   f.Close() 
   fmt.Println("Seed:", seed) 
```

在这里，除了读取命令行参数外，还可以打开`/dev/random`设备进行读取，这是通过调用`binary.Read()`函数并将读取的内容存储在`seed`变量中实现的。使用`binary.Read()`的原因是您需要指定使用的字节顺序（`binary.LittleEndian`），并且您需要构建一个 int64 而不是一系列字节。这是一个必须将二进制文件读入 Go 类型的示例。

程序的最后一部分包含以下 Go 代码：

```go
   startChar := "!" 
   var i int64 
   for i = 0; i < LENGTH; i++ { 
         anInt := int(random(MIN, MAX)) 
         newChar := string(startChar[0] + byte(anInt)) 
         if newChar == " " { 
               i = i - i 
               continue 
         } 
         fmt.Print(newChar) 
   } 
   fmt.Println() 
} 
```

如您所见，Go 处理 ASCII 字符的方式很奇怪，因为默认情况下 Go 支持 Unicode 字符。但是，您仍然可以将整数转换为 ASCII 字符，这可以从定义`newChar`变量的方式中看出。

执行`goodPass.go`将生成以下输出：

```go
$ go run goodPass.go 1
Seed: -5195038511418503382
b
$ go run goodPass.go 10
Seed: 8492864627151568776
k43Ve`+YD)
$ go run goodPass.go 50
Seed: -4276736612056007162
!=Gy+;XV>6eviuR=ST\u:Mk4Q875Y4YZiZhq&q_4Ih/]''`2:x
```

# 另一个围棋更新

在我写这一章的时候，Go 得到了更新。以下输出显示了相关信息：

```go
$ date
Wed May 24 13:35:36 EEST 2017
$ go version
go version go1.8.2 darwin/amd64 
```

# 练习

1.  查找并阅读`time`包的文档。
2.  尝试更改`userFiles.go`的 Go 代码，以支持多用户。
3.  更改`insertLineNumber.go`的 Go 代码，以便逐行读取输入文件，将每行写入一个临时文件，然后用临时文件替换原始文件。如果您不知道如何创建临时文件以及在何处创建临时文件，可以使用随机数生成器获取临时文件名，并使用`/tmp`目录临时保存。
4.  对`multipleMV.go`进行必要的更改，以便打印与给定正则表达式匹配的文件，而不实际重命名它们。
5.  尝试创建一个与`PNG`文件匹配的正则表达式，并使用它处理日志文件的内容。
6.  创建一个捕获日期和时间字符串的正则表达式，以便只打印日期部分并删除时间部分。

# 总结

在本章中，我们讨论了许多事情，包括使用日志文件、处理 Unix 文件权限、用户和组、创建正则表达式以及处理文本文件。

在下一章中，我们将讨论 Unix 信号，它允许您以异步方式与外部运行的程序通信。此外，我们将告诉您如何在 Go 中绘图。

F*