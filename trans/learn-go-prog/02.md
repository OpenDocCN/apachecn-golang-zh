# 二、Go 语言要领

在前一章中，我们建立了使 Go 成为创建现代系统程序的优秀语言的基本特征。在本章中，我们将深入研究该语言的语法，以探索其组成部分和功能。

我们将讨论以下主题：

*   Go 源文件
*   标识符
*   变量
*   常数
*   操作员

# Go 源文件

我们已经在[第 1 章](01.html "Chapter 1. A First Step in Go")中看到了*Go*的第一步，一些 Go 程序的示例。在本节中，我们将检查 Go 源文件。让我们考虑下面的源代码文件（打印不同语言的问候语）：

![The Go source file](img/B03676_02_Helloworld2-source.jpg)

golang.fyi/ch02/helloworld2.go

典型的 Go 源文件（如前面列出的文件）可分为三个主要部分，如下所示：

*   **包装条款**：

    ```go
          //1 Package Clause 
          package main 

    ```

*   **进口报关单**：

    ```go
          //2 Import Declaration 
          import "fmt" 
          import "math/rand" 
          import "time" 

    ```

*   **源体**：

    ```go
          //3 Source Body 
          var greetings = [][]string{ 
            {"Hello, World!","English"}, 
            ... 
          } 

          func greeting() [] string { 
            ... 
          } 

          func main() { 
            ... 
          } 

    ```

**package**子句表示该源文件所属的包的名称（包组织的详细讨论请参见[第 6 章](06.html "Chapter 6. Go Packages and Programs")，Go*Packages and Programs*。**导入**声明列出了源代码希望使用的任何外部包。Go 编译器严格执行包声明用法。在源文件中包含未使用的包被视为错误（编译）。源文件的最后一部分被视为源文件的主体。它是您声明变量、常量、类型和函数的地方。

所有 Go 源文件必须以[T0]后缀结尾。通常，您可以根据需要命名 Go 源文件。例如，与 Java 不同，Go 文件名与其内容中声明的类型之间没有直接关联。然而，将文件命名为表示其内容的名称被认为是良好的做法。

在我们更详细地研究 Go 的语法之前，了解该语言的一些基本结构元素是很重要的。虽然其中一些元素在语法上被固定在语言中，但其他一些元素是简单的习语和惯例，您应该注意这些习语和惯例，以使您的介绍变得简单而有趣。

## 可选分号

您可能已经注意到 Go 不需要分号作为语句分隔符。这是从其他较轻的语言和解释性语言中借用的一种特征。以下两个程序在功能上是等效的。第一个程序使用惯用的 Go 并省略分号：

![Optional semicolon](img/B03736_02_Helloworld-snippet1.jpg)

程序的第二个版本（如下所示）使用多余的分号显式终止其语句。虽然编译器可能会感谢您的帮助，但这在 Go 中并不惯用：

![Optional semicolon](img/B03676_02_Helloworld-snippet2-1.jpg)

尽管 Go 中的分号是可选的，但 Go 的形式语法仍然要求它们作为语句终止符。因此，Go 编译器将在源代码行末尾插入分号，这些代码行以以下内容结尾：

*   标识符
*   字符串、布尔值、数值或复数的文字值
*   控制流指令，如 break、continue 或 return
*   结束括号或括号，如`)`、`}`或`]`
*   递增`++`或递减`--`运算符

由于这些规则，编译器强制执行严格的语法形式，这些语法形式严重影响 Go 中的源代码样式。例如，所有代码块必须以一个开放的卷曲大括号开始，该括号与前面的语句位于同一行。否则，编译器可能会在中断代码的位置插入分号，如以下`if`语句所示：

```go
func main() { 
    if "a" == "a" 
    { 
      fmt.Println("Hello, World!") 
    } 
} 

```

将大括号移动到下一行会导致编译器过早插入分号，这将导致以下语法错误：

```go
$> ... missing condition in if statement ... 

```

这是因为编译器使用本节讨论的分号插入规则在[T0]语句（[T1]）后面插入了分号。您可以通过在`if`条件语句后手动插入分号来验证这一点；您将得到相同的错误。这是过渡到下一节讨论代码块中尾随逗号的好地方。

## 多条线路

将表达式拆分为多行必须遵循上一节讨论的分号规则。主要是，在多行表达式中，每行必须以一个标记结尾，以防止分号过早插入，如下表所示。应注意，表中具有无效表达式的行将不会编译：

<colgroup><col> <col></colgroup> 
| **表达式** | **有效** |
| 

```go
lonStr := "Hello World! " +
"How are you?"

```

 | 是的，`+`操作员可防止过早插入分号。 |
| 

```go
lonStr := "Hello World! "
+ "How are you?"

```

 | 不，分号将插入第一行之后，语义上会打断该行。 |
| 

```go
fmt.Printf("[%s] %d %d %v",
str,
num1,
num2,
nameMap)

```

 | 是的，逗号正确地打断了表达式。 |
| 

```go
fmt.Printf("[%s] %d %d %v",
str,
num1,
num2,
nameMap)

```

 | 是的，编译器仅在最后一行之后插入分号。 |
| 

```go
weekDays := []string{
"Mon", "Tue",
"Wed", "Thr",
"Fri"
}

```

 | 否，`Fri`行导致分号过早插入。 |
| 

```go
weekDays2 := []string{
"Mon", "Tue",
"Wed", "Thr",
"Fri",
}

```

 | 是的，`Fri`行包含一个尾随逗号，这会导致编译器在下一行插入分号。 |
| `weekDays1 := []string{``"Mon", "Tue",``"Wed", "Thr",``"Fri"}` | 是的，分号插入到带右括号的行之后。 |

您可能想知道为什么 Go 编译器让开发人员承担提供换行提示以指示语句结束的责任。当然，Go设计师可以设计出一个复杂的算法来自动解决这个问题。是的，他们可能有。但是，通过保持语法的简单性和可预测性，编译器能够快速解析和编译 Go 源代码。

### 注

Go 工具链包括 gofmt 工具，可用于一致地将正确的格式规则应用于源代码。还有一个`govet`工具，它通过分析代码中的代码元素的结构问题，更进一步。

# 去吧

Go 标识符用于命名程序元素，包括包、变量、函数和类型。以下总结了 Go 中标识符的一些属性：

*   标识符支持 Unicode 字符集
*   标识符的第一个位置必须是字母或下划线
*   惯用的 Go 支持混合大写（驼峰大小写）命名
*   包级别标识符在给定包中必须是唯一的
*   标识符在代码块中必须是唯一的（函数、控制语句）

## 空白标识符

Go 编译器对变量或包的声明标识符的使用特别严格。基本规则是：*您声明它，您必须使用它*。如果您试图用未使用的标识符（如变量或命名包）编译代码，编译器将不会满意，编译将失败。

GO 允许您使用空白标识符关闭该行为，该标记由 PosiT0}（下划线）字符表示。使用空白标识符的任何声明或赋值都不绑定到任何值，并且在编译时被忽略。空白标识符通常在两个上下文中使用，如下面的小节中所列出的。

## 静音包装进口

当包声明前面带有下划线时，编译器允许声明包而无需进一步引用：

```go
import "fmt" 
import "path/filepath" 
import _ "log" 

```

在前面的代码片段中，包`log`将被静音，而无需在代码中进一步引用。在积极开发新代码的过程中，这是一个方便的特性，开发人员可能希望尝试新的想法，而不必不断地注释或删除声明。尽管带有空标识符的包未绑定到任何引用，但 Go 运行时仍将对其进行初始化。[第 6 章](06.html "Chapter 6. Go Packages and Programs")*Go 包和程序*讨论了包的初始化生命周期。

## 静音不需要的功能结果

当 Go 函数调用返回多个值时，必须将返回列表中的每个值分配给变量标识符。但是，在某些情况下，可能需要将返回列表中不需要的结果静音，同时保留其他结果，如以下调用所示：

```go
_, execFile := filepath.Split("/opt/data/bigdata.txt")
```

前面对函数`filepath.Split("/opt/data/bigdata.txt")`的调用采用一个路径并返回两个值：第一个是父路径（`/opt/data`），第二个是文件名（`bigdata.txt`）。第一个值被分配给空白标识符，因此，它与命名标识符是无界的，这会导致编译器忽略它。在以后的讨论中，我们将探讨这个习语的其他上下文的其他用法，例如错误处理和`for`循环。

## 内置标识符

Go 带有许多内置标识符。它们分为不同的类别，包括类型、值和内置函数。

### 类型

以下标识符用于 Go 的内置类型：

<colgroup><col> <col></colgroup> 
| **类别** | **标识符** |
| 数字的 | 这和这个一样，但这和 7 一样，和 11 一样，和 13 一样，和 14 一样，和 15 一样，和 16 一样。 |
| 一串 | `string` |
| 布尔值 | `bool` |
| 错误 | `error` |

### 数值

这些标识符具有预先指定的值：

<colgroup><col> <col></colgroup> 
| **类别** | **标识符** |
| 布尔常数 | `true`、`false` |
| 常数计数器 | `iota` |
| 未初始化值 | `nil` |

### 功能

以下功能作为 Go 内置的预声明标识符的一部分提供：

<colgroup><col> <col></colgroup> 
| **类别** | **标识符** |
| 初始化 | `make()`、`new()` |
| 收藏 | `append()`、`cap()`、`copy()`、`delete()` |
| 复数 | `complex()`、`imag()`、`real()` |
| 错误处理 | `panic()`、`recover()` |

# Go 变量

Go 是一种严格类型化的语言，这意味着所有变量都是绑定到值和类型的命名元素。正如您将看到的，其语法的简单性和灵活性使得在 Go 中声明和初始化变量更像是一种动态类型语言。

## 变量声明

在 Go 中使用变量之前，必须使用命名标识符声明该变量，以便将来在代码中引用。Go 中变量声明的长格式如下所示：

```go
*var <identifier list> <type>*

```

`var`关键字用于声明一个或多个变量标识符，后跟变量类型。以下源代码片段显示了一个缩写程序，其中在函数`main()`之外声明了多个变量：

```go
package main 

import "fmt" 

var name, desc string 
var radius int32 
var mass float64 
var active bool 
var satellites []string 

func main() { 
  name = "Sun" 
  desc = "Star" 
  radius = 685800 
  mass = 1.989E+30 
  active = true 
  satellites = []string{ 
    "Mercury", 
    "Venus", 
    "Earth", 
    "Mars", 
    "Jupiter", 
    "Saturn", 
    "Uranus", 
    "Neptune", 
  } 
  fmt.Println(name) 
  fmt.Println(desc) 
  fmt.Println("Radius (km)", radius) 
  fmt.Println("Mass (kg)", mass) 
  fmt.Println("Satellites", satellites) 
} 

```

golang.fyi/ch02/vardec1。

## 零值

前面的源代码显示了几个使用各种类型声明变量的示例。然后在函数`main()`中为变量分配一个值。乍一看，这些声明的变量在声明时似乎没有赋值。这与我们之前的断言相矛盾，即所有 Go 变量都绑定到一个类型和一个值。

我们如何声明一个变量而不将值绑定到它？在声明变量期间，如果未提供值，Go 将自动将默认值（或零值）绑定到变量，以进行适当的内存初始化（稍后我们将在一个表达式中看到如何进行声明和初始化）。

下表显示了 Go 类型及其默认零值：

<colgroup><col> <col></colgroup> 
| **型** | **零值** |
| `string` | `""`（空字符串） |
| 数字-整数：`byte`、`int`、`int8`、`int16`、`int32`、`int64`、`rune`、`uint`、`uint8`、`uint16`、`uint32`、`uint64`、`uintptr` | 0 |
| 数字-浮点：`float32`、`float64` | 0.0 |
| `bool` | 错误的 |
| `Array` | 每个索引位置都有一个对应于数组元素类型的零值。 |
| `Struct` | 空的[T0]，每个成员都有各自的零值。 |
| 其他类型：接口、函数、通道、切片、映射和指针 | 无 |

## 初始化声明

如前所述，Go 还支持使用以下格式将变量声明和初始化组合为一个表达式：

*变量<标识符列表><类型>=<值列表或初始值设定项表达式>*

此声明格式具有以下属性：

*   等号左侧提供的标识符列表（后跟类型）
*   右侧的匹配逗号分隔值列表
*   赋值按标识符和值的各自顺序进行
*   初始值设定项表达式必须生成匹配的值列表

以下缩略示例显示了工作中的声明和初始化组合：

```go
var name, desc string = "Earth", "Planet" 
var radius int32 = 6378 
var mass float64 = 5.972E+24 
var active bool = true 
var satellites = []string{ 
  "Moon", 
} 

```

golang.fyi/ch02/vardec2

## 省略变量类型

到目前为止，我们已经讨论了所谓的 Go 变量声明和初始化的长形式。为了使语言更接近其动态类型化的同类，可以省略类型规范，如以下声明格式所示：

*var<标识符列表>=<值列表或初始值设定项表达式>*

在编译过程中，编译器根据赋值或等号右侧的初始值设定项表达式推断变量的类型，如以下示例所示。

```go
var name, desc = "Mars", "Planet" 
var radius = 6755 
var mass = 641693000000000.0 
var active = true 
var satellites = []string{ 
  "Phobos", 
  "Deimos", 
} 

```

golang.fyi/ch02/vardec3。

如前所述，当为变量赋值时，它必须随该值一起接收类型。当省略变量的类型时，类型信息将从表达式的赋值或返回值中推导出来。下表显示了给定文字值推断的类型：

<colgroup><col> <col></colgroup> 
| **文字值** | **推断类型** |
| 双引号或单引号（原始）文本：`"Planet Mars"``"All planets revolve around the Sun."` | `string` |
| 整数：`-76`0`1244``1840` | `int` |
| 小数：`-0.25``4.0``3.1e4``7e-12` | `float64` |
| 复数：`-5.0i``3i``(0+4i)` | `complex128` |
| 布尔人：`true``false` | `bool` |
| 数组值：`[2]int{-76, 8080}` | 在文本值中定义的[T0]类型。本例中为：`[2]int` |
| 映射值：`map[string]int{``  "Sun": 685800,``  "Earth": 6378,``  "Mars": 3396,``}` | 在文本值中定义的映射类型。在这种情况下，它是：`map[string]int` |
| 切片值：`[]int{-76, 0, 1244, 1840}` | 文本值中定义的`slice`类型：`[]int` |
| 结构值：`struct{``  name string``  diameter int}``{``  "Mars", 3396,``}` | 文本值中定义的`struct`类型。在这种情况下，类型为：`struct{name string; diameter int}` |
| 函数值：`var sqr = func (v int)   int {``  return v * v``}` | 在函数定义文本中定义的函数类型。在此`case`中，`variable``sqr`将具有以下类型：`func (v int) int` |

## 短变量声明

Go 可以使用*短变量声明*格式进一步减少变量声明语法。在此格式中，声明将丢失 var 关键字和类型规范，并使用赋值运算符`:=`（冒号相等），如图所示：

*<标识符列表>：=<值列表或初始值设定项表达式>*

这是一个简单而整洁的习惯用法，通常在 Go 中声明变量时使用。以下代码示例显示了短变量声明的用法：

```go
func main() { 
    name := "Neptune" 
    desc := "Planet" 
    radius := 24764 
    mass := 1.024e26 
    active := true 
    satellites := []string{ 
         "Naiad", "Thalassa", "Despina", "Galatea", "Larissa", 
     "S/2004 N 1", "Proteus", "Triton", "Nereid", "Halimede", 
         "Sao", "Laomedeia", "Neso", "Psamathe", 
    } 
... 
} 

```

golang.fyi/ch02/vardec4

注意，在声明中省略了关键字`var`和变量类型。短变量声明使用相同的机制来推断前面讨论的变量类型。

## 短变量声明的限制

为方便起见，变量声明的简短形式确实有几个限制，您应该注意这些限制，以避免混淆：

*   首先，它只能在功能块内使用
*   赋值运算符`:=`声明变量并赋值
*   `:=`不能用于更新先前声明的变量
*   必须使用等号更新变量

虽然这些限制可能源于 Go 语法的简单性，但它们通常被视为该语言新手的困惑源。例如，冒号相等运算符不能与包级别变量分配一起使用。学习 Go 的开发人员可能会发现使用赋值运算符作为更新变量的一种方式很有吸引力，但这会导致编译错误。

## 可变范围和可见性

Go 使用基于代码块的词法作用域来确定包中变量的可见性。根据在源文本中声明变量的位置，将确定其范围。作为一般规则，变量只能从块中声明并对所有嵌套子块可见的块中访问。

下面的屏幕截图说明了在源文本中声明的几个变量的范围。每个变量声明都标有其范围（`package`、`function`、`for`循环和`if...else`块）：

![Variable scope and visibility](img/B036376_02_01.jpg)

golang.fyi/ch02/makenums go。

如前所述，可变可见性自上而下工作。具有包范围的变量，例如`mapFile`和`numbersFile`，对包中的所有其他元素都是全局可见的。向下移动范围阶梯，函数中的所有元素（包括子块）都可以看到功能块变量，如`data`和`err`。内部`for`循环块中的变量`i`和`b`仅在该块中可见。循环完成后，`i`和`b`将超出范围。

### 注

对于新手来说，混淆的一个来源是包范围变量的可见性。当在包级别（函数或方法块外部）声明变量时，它对整个包全局可见，而不仅仅是对声明变量的源文件可见。这意味着在组成包的一组文件中，包作用域变量标识符只能声明一次，这对于刚开始使用 Go 的开发人员来说可能并不明显。包组织详见[第 6 章](06.html "Chapter 6. Go Packages and Programs")、*Go包及程序结构*。

## 变量声明块

Go 的语法允许将顶级变量的声明分组到块中，以提高可读性和代码组织。以下示例显示了使用变量声明块重写前面的一个示例：

```go
var ( 
  name string = "Earth" 
  desc string = "Planet" 
  radius int32 = 6378 
  mass float64 = 5.972E+24 
  active bool = true 
  satellites []string   
) 

```

golang.fyi/ch02/vardec5。

# Go 常数

在 Go 中，常量是具有文字表示形式的值，如文本字符串、布尔值或数字。常量的值是静态的，在初始赋值后不能更改。虽然它们所代表的概念很简单，但常数有一些有趣的特性，使它们非常有用，特别是在处理数值时。

## 常量字面值

常量是可以用语言中的文本文字表示的值。常量最有趣的属性之一是，它们的文字表示可以被视为类型化值或非类型化值。与本质上绑定到类型的变量不同，常量可以作为非类型值存储在内存空间中。例如，如果没有该类型约束，可以非常精确地存储数值常量值。

以下是可用 Go 表示的有效常量文字值示例：

```go
"Mastering Go" 
'G' 
false 
111009 
2.71828 
94314483457513374347558557572455574926671352 1e+500 
5.0i 

```

## 类型化常数

Go 常量值可以使用常量声明绑定到命名标识符。与变量声明类似，Go 使用`const`关键字表示常量的声明。但是，与变量不同，声明必须包含要绑定到标识符的文本值，如以下格式所示：

*常量<标识符列表>类型=<值列表或初始值设定项表达式>*

常量不能具有任何需要运行时解析的依赖项。编译器必须能够在编译时解析常量的值。这意味着所有常量都必须用值文字（或生成常量值的表达式）声明和初始化。

以下代码段显示了正在声明的某些类型化常量：

```go
const a1, a2 string = "Mastering", "Go" 
const b rune = 'G' 
const c bool = false 
const d int32 = 111009 
const e float32 = 2.71828 
const f float64 = math.Pi * 2.0e+3 
const g complex64 = 5.0i 
const h time.Duration = 4 * time.Second 

```

golang.fyi/ch02/const。

请注意，在前面的源代码片段中，每个声明的常量标识符都显式地给定了一个类型。正如您所期望的，这意味着常量标识符只能在与其类型兼容的上下文中使用。但是，下一节将解释在常量声明中省略该类型时，这是如何不同地工作的。

## 非类型化常数

常量在非类型化时更有趣。非类型化常量声明如下：

*常量<标识符列表>=<值列表或初始值设定项表达式>*

如前所述，关键字`const`用于将标识符列表及其各自的有界值声明为常量。但是，在这种格式中，声明中省略了类型规范。作为一个非类型化实体，常量只是内存中的一个字节块，没有任何类型精度限制。下面显示了一些非类型化常量的示例声明：

```go
const i = "G is" + " for Go " 
const j = 'V' 
const k1, k2 = true, !k1 
const l = 111*100000 + 9 
const m1 = math.Pi / 3.141592 
const m2 = 1.414213562373095048801688724209698078569671875376... 
const m3 = m2 * m2 
const m4 = m3 * 1.0e+400 
const n = -5.0i * 3 
const o = time.Millisecond * 5 

```

golang.fyi/ch02/const。

从前面的代码片段中，未类型化的常量`m2`被分配了一个长的十进制值（当它再经过 17 位时被截断以适合打印页面）。常数`m4`被分配了一个更大的`m3 x 1.0e+400`数。结果常量的整个值都存储在内存中，精度没有任何损失。对于对高精度计算感兴趣的开发人员来说，这是一个非常有用的工具。

## 分配非类型化常数

非类型化常量值在分配给变量、用作函数参数或作为分配给变量的表达式的一部分之前，用途有限。在像 Go 这样的强类型语言中，这意味着可能需要进行某种类型调整，以确保存储在常量中的值可以正确地分配给目标变量。使用非类型化常量的一个优点是类型系统放松了严格的类型检查应用。可以将非类型化常量指定给不同精度的不同类型（尽管兼容），而无需编译器提出任何投诉，如下例所示：

```go
const m2 = 1.414213562373095048801688724209698078569671875376... 
var u1 float32 = m2 
var u2 float64 = m2 
u3 := m2 

```

前面的代码片段显示了非类型化常量`m2`被分配给两个浮点精度不同的变量`u1`和`u2`，以及一个非类型化变量`u3`。这是可能的，因为常量`m2`存储为原始非类型化值，因此可以分配给与其表示形式（浮点）兼容的任何变量。

虽然类型系统将适应`m2`对不同精度变量的赋值，但结果赋值将进行调整以适应变量类型，如下所述：

```go
u1 = 1.4142135      //float32 
u2 = 1.4142135623730951   //float64 

```

变量`u3`本身是一个非类型化变量，那么它呢？由于`u3`没有指定的类型，它将依赖于来自常量值的类型推断来接收类型分配。回想一下前面*节中省略变量类型*的讨论，常量文本根据其文本表示映射到基本 Go 类型。由于常量`m2`代表一个十进制值，编译器将推断其默认值为`float64`，该值将自动分配给变量`u3`，如图所示：

```go
U3 = 1.4142135623730951  //float64 

```

如您所见，Go 对非类型化原始常量文本的处理通过自动应用一些简单但有效的类型推断规则而提高了语言的可用性，同时又不牺牲类型安全性。与其他语言不同，开发人员不必显式地在值文本中指定类型，也不必执行某种类型的类型转换来实现这一点。

## 常数声明块

正如您可能猜到的，常量声明可以组织为代码块以提高可读性。前面的示例可以重写如下：

```go
const ( 
  a1, a2 string        = "Mastering", "Go" 
  b      rune          = 'G' 
  c      bool          = false 
  d      int32         = 111009 
  e      float32       = 2.71828 
  f      float64       = math.Pi * 2.0e+3 
  g      complex64     = 5.0i 
  h      time.Duration = 4 * time.Second 
... 
) 

```

golang.fyi/ch02/constgo。

## 常数枚举

常数的一个有趣用法是创建枚举值。使用声明块格式（如前一节所示），可以轻松创建以数字递增的枚举整数值。只需将预先声明的常量值`iota`分配给声明块中的常量标识符，如下代码示例所示：

```go
const ( 
  StarHyperGiant = iota 
  StarSuperGiant 
  StarBrightGiant 
  StarGiant 
  StarSubGiant 
  StarDwarf 
  StarSubDwarf 
  StarWhiteDwarf 
  StarRedDwarf 
  StarBrownDwarf 
) 

```

golang.fyi/ch02/enum0。

然后，编译器将自动执行以下操作：

*   将块中的每个成员声明为非类型化整型常量值
*   用零值初始化`iota`
*   将[T0]或零赋值给第一个常量成员（[T1]）
*   每个后续常数都分配了一个增加 1 的`int`值

因此，前面的常量列表将分配一系列从零到九的值。无论何时`const`显示为声明块，它都会将计数器重置为零。在以下代码段中，每组常量分别从 0 到 4 枚举：

```go
const ( 
  StarHyperGiant = iota 
  StarSuperGiant 
  StarBrightGiant 
  StarGiant 
  StarSubGiant 
) 
const ( 
  StarDwarf = iota 
  StarSubDwarf 
  StarWhiteDwarf 
  StarRedDwarf 
  StarBrownDwarf 
) 

```

golang.fyi/ch02/enum1。

## 覆盖默认枚举类型

默认情况下，枚举常量声明为非类型化整数值。但是，您可以通过为枚举常量提供显式数字类型来覆盖枚举值的默认类型，如以下代码示例所示：

```go
const ( 
  StarDwarf byte = iota 
  StarSubDwarf 
  StarWhiteDwarf 
  StarRedDwarf 
  StarBrownDwarf 
) 

```

您可以指定任何可以表示整数或浮点值的数字类型。例如，在前面的代码示例中，每个常量都将声明为类型`byte`。

## 在表达式中使用 iota

当`iota`出现在表达式中时，相同的机制会按预期工作。编译器将为`iota`的每个连续递增值应用表达式。以下示例将偶数分配给常量声明块的枚举成员：

```go
const ( 
  StarHyperGiant = 2.0*iota 
  StarSuperGiant 
  StarBrightGiant 
  StarGiant 
  StarSubGiant 
) 

```

golang.fyi/ch02/enum2。

如您所料，前面的示例为每个枚举常量指定一个偶数值，从 0 开始，如以下输出所示：

```go
 StarHyperGiant = 0    [float64]
    StarSuperGiant = 2    [float64]
    StarBrightGiant = 4   [float64]
    StarGiant = 6         [float64]
    StarSubGiant = 8      [float64] 

```

## 跳过枚举值

使用枚举常量时，您可能希望丢弃某些不应属于枚举的值。这可以通过将 IOTA 分配到枚举中所需位置的空白标识符来实现。例如，以下跳过值 0 和`64`：

```go
_              = iota    // value 0 
StarHyperGiant = 1 << iota 
StarSuperGiant 
StarBrightGiant 
StarGiant 
StarSubGiant 
_          // value 64 
StarDwarf 
StarSubDwarf 
StarWhiteDwarf 
StarRedDwarf 
StarBrownDwarf 

```

golang.fyi/ch02/enum3。

由于我们跳过了`iota`位置`0`，所以第一个指定的常量值位于`1`位置。这导致表达`1 << iota`解析为`1 << 1 = 2`。第六个位置也是如此，其中表达式`1 << iota`返回`64`。该值将被跳过，并且不会分配给任何常量，如以下输出所示：

```go
 StarHyperGiant = 2
    StarSuperGiant = 4
    StarBrightGiant = 8
    StarGiant = 16
    StarSubGiant = 32
    StarDwarf = 128
    StarSubDwarf = 256
    StarWhiteDwarf = 512
    StarRedDwarf = 1024
    StarBrownDwarf = 2048 

```

# Go操作员

Go 中的运算符保持其过于简单的性质，完全按照您的预期进行操作，主要是允许将操作数组合到表达式中。GO 运算符没有隐藏的意外行为，因为在 C++或斯卡拉中没有支持操作符重载。这是设计者有意做出的决定，以保持语言的语义简单且可预测。

本节探讨在开始使用 Go 时将遇到的最常见的运算符。本书的其他章节涵盖了其他运算符。

## 算术运算符

下表总结了 Go 中支持的算术运算符。

<colgroup><col> <col> <col></colgroup> 
| **操作员** | **操作** | **兼容类型** |
| `*`、`/`、`-` | 乘法、除法和减法 | 整数、浮点和复数 |
| `%` | 余数 | 整数 |
| `+` | 附加 | 整数、浮点、复数和字符串（串联） |

注意，加法运算符`+`可以应用于表达式`var i = "G is" + " for Go"`中的字符串。将两个字符串操作数串联起来，以创建一个分配给变量`i`的新字符串。

## 递增和递减运算符

与其他类似 C 的语言一样，Go 支持`++`（递增）和`--`（递减）运算符。应用时，这些运算符将操作数的值分别增加或减少 1。下面显示了一个函数，该函数使用减量运算符按相反顺序遍历字符串 s 中的字母：

```go
func reverse(s string) { 
  for i := len(s) - 1; i >= 0; { 
    fmt.Print(string(s[i])) 
    i-- 
  } 
} 

```

请务必注意，递增和递减运算符是语句，而不是表达式，如以下代码段所示：

```go
nextChar := i++       // syntax error 
fmt.Println("Current char", i--)   // syntax error 
nextChar++        // OK 

```

在前面的示例中，值得注意的是递增和递减语句只支持后缀符号。由于语句-`i`，无法编译以下代码段：

```go
for i := len(s) - 1; i >= 0; { 
  fmt.Print(string(s[i])) 
  --i   //syntax error 
} 

```

## Go 分配运算符

<colgroup><col> <col></colgroup> 
| **操作员** | **说明** |
| `=` | 这个简单的任务按预期工作。它用右操作数的值更新左操作数。 |
| `:=` | 冒号相等运算符声明一个新变量，即左侧运算符，并为其分配右侧操作数的值（和类型）。 |
| `+=`，[T0]，[T0]，[T0]，[T0] | 使用 left 和 right 运算符应用指示的操作，并将结果存储在 left 运算符中。例如，`a *= 8`表示`a = a * 8`。 |

## 位运算符

Go 完全支持以最基本的形式操纵值。以下总结了 Go 支持的位运算符：

<colgroup><col> <col></colgroup> 
| **操作员** | **说明** |
| `&` | 按位与 |
| `&#124;` | 按位或 |
| `a ^ b` | 按位异或 |
| `&^` | 按位而不是 |
| `^a` | 一元位补码 |
| `<<` | 左移 |
| `>>` | 右移 |

移位运算中的右操作数必须是无符号整数或能够转换为无符号值。当左操作数是非类型化常量值时，编译器必须能够从其值派生有符号整数类型，否则编译将失败。

Go 中的移位运算符还支持算术移位和逻辑移位。如果左操作数无符号，Go 将自动应用逻辑移位，而如果左操作数有符号，Go 将应用算术移位。

## 逻辑运算符

以下是布尔值的 Go 逻辑操作列表：

<colgroup><col> <col></colgroup> 
| **操作员** | **操作** |
| `&&` | 逻辑与 |
| `&#124;&#124;` | 逻辑或 |
| `!` | 不符合逻辑 |

## 比较运算符

可以测试所有 Go 类型是否相等，包括基本类型和复合类型。但是，使用排序运算符只能比较字符串、整数和浮点值，如下表所示：

<colgroup><col> <col> <col></colgroup> 
| **操作员** | **操作** | **支撑式** |
| `==` | 相同的 | 字符串、数字、布尔值、接口、指针和结构类型 |
| `!=` | 不相上下 | 字符串、数字、布尔值、接口、指针和结构类型 |
| `<`，[T0]，[T0]，[T0] | 排序运算符 | 字符串、整数和浮点 |

## 运算符优先级

由于 Go 的运算符比 C 或 Java 中的运算符少，因此其运算符优先级规则要简单得多。下表列出了 Go 的运算符优先级梯队，从最高优先级开始：

<colgroup><col> <col></colgroup> 
| **操作** | **优先级** |
| 乘法 | 橄榄和石榴 |
| 添加剂 | `+`、 `-`、 `&#124;`、 `^` |
| 比较的 | 还有橄榄树和棕榈树 |
| 逻辑与 | `&&` |
| 逻辑或 | `&#124;&#124;` |

# 总结

本章介绍了Go语言的基本结构。它从 Go 的源代码文本文件的结构开始，并逐渐涵盖变量标识符、声明和初始化。本章还广泛介绍了 Go 常量、常量声明和运算符。

在这一点上，您可能会感到有点不知所措，因为有太多关于该语言及其语法的琐碎信息。好消息是，您不必了解所有这些细节，就可以有效地使用该语言。在接下来的章节中，我们将继续探索一些关于 Go 的更有趣的内容，包括数据类型、函数和包。