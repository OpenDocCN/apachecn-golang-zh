SUMMARY

# 测试同构 Go Web 应用程序

在上一章中，随着可重用组件（COG）在整个网站上的散布，我们已经达到了一个项目里程碑——我们完成了在[第 2 章](02.html)、*同构 Go 工具链*中列出的 IGWEB 功能集。然而，我们还不能推出 IGWEB。在启动之前，我们必须通过验证同构 web 应用程序是否满足一定的功能需求基线集来确保其质量。要做到这一点，我们必须实现端到端测试，以跨环境（服务器端和客户端）执行同构 web 应用程序的功能。

在本章中，您将学习如何为 IGWEB 提供端到端测试覆盖率。我们将使用 Go 的内置测试框架来测试服务器端功能，并使用 CasperJS 来测试客户端功能。通过实现一套端到端测试，我们不仅可以实现自动化测试，而且在我们编写的每个测试中都有一个有价值的项目工件，因为每个测试都传达了在同构 web 应用程序中找到的预期功能的意图。在本章的末尾，我们将创建一个端到端的测试套件，它构成了一个坚实的测试策略的基础，读者可以在此基础上进一步研究。

在本章中，我们将介绍以下主题：

*   使用 Go 的测试框架测试服务器端功能
*   使用 CasperJS 测试客户端功能

# 测试服务器端功能

正如我们在[第 1 章](01.html)、*同构 Web 应用程序与 Go*中了解到的，同构 Web 应用程序架构采用了经典的 Web 应用程序架构，这意味着 Web 页面响应将在服务器端呈现。这意味着 web 客户端不需要启用 JavaScript 就可以使用从服务器响应接收的内容。这一事实对于机器用户尤其重要，比如搜索引擎机器人，他们需要爬过网站上的各种链接并为它们编制索引。通常情况下，搜索引擎爬行器不支持 JavaScript。这意味着我们必须确保服务器端路由正常运行，并且网页响应也能正确呈现。

除此之外，我们在[第 7 章](07.html)*同构 Web 表单*中做了大量的努力，以创建一个可访问的、同构的 Web 表单，供具有更高访问性需求的用户访问。我们需要确保联系人表单的验证功能正常工作，并且我们可以成功发送有效的联系人表单提交。

因此，在服务器端，我们将测试的基本功能集包括以下各项：

1.  验证服务器端路由和模板呈现
2.  验证联系人表单的验证功能
3.  验证成功的联系人表单提交

# Go 的测试框架

我们将使用 Go 的内置测试框架来编写一组测试，以实现 IGWEB 的服务器端功能。所有服务器端测试都存储在`tests`文件夹中。

如果您是通过`testing`包提供的 to Go 内置测试框架的新手，您可以通过以下链接了解更多信息：[https://golang.org/pkg/testing/](https://golang.org/pkg/testing/) 。

在运行`go test`命令执行所有测试之前，必须先启动 Redis server 实例和 IGWEB（最好在各自的专用终端窗口或选项卡中）。

您可以使用以下命令启动 Redis server 实例：

```go
$ redis-server
```

您可以在`$IGWEB_APP_ROOT`文件夹中使用以下命令启动 IGWEB 实例：

```go
$ go run igweb.go
```

要运行套件中的所有测试，只需在`tests`文件夹中运行`go test`命令：

```go
$ go test
```

# 验证服务器端路由和模板呈现

我们创建了一个测试来验证 IGWEB 应用程序的所有服务器端路由。我们测试的每个路由都将与一个预期的字符串标记相关联，该标记在页面响应中呈现，特别是在主内容`div`容器中。因此，我们不仅可以验证服务器端路由是否正常工作，还可以知道服务器端模板呈现是否正常工作。

以下是在`tests`文件夹中找到的`routes_test.go`源文件的内容：

```go
package tests

import (
  "io/ioutil"
  "net/http"
  "strings"
  "testing"
)

func checkRoute(t *testing.T, route string, expectedToken string) {

  testURL := testHost + route
  response, err := http.Get(testURL)
  if err != nil {
    t.Errorf("Could not connect to URL: %s. Failed with error: %s",     
    testURL, err)
  } else {
    defer response.Body.Close()
    contents, err := ioutil.ReadAll(response.Body)
    if err != nil {
      t.Errorf("Could not read response body. Failed with error: %s",   
      err)
    }
    if strings.Contains(string(contents), expectedToken) == false {
      t.Errorf("Could not find expected string token: \"%s\", in 
      response body for URL: %s", expectedToken, testURL)
    }
  }
}

func TestServerSideRoutes(t *testing.T) {

  routesTokenMap := map[string]string{"": "IGWEB", "/": "IGWEB",   
  "/index": "IGWEB", "/products": "Add To Cart", "/product-  
  detail/swiss-army-knife": "Swiss Army Knife", "/about": "Molly",   
  "/contact": "Enter your message for us here"}

  for route, expectedString := range routesTokenMap {
    checkRoute(t, route, expectedString)
  }
}
```

我们定义的`testHost`变量用于指定 IGWEB 实例运行的主机名和端口。

`TestServerSideRoutes`函数负责测试服务器端路由，并验证响应体中是否存在预期的令牌字符串。在函数内部，我们声明并初始化类型为`map[string]string`的`routesTokenMap`变量。此`map`中的密钥表示我们正在测试的服务器端路由，给定密钥的值表示从服务器返回的网页响应中应该存在的预期`string`令牌。因此，这个测试不仅会告诉我们服务器端路由是否正常工作，而且还会让我们了解模板呈现的健康状况，因为我们提供的预期`string`标记都是应该在网页主体中找到的字符串。然后我们通过`routesTokenMap`进行`range`，对于每个迭代，我们将`route`和`expectedString`传递给`checkRoute`函数。

`checkRoute`功能负责访问给定的路由，读取其响应体，并验证`expectedString`是否存在于响应体中。有三种情况会导致测试失败：

1.  无法建立到路由 URL 的连接时
2.  如果无法读取从服务器检索的响应正文
3.  如果从服务器返回的网页响应中不存在所需的字符串标记

如果出现这三个错误中的任何一个，测试将失败。否则，该函数将正常返回。

我们可以通过发出以下`go test`命令来运行此测试：

```go
$ go test -run TestServerSideRoutes
```

检查运行测试的输出表明测试已通过：

```go
$ go test -run TestServerSideRoutes
PASS
ok github.com/EngineerKamesh/igb/igweb/tests 0.014s
```

我们现在已经成功地验证了访问服务器端路由，并确保每个路由中的预期字符串在 web 页面响应中正确呈现。现在，让我们开始验证联系人表单功能，从表单验证功能开始。

# 验证联系人表单的验证功能

我们将要实现的下一个测试将测试联系人表单的服务器端表单验证功能。我们将测试两种类型的验证：

*   未填写所需表单字段时显示的错误消息
*   电子邮件字段中提供格式不正确的电子邮件地址值时显示的错误消息

以下是在`tests`文件夹中找到的`contactvalidation_test.go`源文件的内容：

```go
package tests

import (
  "io/ioutil"
  "net/http"
  "net/url"
  "strconv"
  "strings"
  "testing"
)

func TestContactFormValidation(t *testing.T) {

  testURL := testHost + "/contact"
  expectedTokenMap := map[string]string{"firstName": "The first name 
  field is required.", "/": "The last name field is required.",   
  "email": "The e-mail address entered has an improper syntax.",   
  "messageBody": "The message area must be filled."}

  form := url.Values{}
  form.Add("firstName", "")
  form.Add("lastName", "")
  form.Add("email", "devnull@g@o")
  form.Add("messageBody", "")

  req, err := http.NewRequest("POST", testURL,   
  strings.NewReader(form.Encode()))

  if err != nil {
    t.Errorf("Failed to create new POST request to URL: %s, with error:   
    %s", testURL, err)
  }

  req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
  req.Header.Add("Content-Length", strconv.Itoa(len(form.Encode())))

  hc := http.Client{}
  response, err := hc.Do(req)

  if err != nil {
    t.Errorf("Failed to make POST request to URL: %s, with error: %s", 
    testURL, err)
  }

  defer response.Body.Close()
  contents, err := ioutil.ReadAll(response.Body)

  if err != nil {
    t.Errorf("Failed to read response body contents with error: %s",         
    err)
  }

  for k, v := range expectedTokenMap {
    if strings.Contains(string(contents), v) == false {
      t.Errorf("Could not find expected string token: \"%s\" for field 
      \"%s\"", v, k)
    }
  }

}
```

`TestContactFormValidation`功能负责测试联系人表单的服务器端表单验证功能。我们声明并初始化`testURL`变量，它是 IGWEB 联系人部分的 URL。

我们声明并初始化`map[string]string`类型的`expectedTokenMap`变量，其中映射中的键是表单字段的名称，每个键的值表示提交表单时应返回的预期错误消息。

我们创建一个新表单，并使用表单对象的`Add`方法填充表单字段值。请注意，我们为[T2]、[T3]和[T4]字段提供了一个空的[T1]值。我们还为`email`字段提供了格式不正确的电子邮件地址。

我们使用`http`包中的`NewRequest`函数使用 HTTP POST 请求提交表单。

我们创建一个`http.Client`、`hc`，并通过调用其`Do`方法提交 POST 请求。我们使用`ioutil`包中的`ReadAll`函数获取响应体的内容。我们通过`expectedTokenMap`来`range`，并且在每次迭代中，我们检查是否在响应体中找到了预期的错误消息。

以下是可能导致该测试失败的四种情况：

*   如果无法创建 POST 请求
*   如果 POST 请求由于与 web 服务器的连接问题而失败
*   如果 web 客户端无法读取从 web 服务器返回的 web 页面响应的响应正文
*   如果在网页正文中找不到预期的错误消息

如果遇到这些错误中的任何一个，此测试将失败。

我们可以通过发出以下命令来运行此测试：

```go
$ go test -run TestContactFormValidation
```

检查运行测试的输出表明测试已通过：

```go
$ go test -run TestContactFormValidation
PASS
ok github.com/EngineerKamesh/igb/igweb/tests 0.009s
```

# 验证成功的联系人表单提交

我们将实施的下一个测试将测试成功的联系人表单提交。此测试与上次测试非常相似，只是我们将填写所有表单字段，并在`email`表单字段中提供格式正确的电子邮件地址。

以下是在`tests`文件夹中找到的`contact_test.go`源文件的内容：

```go
package tests

import (
  "io/ioutil"
  "net/http"
  "net/url"
  "strconv"
  "strings"
  "testing"
)

func TestContactForm(t *testing.T) {

  testURL := testHost + "/contact"
  expectedTokenString := "The contact form has been successfully   
  completed."

  form := url.Values{}
  form.Add("firstName", "Isomorphic")
  form.Add("lastName", "Gopher")
  form.Add("email", "devnull@test.com")
  form.Add("messageBody", "This is a message sent from the automated   
  contact form test.")

  req, err := http.NewRequest("POST", testURL,   
  strings.NewReader(form.Encode()))

  if err != nil {
    t.Errorf("Failed to create new POST request to URL: %s, with error: 
    %s", testURL, err)
  }

  req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
  req.Header.Add("Content-Length", strconv.Itoa(len(form.Encode())))

  hc := http.Client{}
  response, err := hc.Do(req)

  if err != nil {
    t.Errorf("Failed to make POST request to URL: %s, with error: %s", 
    testURL, err)
  }

  defer response.Body.Close()
  contents, err := ioutil.ReadAll(response.Body)

  if err != nil {
    t.Errorf("Failed to read response body contents with error: %s", 
    err)
  }

  if strings.Contains(string(contents), expectedTokenString) == false {
    t.Errorf("Could not find expected string token: \"%s\"", 
    expectedTokenString)
  }
}
```

同样，该测试与我们实现的上一个测试非常相似，只是我们填充了所有表单字段并提供了一个格式正确的电子邮件地址。我们声明`expectedTokenString`变量并将其初始化为确认字符串，我们希望在成功提交表单后在响应正文中打印出来。函数的最后一个`if`条件块检查响应体是否包含`expectedTokenString`。否则，测试将失败。

以下是可能导致该测试失败的四种情况：

*   如果无法创建 POST 请求
*   如果 POST 请求由于与 web 服务器的连接问题而失败
*   如果 web 客户端无法读取从 web 服务器返回的 web 页面响应的响应正文
*   如果在网页正文中找不到预期的确认消息

同样，如果遇到这些错误中的任何一个，此测试将失败。

我们可以通过发出以下命令来运行测试：

```go
$ go test - run TestContactForm
```

通过运行测试后检查输出，我们可以看到测试已通过：

```go
$ go test - run TestContactForm
PASS
ok github.com/EngineerKamesh/igb/igweb/tests 0.012s
```

只需在`tests`目录中发出`go test`命令，即可运行测试套件中的所有测试：

```go
$ go test
PASS
ok github.com/EngineerKamesh/igb/igweb/tests 0.011s
```

到目前为止，我们已经编写了测试来覆盖测试服务器端 web 应用程序的基本功能集。现在，是时候专注于测试客户端应用程序了。

# 测试客户端功能

如[第 1 章](https://cdp.packtpub.com/isomorphic_go/wp-admin/post.php?post=616&action=edit#post_26)所述，*与 Go*同构的 Web 应用程序，初始页面加载后，使用单页面应用程序架构提供后续网站导航服务。这意味着对 RESTAPI 端点启动 XHR 调用，该端点提供必要的数据来呈现将显示在 web 页面上的内容。例如，在客户端处理程序显示产品列表页面的情况下，使用 RESTAPI 端点获取要显示的产品列表。在某些情况下，甚至不需要 RESTAPI 端点，因为页面内容只需要呈现模板。这方面的一个例子是，用户通过单击导航栏中的联系人链接访问联系人表单。在这种情况下，我们只需呈现联系人表单模板并在主内容区域中显示内容。

让我们花一点时间考虑一下我们需要在客户端测试的所有基线功能。我们需要验证客户端路由是否正常工作，以及是否为每个路由呈现了正确的页面，类似于我们在上一节中验证服务器端路由的方式。除此之外，我们还需要确认客户端表单验证对联系人表单有效，并测试有效表单提交的场景。向购物车添加和从购物车中删除项目的功能目前仅在客户端实现。这意味着我们必须编写测试来验证此功能是否按预期工作。另一个目前仅在客户端可用的功能是实时聊天功能。我们必须验证用户是否可以与实时聊天机器人进行通信，机器人是否回复，以及在用户导航到网站的不同部分时是否保持对话。

最后，我们必须测试 COG 集合。我们必须确保 time ago cog 以人类可以理解的格式显示时间实例。我们必须验证实时时钟 cog 是否正常工作。我们必须验证在单击时间敏感日期字段时是否显示日期选择器 cog。我们必须验证转盘齿轮是否出现在主页上。最后，我们必须验证 notify cog 在向购物车添加和从购物车中删除项目时是否正确显示通知。

因此，在客户端，我们将测试的基本功能集包括以下各项：

1.  验证客户端路由和模板呈现
2.  核实联络表格
3.  验证购物车功能
4.  验证实时聊天功能
5.  验证时间间隔 cog
6.  验证实时时钟 cog
7.  验证日期选择器 cog
8.  验证转盘齿轮
9.  验证通知 cog

为了在客户端（包括用户交互）上执行自动化测试，我们需要一个内置 JavaScript 运行时的工具。因此，我们在测试客户端功能时不能使用`go test`。

我们将使用 CasperJS 在客户端执行自动化测试。

# 卡斯珀斯。

CasperJS 是一个自动化测试工具，它位于 PhantomJS 之上，PhantomJS 是一种无头 web 浏览器，用于自动化用户交互。CasperJS 允许我们使用断言编写测试，并组织测试，以便它们可以顺序地一起运行。测试运行后，我们可以收到通过的测试数量与失败的测试数量的摘要。除此之外，CasperJS 还可以利用 PhantomJS 中的功能，在进行测试时拍摄网页截图。这允许人工用户直观地评估测试运行。

为了安装 CasperJS，我们必须首先安装 NodeJS 和 PhantomJS。

您可以通过以下链接下载适用于您的操作系统的 NodeJS 安装程序来安装 NodeJS:[https://nodejs.org/en/download/](https://nodejs.org/en/download/) 。

安装 NodeJS 后，可以通过发出以下命令来安装 PhantomJS：

```go
$ npm install -g phantomjs
```

您可以通过发出以下命令查看系统上安装的 PhantomJS 的版本号来验证`phantomjs`是否已正确安装：

```go
$ phantomjs --version
2.1.1
```

验证系统上安装了 PhantomJS 后，可以发出以下命令来安装 CasperJS：

```go
$ npm install -g casperjs
```

要验证`casperjs`是否已正确安装，您可以发出以下命令查看系统上安装的 CasperJS 版本号：

```go
$ casperjs --version
1.1.4
```

我们的客户端 CasperJS 测试将放在`client/tests`目录中。注意`client/tests`文件夹中的子文件夹：

```go
 ⁃ tests
    ⁃ go
    ⁃ js
    ⁃ screenshots
```

我们将在 Go 中编写所有 CasperJS 测试，并将它们放在`go`文件夹中。我们将使用在`scripts`目录中找到的`build_casper_tests.sh`bash 脚本，将在 Go 中实现的 CasperJS 测试转换为其等效的 JavaScript 表示。生成的 JavaScript 源文件将放在`js`文件夹中。我们将创建的许多测试将生成正在进行的测试的屏幕截图，这些屏幕截图图像将存储在`screenshots`文件夹中。

您应该运行以下命令，使`build_casper_tests.sh`bash 脚本可执行：

```go
$ chmod +x $IGWEB_APP_ROOT/scripts/build_casper_tests.sh
```

无论何时我们在 Go 中编写 CasperJS 测试或对其进行更改，我们都必须执行[T0]bash 脚本：

```go
$ $IGWEB_APP_ROOT/scripts/build_casper_tests.sh 
```

在开始编写 CasPijs 测试之前，让我们先看一下在 OutT1 目录中找到的水果挞源文件：

```go
package caspertest

import "github.com/gopherjs/gopherjs/js"

type ViewportParams struct {
  *js.Object
  Width int `js:"width"`
  Height int `js:"height"`
}
```

[T0]结构将用于定义 web 浏览器的视口尺寸。我们将使用 1440×960 的维度来模拟所有客户端测试的桌面查看体验。在运行生成一个或多个屏幕截图的 CasperJS 测试后，通过查看生成的屏幕截图可以很容易地看到设置视口维度的后果。

现在，让我们开始使用 CasperJS 编写客户端测试。

# 验证客户端路由和模板呈现

我们在 Go 中实现的 CasperJS 测试，用于测试客户端路由，可以在`client/tests/go`目录下的`routes_test.go`源文件中找到。

在导入分组中，注意我们包括了`caspertestjs`包，其中我们定义了`ViewportParams``struct`，我们包括了`js`包：

```go
package main

import (
  "strings"

  "github.com/EngineerKamesh/igb/igweb/client/tests/go/caspertest"
 "github.com/gopherjs/gopherjs/js"
)
```

我们将广泛使用`js`包中的功能，以利用 CasperJS 功能，因为目前没有可用于 CasperJS 的 GopherJS 绑定。

我们将定义一个名为`wait`的 JavaScript 函数，该函数负责等待主内容`div`容器加载到远程 DOM 中：

```go
var wait = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  this.Call("waitForSelector", "#primaryContent")
  return nil
})
```

在执行 CasperJS 时，我们声明并初始化`casper`变量为`casper`实例，这是一个 JavaScript 对象，已在远程 DOM 中填充：

```go
var casper = js.Global.Get("casper")
```

我们在`main`功能中实现了客户端路由测试。我们首先声明一个`routesTokenMap`（类似于我们在服务器端路由测试中所做的），其类型为`map[string]string`：

```go
func main() {

  routesTokenMap := map[string]string{"/": "IGWEB", "/index": "IGWEB",   
  "/products": "Add To Cart", "/product-detail/swiss-army-knife":   
  "Swiss Army Knife", "/about": "Molly", "/contact": "Contact",  
  "/shopping-cart": "Shopping Cart"}
```

键表示客户端路由，给定键的值表示访问给定客户端路由时应在网页上呈现的预期字符串标记。

我们使用以下代码设置 web 浏览器的视口大小：

```go
viewportParams := &caspertest.ViewportParams{Object: js.Global.Get("Object").New()}
  viewportParams.Width = 1440
  viewportParams.Height = 960
  casper.Get("options").Set("viewportSize", viewportParams)
```

请注意，PhantomJS 使用 400×300 的默认视口。我们必须覆盖此值，因为我们将模拟桌面查看体验。

在编写测试时，我们将使用 CasperJS 的`tester`模块。`Tester`类提供用于单元和功能测试的 API，可通过`casper`实例的`test`属性访问。`tester`模块的完整文档可通过以下链接获得：[http://docs.casperjs.org/en/latest/modules/tester.html](http://docs.casperjs.org/en/latest/modules/tester.html) 。

我们调用`test`对象的`begin`方法来启动一套计划测试：

```go
  casper.Get("test").Call("begin", "Client-Side Routes Test Suite", 7, func(test *js.Object) {
    casper.Call("start", "http://localhost:8080", wait)
  })
```

提供给`begin`方法的第一个参数是测试套件的描述。我们已经提供了`"Client-Side Routes Test Suite"`的说明。

第二个参数表示计划的测试数量。这里我们已经指定总共有七个测试，因为这是我们要测试的客户端路由的数量。如果计划测试的数量与实际测试的数量不匹配，那么 CasPijs 会认为这是一个可疑的错误。因此，确保正确计划的测试数量是正确的，这一直是一个很好的做法。我们将向您展示如何计算本例中执行的测试数量。

第三个参数是 JavaScript 回调函数，它包含将要执行的测试套件。请注意，回调函数获取[T0]实例（一个 JavaScript 对象）作为输入参数。在这个函数中，我们调用`casper`对象的`start`方法。这将启动 Casper 并打开在方法的第一个输入参数中指定的 URL。`start`方法的第二个输入参数被认为是下一步，即访问 URL 后立即运行的 JavaScript 回调函数。我们指定的下一步是`wait`函数，它是我们之前创建的。这将产生访问 IGWEB 主页的 URL 的效果，并等待主内容`div`容器在远程 DOM 中可用。

在这一点上，我们可以开始我们的测试。我们`range`通过`routesTokenMap`中的每条路线和`expectedString`对：

```go
  for route, expectedString := range routesTokenMap {
    func(route, expectedString string) {
```

我们调用`casper`对象的`then`方法向堆栈中添加新的导航步骤：

```go
      casper.Call("then", func() {
        casper.Call("click", "a[href^='"+route+"']")
      })
```

在表示导航步骤的函数中，我们调用`casper`对象的`click`方法。`click`方法将在与提供的 CSS 选择器匹配的元素上触发鼠标单击事件。我们为每个路由创建一个 CSS 选择器，它将匹配网页主体上的一个链接。CSS 选择器允许我们模拟用户单击导航链接的场景。

不属于导航链接的两条路线是`/`和`/product-detail/swiss-army-knife`路线。`/`路线的 CSS 选择器将匹配网页左上角为网站徽标声明的链接。测试此场景时，它相当于用户单击网站的徽标。在这种情况下，一旦呈现了产品页面的内容，将在主内容区域 div 中找到瑞士军刀的产品详细信息页面链接`/product-detail/swiss-army-knife`。当测试此场景时，它相当于用户单击产品列表页面上的瑞士军刀图像。

在下一个导航步骤中，我们将生成测试用例的屏幕截图，并检查在网页正文中是否找到`expectedString`：

```go
      casper.Call("then", func() {
        casper.Call("wait", 1800, func() {
          routeName := strings.Replace(route, `/`, "", -1)
          screenshotName := "route_render_test_" + routeName + ".png"
          casper.Call("capture", "screenshots/"+screenshotName)
          casper.Get("test").Call("assertTextExists", expectedString,  
          "Expected text \""+expectedString+"\", in body of web page, 
          when accessing route: "+route)
        })
      })
    }(route, expectedString)
  }
```

这里，我们调用`casper`对象的`capture`方法来提供生成的屏幕截图图像的路径。将为我们测试的每条路线生成一个屏幕截图，因此我们将从该测试生成总共七个屏幕截图图像。

注意，我们调用 casper 的`wait`方法来引入`1800`毫秒延迟，并提供`then`回调函数。在会话英语中，我们可以将此调用解释为“等待 1800 毫秒，然后执行此操作”。在我们提供的`then`回调函数中，我们对 casper 的`test`对象（即`tester`模块）调用`assertTextExists`方法。在`assertTextExists`方法调用中，我们提供了应该存在于网页主体中的`expectedString`，第二个参数是描述测试的消息。我们增加了`1800`毫秒延迟，为网页内容在网页上显示提供足够的时间。

请注意，无论何时调用 casper`tester`模块中`assert`方法家族中的任何类型的`assert`方法，它都被视为一个测试。回想一下，当我们调用 tester 模块的`begin`方法时，我们提供了一个`7`值，以指示此测试套件中将进行 7 个预期测试。因此，您在测试中拥有的`assert`方法调用的数量必须与将要执行的预期测试的数量相匹配，否则您将在运行测试套件时遇到可疑错误。

我们调用`casper`对象的`run`方法来运行测试套件：

```go
  casper.Call("run", func() {
    casper.Get("test").Call("done")
  })
```

注意，我们为`run`方法提供了一个回调函数。当所有步骤都已完成运行时，将调用此回调函数。在回调函数中，我们调用`tester`模块的`done`方法来表示测试套件的结束。请记住，在 CasperJS 测试中，每当我们调用`tester`模块上的`begin`方法时，测试中必须有一个相应的位置，在那里我们调用 tester 模块的`done`方法。如果我们忘记将方法调用留给`done`，程序将挂起，我们将不得不中断程序（使用*Ctrl*+*C*按键）。

我们必须将测试转换为 JavaScript 等价物，我们可以通过运行`build_casper_tests.sh`bash 脚本来实现：

```go
$ $IGWEB_APP_ROOT/scripts/build_casper_tests.sh
```

bash 脚本将传输驻留在`client/tests/go`目录中的所有用 Go 编写的 CasperJS 测试，并将生成的 JavaScript 源文件放在`client/tests/js`目录中。我们将在后续的测试运行中省略此步骤。请记住，如果您对需要重新运行此脚本以使更改生效的任何测试进行了更改，请在下次运行测试套件时执行。

我们可以通过发出以下命令来运行测试以检查客户端路由：

```go
$ cd $IGWEB_APP_ROOT/client/tests
$ casperjs test js/routes_test.js
```

*图 10.1*显示了运行客户端路由测试套件的屏幕截图：

![](Images/41dfb567-3a37-4b6c-8814-5928926b71ef.png)

图 10.1：运行客户端路由测试套件

可在`client/tests/screenshots`文件夹中找到测试生成的截图图像。屏幕截图很方便，因为它们允许人类用户直观地查看测试结果。

*图 10.2*为`/`路线测试截图：

![](Images/fb2e82c8-a64f-4f2b-9f2b-014b2f11dccf.jpg)

图 10.2：测试车辆/路线

*图 10.3*显示了测试`/index`路线的屏幕截图。注意页面呈现与*图 10.2*相同，应该是：

![](Images/1eaa6278-ca2f-4f14-bb58-48db34218b0c.jpg)

图 10.3：测试/索引路由

请注意，通过提供延迟时间`1800`毫秒，我们为转盘齿轮和活动时钟齿轮提供了足够的加载时间。在本章后面，您将学习如何测试这些齿轮。

*图 10.4*为`/products`路线测试截图：

![](Images/4bd932f1-20ee-4f35-943b-54e3a4e13f07.jpg)

图 10.4：测试产品/路线

从这个测试中，我们可以直观地确认产品列表页面加载良好。下一个测试步骤将单击瑞士军刀的图像，导航到其产品详细信息页面。

*图 10.5*为`/product-detail/swiss-army-knife`路线测试截图：

![](Images/6cc75f81-3bfe-46f3-8191-244984eea02c.jpg)

图 10.5：测试/产品细节路线

*图 10.6*为`/about`路线测试截图：

![](Images/0ea50626-d930-4c4b-a750-adab177c1edd.jpg)

图 10.6：测试/关于路线

请注意，time ago cog 已为所有三只地鼠正确渲染。

*图 10.7*为`/contact`路线测试截图：

![](Images/24d218b2-ecb9-4a99-8aab-ad4490824fff.jpg)

图 10.7：测试/接触路线

*图 10.8*显示了测试`/shopping-cart`路线的截图。

![](Images/7d93df9f-ec48-4fdd-bbde-00e75c0dfce5.jpg)

图 10.8：测试/购物车路线

通过屏幕截图提供的视觉确认，我们现在可以确信客户端路由正在按预期工作。除此之外，生成的屏幕截图帮助我们直观地确认模板渲染功能正常。现在让我们看看验证联系人窗体功能。

# 核实联络表格

我们为验证联系人表单功能而实施的测试可以在`client/tests/go`目录中的`contactform_test.go`源文件中找到。

在本测试中，我们定义了`FormParams``struct`，表示在执行我们的测试步骤时，联系人表单应填写的表单参数：

```go
type FormParams struct {
  *js.Object
  FirstName string `js:"firstName"`
  LastName string `js:"lastName"`
  Email string `js:"email"`
  MessageBody string `js:"messageBody"`
}
```

我们创建了一个 JavaScript`wait`函数，以确保测试运行者在运行其他步骤之前，将等待主内容`div`容器加载：

```go
var wait = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  this.Call("waitForSelector", "#primaryContent")
  return nil
})
```

根据我们正在进行的测试类型，我们将引入以下三个 JavaScript 函数来填充联系人表单的字段：

*   `fillOutContactFormWithPoorlyFormattedEmailAddress`
*   `fillOutContactFormPartially`
*   `filloutContactFormCompletely`

顾名思义，`fillOutContactFormWithPoorlyFormattedEmailAddress`函数将向`email`字段提供无效的电子邮件地址：

```go
var fillOutContactFormWithPoorlyFormattedEmailAddress = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  params := &FormParams{Object: js.Global.Get("Object").New()}
  params.FirstName = "Isomorphic"
  params.LastName = "Gopher"
  params.Email = "dev@null@test@test.com"
  params.MessageBody = "Sending a contact form submission using CasperJS and PhantomJS"
  this.Call("fill", "#contactForm", params, true)
  return nil
})
```

注意，我们创建了一个新的`FormParams`实例，并填充了`FirstName`、`LastName`、`Email`和`MessageBody`字段。请特别注意，我们为`Email`字段提供了无效的电子邮件地址。

在此函数上下文中，`this`变量表示`tester`模块。我们调用了`tester`模块的`fill`方法，向联系人表单、`params`对象和一个布尔值`true`提供 CSS 选择器，以指示表单应该提交。

填写并提交表单后，我们希望客户端表单验证会向我们显示一条错误消息，表明我们提供了无效的电子邮件地址。

`fillOutContactFormPartially`功能将部分填写联系人表单，留下一些必填字段未填写，导致表单不完整：

```go
var fillOutContactFormPartially = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  params := &FormParams{Object: js.Global.Get("Object").New()}
  params.FirstName = "Isomorphic"
  params.LastName = ""
  params.Email = "devnull@test.com"
  params.MessageBody = ""
  this.Call("fill", "#contactForm", params, true)
  return nil
})
```

在这里，我们创建一个新的`FormParams`实例，注意我们为`LastName`和`MessageBody`字段提供了一个空的`string`值。

填写并提交表单后，我们希望客户端表单验证向我们显示一条错误消息，表明我们尚未填写这两个必填字段。

`fillOutContactFormCompletely`功能将填写联系人表格的所有字段，并包括格式正确的电子邮件地址：

```go
var fillOutContactFormCompletely = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  params := &FormParams{Object: js.Global.Get("Object").New()}
  params.FirstName = "Isomorphic"
  params.LastName = "Gopher"
  params.Email = "devnull@test.com"
  params.MessageBody = "Sending a contact form submission using CasperJS and PhantomJS"
  this.Call("fill", "#contactForm", params, true)
  return nil
})
```

这里我们创建一个新的`FormParams`实例，并填充联系人表单的所有字段。对于`Email`字段，我们确保提供格式正确的电子邮件地址。

填写并提交表单后，我们希望客户端表单验证为表单开绿灯，表单在幕后将启动对 rest API 端点的 XHR 调用，以验证是否已使用服务器端表单验证正确填写了联系人表单。我们期望服务器端验证也会为表单字段值亮起绿灯，从而产生一条确认消息。如果我们能够成功验证我们已获得确认消息，我们的测试将通过。

与上一个示例一样，我们首先声明视口参数并设置 web 浏览器的视口大小：

```go
func main() {

  viewportParams := &caspertest.ViewportParams{Object: 
  js.Global.Get("Object").New()}
  viewportParams.Width = 1440
  viewportParams.Height = 960
  casper.Get("options").Set("viewportSize", viewportParams)
```

请注意，我们调用`tester`模块的`begin`方法来启动 Contact Form Test Suite 中的测试：

```go
  casper.Get("test").Call("begin", "Contact Form Test Suite", 4, 
  func(test *js.Object) {
    casper.Call("start", "http://localhost:8080/contact", wait)
  })
```

我们提供了`begin`方法和测试说明`"Contact Form Test Suite"`。然后，我们提供该套件中预期测试的数量，即`4`。请记住，该值对应于我们进行的测试数量。我们可以通过调用属于`tester`模块`assert`方法系列的方法的次数来确定执行的测试次数。我们提供了`then`回调函数，在这里我们调用`casper`对象上的`start`方法，向联系人页面提供 URL，并提供`wait`函数，指示我们应该等待主内容`div`容器加载，然后再执行任何测试步骤。

我们测试的第一个场景是在提供格式不正确的电子邮件地址时检查客户端验证：

```go
  casper.Call("then", 
  fillOutContactFormWithPoorlyFormattedEmailAddress)
  casper.Call("wait", 450, func() {
    casper.Call("capture", 
    "screenshots/contactform_test_invalid_email_error_message.png")
    casper.Get("test").Call("assertSelectorHasText", "#emailError", 
    "The e-mail address entered has an improper syntax", "Display e-
    mail address syntax error when poorly formatted e-mail entered.")
  })
```

我们调用 casper 对象的`then`方法，提供`fillOutContactFormWithPoorlyFormattedEmailAddress`JavaScript 函数作为`then`回调函数。我们等待`450`毫秒以获得结果，捕获测试运行的屏幕截图（如*图 10.10*所示），然后调用`tester`模块上的`assertSelectorHasText`方法，提供包含错误消息的元素的 CSS 选择器，以及错误消息应该显示的预期文本，然后是对我们正在进行的测试的描述。

我们测试的第二个场景是在提交不完整表单时检查客户端验证：

```go
  casper.Call("then", fillOutContactFormPartially)
  casper.Call("wait", 450, func() {
    casper.Call("capture", 
    "screenshots/contactform_test_partially_filled_form_errors.png")
    casper.Get("test").Call("assertSelectorHasText", "#lastNameError", 
    "The last name field is required.", "Display error message when the 
    last name field has not been filled out.")
    casper.Get("test").Call("assertSelectorHasText",  
    "#messageBodyError", "The message area must be filled.", "Display 
    error message when the message body text area has not been filled 
    out.")
  })
```

我们调用`casper`对象的`then`方法，提供`fillOutContactFormPartially`JavaScript 函数，作为`then`回调函数。我们等待`450`毫秒以获得结果，捕获测试运行的屏幕截图（如*图 10.11*所示），并在此场景中执行两个测试。

在第一个测试中，我们在`tester`模块上调用`assertSelectorHasText`方法，为包含姓氏字段错误消息的元素提供 CSS 选择器，以及错误消息应该包含的预期文本，然后是测试描述。在第二个测试中，我们在`tester`模块上调用`assertSelectorHasText`方法，为消息正文文本区域提供包含错误消息的元素的 CSS 选择器，错误消息应该具有的预期文本，然后是测试描述。

我们测试的第三个场景是检查在提交正确填写的联系表单时是否显示了确认消息：

```go
  casper.Call("then", fillOutContactFormCompletely)
  casper.Call("wait", 450, func() {
    casper.Call("capture", 
    "screenshots/contactform_confirmation_message.png")
    casper.Get("test").Call("assertSelectorHasText", "#primaryContent 
    h1", "Confirmation", "Display confirmation message after submitting 
    contact form.")
  })
```

我们调用`casper`对象的`then`方法，提供`fillOutContactFormCompletely`JavaScript 函数，作为`then`回调函数。我们等待`450`毫秒以获得结果，捕获测试运行的屏幕截图（如*图 10.12*所示），并调用`casper`对象的`assertSelectorHasText`方法。我们提供 CSS 选择器`"#primaryContent h1"`，因为确认消息将位于`<h1>`标记内。我们提供确认消息应包含的预期文本，即`"Confirmation"`。最后，我们对`assertSelectorHasText`方法的最后一个参数的测试进行了说明。

为了表示测试套件的结束，我们调用 casper 对象的`run`方法，在`then`回调函数中，我们调用 tester 模块的`done`方法：

```go
  casper.Call("run", func() {
    casper.Get("test").Call("done")
  })
```

假设您在`client/tests`文件夹中，您可以发出以下命令来运行联系人表单测试套件：

```go
$ casperjs test js/contactform_test.js
```

*图 10.9*显示运行联系人表单测试套件的屏幕截图：

![](Images/23a64aa1-e615-485d-8963-23c087ae03b9.png)

图 10.9：运行联系人表单测试套件

*图 10.10*显示运行第一个测试的生成屏幕截图，该测试检查客户端表单验证是否正确检测到格式不正确的电子邮件地址：

![](Images/e460f8a1-c6f5-48d1-b820-b84ae40699ef.jpg)

图 10.10：测试电子邮件验证语法

*图 10.11*显示生成的运行第二次测试和第三次测试的截屏图像，检查客户端表单验证是否正确检测到姓氏字段和消息正文文本区域未填写：

![](Images/38941cab-a572-415b-9fc3-d1af80f33375.jpg)

图 10.11：验证表单验证是否检测到未填写的必填字段的测试

*图 10.12*显示了生成的运行第四次测试的屏幕截图，该截图检查在成功填写并提交联系表后是否显示了确认消息：

![](Images/6ac84bc0-7438-47bf-a309-700223b90e08.jpg)

图 10.12：验证确认消息的测试

既然我们已经验证了联系人表单的客户端验证功能，那么让我们看看如何为购物车功能实现 CasperJS 测试套件。

# 验证购物车功能

为了验证购物车的功能，我们必须能够多次将产品添加到购物车，检查购物车中是否存在显示适当数量的产品，并能够从购物车中移除产品。因此，购物车测试套件中需要 3 个预期测试。

`shoppingcart_test.go`源文件中的`main`函数位于`client/tests/go`目录中，实现购物车测试套件：

```go
func main() {

  viewportParams := &caspertest.ViewportParams{Object: 
  js.Global.Get("Object").New()}
  viewportParams.Width = 1440
  viewportParams.Height = 960
  casper.Get("options").Set("viewportSize", viewportParams)

  casper.Get("test").Call("begin", "Shopping Cart Test Suite", 3, 
  func(test *js.Object) {
    casper.Call("start", "http://localhost:8080/products", wait)
  })
```

在`main`函数中，我们设置 web 浏览器的视口大小。我们通过调用`casper`对象上的`begin`方法来启动一个新的测试套件。注意，我们已经指出在这个测试套件中有 3 个预期的测试。在构成`begin`方法最后一个参数的`then`回调函数中，我们调用`casper`对象的`start`方法，为产品列表页面提供 URL，并提供 JavaScript`wait`函数作为`then`回调函数。这将导致程序在执行任何测试之前，等待主内容`div`容器加载到 DOM 中。

使用以下代码，我们将三把瑞士军刀添加到购物车中：

```go
  for i := 0; i < 3; i++ {
    casper.Call("then", func() {
      casper.Call("click", ".addToCartButton:first-child")
    })
  }
```

请注意，我们已经通过 CSS 选择器`".addToCartButton:first-child"`传递了`casper`对象的`click`方法，以确保点击瑞士军刀产品，因为它是产品列表页面上显示的第一个产品。

为了验证瑞士军刀是否正确放置在购物车中，我们需要导航到购物车页面：

```go
  casper.Call("then", func() {
    casper.Call("click", "a[href^='/shopping-cart']")
  })
```

我们的第一个测试包括验证购物车中是否存在正确的产品类型：

```go
  casper.Call("wait", 207, func() {
    casper.Get("test").Call("assertTextExists", "Swiss Army Knife", "Display correct product in shopping cart.")
  })
```

我们通过在`tester`模块对象上调用`assertTextExists`方法并提供预期的文本值`"Swiss Army Knife"`来检查`"Swiss Army Knife"`文本是否存在于购物车页面上。

我们的第二个测试包括验证购物车页面上是否存在正确的产品数量：

```go
  casper.Call("wait", 93, func() {
    casper.Get("test").Call("assertTextExists", "Quantity: 3", "Display 
    correct product quantity in shopping cart.")
  })
```

我们再次调用`tester`模块对象的`assertTextExists`方法，传入预期的文本`"Quantity: 3"`。

我们生成一个购物车的截图，这个截图（如*图 10.14*所示）应该显示数量值为`3`的瑞士军刀：

```go
  casper.Call("wait", 450, func() {
    casper.Call("capture", "screenshots/shoppingcart_test_add_item.png")
  })
```

我们的最后一个测试包括从购物车中删除一个项目。我们使用以下代码从购物车中删除产品：

```go
  casper.Call("then", func() {
    casper.Call("click", ".removeFromCartButton:first-child")
  })
```

为了验证产品已成功从购物车中删除，我们需要检查购物车页面上是否存在指示购物车为空的消息：

```go
  casper.Call("wait", 5004, func() {
    casper.Call("capture", "screenshots/shoppingcart_test_empty.png")
    casper.Get("test").Call("assertTextExists", "Your shopping cart is   
    empty.", "Empty the shopping cart.")
  })
```

注意，在我们调用`tester`模块对象的`assertTextExists`方法时，我们检查网页上是否存在`"Your shopping cart is empty."`文本。在此之前，我们还生成了一个屏幕截图（如*图 10.15*所示），显示购物车处于空状态。

最后，我们将用以下代码表示购物车测试套件的结束：

```go
  casper.Call("run", func() {
    casper.Get("test").Call("done")
  })
```

我们可以通过发出以下命令为购物车测试套件运行 CasperJS 测试：

```go
$ casperjs test js/shoppingcart_test.js
```

*图 10.13*显示了运行购物车测试套件的结果截图：

![](Images/198e3138-fef7-4a77-aaac-3d297f1761a1.png)

图 10.13：运行购物车测试套件

*图 10.14*显示了生成的显示测试用例的屏幕截图，其中`3`瑞士军刀已成功添加到购物车中：

![](Images/bc3bbfd2-e87e-482b-9d5b-0511eb5cffe9.jpg)

图 10.14：将产品多次添加到购物车的测试用例

*图 10.15*显示了生成的屏幕截图，显示了测试用例，其中瑞士军刀产品已被移除，从而清空了购物车：

![](Images/f46a1785-f500-4a37-b10c-e58ceb670de9.jpg)

图 10.15：验证清空购物车的测试

现在我们已经验证了购物车的功能，让我们来看看测试实时聊天功能。

# 验证实时聊天功能

实时聊天测试套件由三个测试组成。首先，我们必须确保当点击顶部栏上的实时聊天图标时，聊天框打开。第二，我们必须确保聊天机器人在我们提问时对我们做出响应。第三，当我们浏览到网站的另一个部分时，我们必须确保对话被保留。

live chat 测试套件在`client/tests/go`目录下的`livechat_test.go`源文件中实现。

`waitChat`JavaScript 函数将用于等待聊天框打开：

```go
var waitChat = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  this.Call("waitForSelector", "#chatbox")
  return nil
})
```

`askQuestion`JavaScript 函数将用于向聊天机器人发送问题：

```go
var askQuestion = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  this.Call("sendKeys", "input#chatboxInputField", "What is Isomorphic 
  Go?")
  this.Call("sendKeys", "input#chatboxInputField", 
  casper.Get("page").Get("event").Get("key").Get("Enter"))
  return nil
})
```

注意，我们使用`tester`模块对象的`sendKeys`方法（将`this`变量绑定到`tester`模块对象）来输入`"What is Isomorphic Go"`问题，我们再次调用`sendKeys`方法来发送`enter`键（相当于按下键盘上的`enter`键）。

在`main`函数中，我们设置 web 浏览器的视口大小并开始测试套件：

```go
func main() {

  viewportParams := &caspertest.ViewportParams{Object: 
  js.Global.Get("Object").New()}
  viewportParams.Width = 1440
  viewportParams.Height = 960
  casper.Get("options").Set("viewportSize", viewportParams)

  casper.Get("test").Call("begin", "Live Chat Test Suite", 3, func(test 
  *js.Object) {
    casper.Call("start", "http://localhost:8080/index", wait)
  })
```

以下代码将通过模拟用户单击顶部栏上的实时聊天图标来激活实时聊天功能：

```go
  casper.Call("then", func() {
    casper.Call("click", "#livechatContainer img")
  })
```

以下代码将等待聊天室打开后再继续：

```go
casper.Call("then", waitChat)
```

聊天室打开后，我们可以使用以下代码验证聊天室是否可见：

```go
  casper.Call("wait", 1800, func() {
    casper.Call("capture", 
    "screenshots/livechat_test_chatbox_open.png")
    casper.Get("test").Call("assertSelectorHasText", "#chatboxTitle 
    span", "Chat with", "Display chatbox.")
  })
```

注意，我们调用了`tester`模块对象的`assertSelectorHasText`方法，提供了一个`"#chatboxTitle span"`的 CSS 选择器，以聊天框的标题`span`元素为目标。然后检查`"Chat with"`文本是否存在于`span`元素中，以验证聊天框是否可见。

请注意，我们已经生成了一个屏幕截图，它应该向我们显示打开的聊天框，聊天机器人提供其问候信息（如图 10.17 所示）。

以下代码用于验证聊天机器人在我们提问时是否向我们提供答案：

```go
  casper.Call("then", askQuestion)
  casper.Call("wait", 450, func() {
    casper.Call("capture", 
    "screenshots/livechat_test_answer_question.png")
    casper.Get("test").Call("assertSelectorHasText", 
    "#chatboxConversationContainer", "Isomorphic Go is the methodology 
    to create isomorphic web applications", "Display the answer to 
    \"What is Isomorphic Go?\"")
  })
```

我们调用`askQuestion`函数模拟用户输入`"What is Isomorphic Go"`问题并按下`enter`键。我们等待`450`毫秒，然后生成一个屏幕截图，该截图应该显示回答我们问题的实时聊天机器人（如*图 10.18*所示）。我们通过调用`tester`模块对象的`assertSelectorHasText`方法并向其提供 CSS 选择器以访问`div`容器来验证聊天机器人是否提供了答案，该容器包含对话和预期答案的子字符串。

目前，我们在主页上。为了测试在导航到网站的不同部分时是否保留对话，我们使用以下代码：

```go
  casper.Call("then", func() {
    casper.Call("click", "a[href^='/about']")
  })

  casper.Call("then", wait)
```

在这里，我们指定导航到 About 页面，然后等待主内容`div`容器加载。

我们等待`450`毫秒，拍摄屏幕截图（如*图 10.19*所示），然后在我们的测试套件中进行最后一次测试：

```go
  casper.Call("wait", 450, func() {
    casper.Call("capture", 
    "screenshots/livechat_test_conversation_retained.png")
    casper.Get("test").Call("assertSelectorHasText", 
    "#chatboxConversationContainer", "Isomorphic Go is the methodology 
    to create isomorphic web applications", "Verify that the 
    conversation is retained when navigating to another page in the 
    website.")
  })
```

这里的最后一个测试是我们进行的上一个测试的重复。由于我们正在测试会话是否被保留，因此我们希望聊天机器人在上次测试后给出的答案会保存在包含会话的`div`容器中。

我们将通过模拟用户单击关闭控件（位于聊天框右上角的Χ）来关闭聊天框，以便 websocket 连接正常关闭：

```go
  casper.Call("then", func() {
    casper.Call("click", "#chatboxCloseControl")
  })
```

最后，我们将用以下代码表示 live chat 测试套件的结束：

```go
  casper.Call("run", func() {
    casper.Get("test").Call("done")
  })
```

我们可以通过发出以下命令来运行实时聊天测试套件的 CasperJS 测试：

```go
$ casperjs test js/livechat_test.js
```

*图 10.16*显示了运行实时聊天测试套件的结果截图：

![](Images/3a3a32ac-e59b-46df-8825-8444727993e5.png)

图 10.16：运行实时聊天测试套件

*图 10.17*显示了生成的显示测试用例的屏幕截图，我们检查聊天框是否已打开：

![](Images/2356f933-0a29-4f85-9cb1-e16773ef5aa0.jpg)

图 10.17：验证聊天框是否出现的测试

*图 10.18*显示了生成的显示测试用例的屏幕截图，我们检查聊天机器人是否响应给定问题：

![](Images/287800b7-6d60-4eb6-95b2-ead61e61aa08.jpg)

图 10.18：验证聊天机器人是否响应问题的测试

*图 10.19*显示了生成的显示测试用例的屏幕截图，在这里我们检查在导航到网站上的不同页面后聊天对话是否被保留：

![](Images/b035846b-882a-430c-abe3-f4f36f65c4ef.jpg)

图 10.19：测试在导航到网站的不同部分后是否保留聊天对话

现在我们已经验证了实时聊天功能的功能，让我们从 time ago cog 开始测试 cog。

为了简洁起见，图 10.17、10.18、10.19、10.21、10.23、10.25、10.27 和 10.29 中所示的生成屏幕截图已被裁剪。

# 验证时间间隔 cog

测试 time ago cog 包括确定一只地鼠加入 IGWEB 团队的已知日期。我们将 2017 年 5 月 24 日定为 Molly 的开始日期，并以此为基础测试人类可以理解的时间，该时间显示在关于页面上 Molly 的生物数据下。

这是 time ago cog 的测试套件，它在`client/tests/go`目录中的`humantimecog_test.go`源文件中实现：

```go
package main

import (
  "time"

  "github.com/EngineerKamesh/igb/igweb/client/tests/go/caspertest"
  humanize "github.com/dustin/go-humanize"
  "github.com/gopherjs/gopherjs/js"
)

var wait = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  this.Call("waitForSelector", "#primaryContent")
  return nil
})

var casper = js.Global.Get("casper")

func main() {

  viewportParams := &caspertest.ViewportParams{Object: 
  js.Global.Get("Object").New()}
  viewportParams.Width = 1440
  viewportParams.Height = 960
  casper.Get("options").Set("viewportSize", viewportParams)

  casper.Get("test").Call("begin", "Time Ago Cog Test Suite", 1, 
  func(test *js.Object) {
    casper.Call("start", "http://localhost:8080/about", wait)
  })

  // Verify the human time representation of Molly's start date
  casper.Call("then", func() {
    mollysStartDate := time.Date(2017, 5, 24, 17, 9, 0, 0, time.UTC)
    mollysStartDateInHumanTime := humanize.Time(mollysStartDate)
    casper.Call("capture", "screenshots/timeago_cog_test.png")
    casper.Get("test").Call("assertSelectorHasText", "#Gopher-Molly 
    .timeagoSpan", mollysStartDateInHumanTime, "Verify human time of 
    Molly's start date produced by the Time Ago Cog.")
  })

  casper.Call("run", func() {
    casper.Get("test").Call("done")
  })

}
```

在`main`函数中，在我们设置视口大小并开始测试套件后，我们创建了一个新的`time`实例，名为`mollysStartDate`，它表示 Molly 加入 IGWEB 团队的时间。然后，我们将`mollyStartDate`传递给`go-humanize`包的`Time`函数（注意，我们将此包别名为`"humanize"`，并将开始日期的人类可理解值存储在`mollysStartDateHumanTime`变量中。

我们生成测试运行的屏幕截图（如图 10.21 所示），然后调用`tester`模块对象的`assertSelectorHasText`方法，将 CSS 选择器传递给包含 Molly 开始日期的`div`容器，该容器采用人类可读的格式。我们还传入了`mollysStartDateInHumanTime`变量，因为这是选择器中应该存在的预期文本。

我们将通过调用`tester`模块对象上的`done`方法来表示 time ago cog 测试套件的结束。

我们可以通过发出以下命令为 time ago cog 测试套件运行 CasperJS 测试：

```go
$ casperjs test js/humantimecog_test.js
```

*图 10.20*显示运行 time ago cog 测试套件结果的屏幕截图：

![](Images/167feaf5-4996-4f62-b9f6-f6ad7d46c6cf.png)

图 10.20：运行 time ago cog 测试套件

*图 10.21*显示了生成的显示 About 页面的屏幕截图，其中 Molly 的开始日期以人类可读的时间格式打印出来：

![](Images/4939e782-a0bc-42a1-b2a9-0dc531f15f44.jpg)

图 10.21：验证时间间隔 cog 的试验

现在我们已经验证了 time ago cog 的功能，让我们看看测试实时时钟 cog 的功能。

# 验证实时时钟 cog

验证用户本地时间的实时时钟 cog 功能，包括创建一个基于本地时区名称和本地时区偏移量格式化的当前时间的新`time`实例，并将其与主页上显示的`myLiveClock``div`容器中的值进行比较。

以下是实时时钟 cog 的测试套件，它在`client/tests/go`目录中的`liveclockcog_test.go`源文件中实现：

```go
package main

import (
  "time"

  "github.com/EngineerKamesh/igb/igweb/client/tests/go/caspertest"
  "github.com/gopherjs/gopherjs/js"
)

var wait = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  this.Call("waitForSelector", "#myLiveClock div")
  return nil
})

var casper = js.Global.Get("casper")

func main() {

  viewportParams := &caspertest.ViewportParams{Object: 
  js.Global.Get("Object").New()}
  viewportParams.Width = 1440
  viewportParams.Height = 960
  casper.Get("options").Set("viewportSize", viewportParams)

  casper.Get("test").Call("begin", "Live Clock Cog Test Suite", 1, 
  func(test *js.Object) {
    casper.Call("start", "http://localhost:8080/index", wait)
  })

  // Verify that the live clock shows the current time for the local 
  time zone
  casper.Call("then", func() {
    casper.Call("wait", 900, func() {

      localZonename, localOffset := time.Now().In(time.Local).Zone()
      const layout = time.RFC1123
      var location *time.Location
      location = time.FixedZone(localZonename, localOffset)
      casper.Call("wait", 10, func() {
        t := time.Now()
        currentTime := t.In(location).Format(layout)
        casper.Get("test").Call("assertSelectorHasText", "#myLiveClock 
        div", currentTime, "Display live clock for local timezone.")
      })

    })
  })

  casper.Call("then", func() {
    casper.Call("capture", "screenshots/liveclock_cog_test.png")
  })

  casper.Call("run", func() {
    casper.Get("test").Call("done")
  })

}
```

在设置 web 浏览器的视口大小并通过访问主页启动测试套件后，我们等待`900ms`，然后收集用户的本地时区名称和本地时区偏移量。我们将根据 RFC1123 布局格式化时间。这恰好与实时时钟 cog 用于显示时间的布局相同。

我们从传入`localZonename`和`localOffset`的`time`包调用`FixedZone`函数来获取位置。我们创建一个新的时区实例，并使用`location`和 RFC1123`layout`对其进行格式化。我们使用`tester`模块对象的`assertSelectorHasText`方法来查看使用 RFC1123`layout`和使用用户当前状态`location`格式化的当前时间是否存在于`assertSelectorHasText`方法指定的选择器中。

我们生成测试运行的屏幕截图（如图 10.23 所示），然后在`tester`模块对象上调用`done`方法，表示测试套件结束。

我们可以通过发出以下命令为实时时钟 cog 测试套件运行 CasperJS 测试：

```go
$ casperjs test js/liveclockcog_test.js
```

*图 10.22*显示运行实时时钟 cog 测试套件结果的屏幕截图：

![](Images/2e537569-a9fc-488b-a40b-35643edd978c.png)

图 10.22：运行实时时钟 cog 测试套件

*图 10.23*显示生成的屏幕截图，显示主页上的实时时钟 cog：

![](Images/85e8e540-f8e5-4f98-acf1-ca380e3bb0ba.jpg)

图 10.23：在主页上测试实时时钟 cog

现在我们已经验证了实时时钟 cog 的功能，让我们来看看测试日期选择器 cog 的功能。

# 验证日期选择器 cog

验证日期选择器 cog 的功能包括导航到联系人页面，并单击时间敏感日期输入字段。这将触发日历小部件的显示。

以下是日期选择器 cog 的测试套件，它在位于`client/tests/go`目录的`datepickercog_test.go`源文件中实现：

```go
package main

import (
  "github.com/EngineerKamesh/igb/igweb/client/tests/go/caspertest"
  "github.com/gopherjs/gopherjs/js"
)

var wait = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  this.Call("waitForSelector", "#primaryContent")
  return nil
})

var casper = js.Global.Get("casper")

func main() {

  viewportParams := &caspertest.ViewportParams{Object: 
  js.Global.Get("Object").New()}
  viewportParams.Width = 1440
  viewportParams.Height = 960
  casper.Get("options").Set("viewportSize", viewportParams)

  casper.Get("test").Call("begin", "Date Picker Cog Test Suite", 1, 
  func(test *js.Object) {
    casper.Call("start", "http://localhost:8080/contact", wait)
  })

  // Verify that the date picker is activated upon clicking the date 
  input field
  casper.Call("then", func() {
    casper.Call("click", "#byDateInput")
    casper.Call("capture", "screenshots/datepicker_cog_test.png")
    casper.Get("test").Call("assertVisible", ".pika-single", "Display 
    Datepicker Cog.")
  })

  casper.Call("run", func() {
    casper.Get("test").Call("done")
  })
}
```

在`main`函数中，我们设置 web 浏览器的视口大小，并通过导航到联系人页面启动测试套件。

然后我们调用`casper`对象的`click`方法，并提供 CSS 选择器`"#byDateInput"`，它将向时间敏感日期输入字段发送鼠标点击事件，该字段将显示日历小部件。

我们获取测试运行的屏幕截图（如*图 10.25*所示），然后调用`tester`模块对象的`assertVisible`方法，提供`".pika-single"`选择器和测试名称，作为该方法的输入参数。`assertVisible`方法将断言至少有一个与提供的选择器表达式匹配的元素可见。

最后，我们在`tester`模块对象上调用`done`方法，以表示测试套件的结束。

我们可以通过发出以下命令为日期选择器 cog 测试套件运行 CasperJS 测试：

```go
$ casperjs test js/datepickercog_test.js
```

*图 10.24*显示了运行日期选择器 cog 测试套件的结果截图：

![](Images/b21e8409-5679-499d-b43f-2c07f6351391.png)

图 10.24：运行日期选择器 cog 测试套件

*图 10.25*显示了在点击时间敏感日期输入字段后生成的显示日历小部件的屏幕截图：

![](Images/e736752f-9000-4c4a-8520-62d18ef8be0a.jpg)

图 10.25：验证日期选择器是否出现的测试

既然我们已经验证了日期选择器 cog 的功能，那么让我们来看看如何测试转盘 cog 的功能。

# 验证转盘齿轮

验证旋转木马 cog 的功能包括提供足够的时间来加载旋转木马的图像，并为第一个图像提供显示在网页上的`watch.jpg`图像文件。

以下是转盘 cog 的测试套件，它在位于`client/tests/go`目录中的`carouselcog_test.go`源文件中实现：

```go
package main

import (
  "github.com/EngineerKamesh/igb/igweb/client/tests/go/caspertest"
  "github.com/gopherjs/gopherjs/js"
)

var wait = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  this.Call("waitForSelector", "#carousel")
  return nil
})

var casper = js.Global.Get("casper")

func main() {

  viewportParams := &caspertest.ViewportParams{Object: 
  js.Global.Get("Object").New()}
  viewportParams.Width = 1440
  viewportParams.Height = 960
  casper.Get("options").Set("viewportSize", viewportParams)

  casper.Get("test").Call("begin", "Carousel Cog Test Suite", 1, 
  func(test *js.Object) {
    casper.Call("start", "http://localhost:8080/index", wait)
  })

  // Verify that the carousel cog has been loaded.
  casper.Call("wait", 1800, func() {
    casper.Get("test").Call("assertResourceExists", "watch.jpg", 
    "Display carousel cog.")
  })

  casper.Call("then", func() {
    casper.Call("capture", "screenshots/carousel_cog_test.png")
  })

  casper.Call("run", func() {
    casper.Get("test").Call("done")
  })

}
```

在设置 web 浏览器的视口大小并启动测试套件后，通过导航到主页，我们等待`1800`毫秒，然后调用`tester`模块对象上的`assetResourceExists`方法，提供要检查的资源的名称，这恰好是`"watch.jpg"`图像文件，以及测试的描述。`assertResourceExists`函数检查`"watch.jpg"`图像文件是否存在于加载到网页上的资产集中。

我们获取测试运行的屏幕截图（如图 10.27*所示*，然后在`casper`对象上调用`done`方法，表示测试套件的结束。

我们可以通过发出以下命令来运行 carousel cog 测试套件的 CasperJS 测试：

```go
$ casperjs test js/carouselcog_test.js
```

*图 10.26*显示了运行转盘齿轮测试套件的结果的屏幕截图：

![](Images/17e19dbb-85e2-46db-b799-0f4e08e90ac5.png)

图 10.26：运行转盘齿轮测试套件

*图 10.27*显示了生成的显示转盘齿轮的屏幕截图：

![](Images/682d8e25-dc8f-45b3-a254-22e383f29bff.jpg)

图 10.27：验证转盘齿轮是否出现的测试

既然我们已经验证了转盘齿轮的功能，那么让我们来看看 notify 齿轮的功能测试。

# 验证通知 cog

验证 notify cog 的功能包括导航到产品列表页面，通过单击所列产品上的“添加到购物车”按钮将项目添加到购物车，然后验证通知是否出现在网页上。

以下是 notify cog 的测试套件，它在位于`client/test/go`目录中的`notifycog_test.go`源文件中实现：

```go
package main

import (
  "github.com/EngineerKamesh/igb/igweb/client/tests/go/caspertest"
  "github.com/gopherjs/gopherjs/js"
)

var wait = js.MakeFunc(func(this *js.Object, arguments []*js.Object) interface{} {
  this.Call("waitForSelector", "#primaryContent")
  return nil
})

var casper = js.Global.Get("casper")

func main() {

  viewportParams := &caspertest.ViewportParams{Object: 
  js.Global.Get("Object").New()}
  viewportParams.Width = 1440
  viewportParams.Height = 960
  casper.Get("options").Set("viewportSize", viewportParams)

  casper.Get("test").Call("begin", "Notify Cog Test Suite", 1, 
  func(test *js.Object) {
    casper.Call("start", "http://localhost:8080/products", wait)
  })

  // Add an item to the shopping cart
  casper.Call("then", func() {
    casper.Call("click", ".addToCartButton:nth-child(1)")
  })

  // Verify that the notification has been displayed
  casper.Call("wait", 450, func() {
    casper.Get("test").Call("assertSelectorHasText", "#alertify-logs 
    .alertify-log-success", "Item added to cart", "Display Notify Cog 
    when item added to shopping cart.")
  })

  casper.Call("wait", 450, func() {
    casper.Call("capture", "screenshots/notify_cog_test.png")
  })

  // Navigate to Shopping Cart page
  casper.Call("then", func() {
    casper.Call("click", "a[href^='/shopping-cart']")

  })

  // Remove product from shopping cart
  casper.Call("wait", 450, func() {
    casper.Call("click", ".removeFromCartButton:first-child")
  })

  casper.Call("run", func() {
    casper.Get("test").Call("done")
  })
}
```

在设置 web 浏览器的视口并通过导航到产品列表页面启动测试套件之后，我们调用`casper`对象的`click`方法，提供`".addToCartButton:nth-child(1)"`选择器。这将向网页上的第一个“添加到购物车”按钮发送鼠标单击事件。

我们等待`450`毫秒，然后调用`tester`模块的`assertSelectorHasText`方法，提供 CSS 选择器、选择器返回的元素中应该存在的文本以及作为输入参数的测试描述。

我们拍摄了测试运行的屏幕截图（如*图 10.29*所示）。然后，我们导航到购物车页面，并从购物车中删除该项目。

最后，我们在`tester`模块对象上调用`done`方法，以表示测试套件的结束。

我们可以通过发出以下命令为 notify cog 测试套件运行 CasperJS 测试：

```go
$ casperjs test js/notifycog_test.js
```

*图 10.28*显示运行 notify cog 测试套件的结果截图：

![](Images/7b92c81a-fd43-4a2a-ae48-6dcd8626da95.png)

图 10.28：运行 notify cog 测试套件

*图 10.29*显示了生成的屏幕截图，显示了网页右下角显示的通知消息，如预期：

![](Images/19ffe05f-950c-4448-9608-7f34d1addbb4.jpg)

图 10.29：运行测试以验证是否显示了通知消息

现在，我们已经验证了 notify cog 是否按预期运行，这就结束了我们对 IGWEB 客户端功能的测试。

*图 10.30*显示了通过运行以下命令运行整个测试套件集合的屏幕截图：

```go
$ casperjs test js/*.js
```

![](Images/2b9a606e-627b-4472-b0a2-af934ca2ff35.png)

图 10.30：运行整个 CasperJS 测试套件集合

# 总结

在本章中，您学习了如何执行端到端测试以验证同构 Go web 应用程序的功能。为了确保 IGWEB 的质量，在网站发布之前，我们首先收集了一组基线功能进行测试。

为了验证服务器端功能，我们使用标准库中 Go 的`testing`包实现了测试。我们实现了验证服务器端路由/模板呈现、联系人表单的验证功能以及成功的联系人表单提交场景的测试。

为了验证客户端功能，我们使用 CasperJS 实现了测试，以验证多个用户交互场景。我们能够使用 CasperJS 执行自动用户交互测试，因为它位于 PhantomJS 之上，PhantomJS 是一种配备 JavaScript 运行时的无头 web 浏览器。我们实施了 CasperJS 测试，以验证客户端路由/模板呈现、联系人表单的客户端验证功能、客户端成功提交联系人表单的场景、购物车的功能以及实时聊天功能。我们还实施了 CasperJS 测试，以验证我们在[第 9 章](09.html)、*cogs–可重用组件*中实施的 cogs 集合的功能。

在[第 11 章](11.html)中*部署一个同构的 Go Web 应用程序*中，您将学习如何将 IGWEB 部署到云端。我们将首先探讨将网站发布到独立服务器的过程。之后，您将学习如何利用 Docker，以多容器 Docker 应用程序的形式发布网站。