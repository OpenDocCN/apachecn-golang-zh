SUMMARY

# Cogs–可重用组件

在本书的前五章中，我们着重于为 IGWEB 上的特定网页或特定功能开发功能，例如我们在上一章中实现的实时聊天功能。到目前为止，我们所提出的解决方案都达到了特定的目的。在促进特定用户界面特性的代码重用方面没有考虑太多因素，因为我们不需要创建它的多个实例。

可重用组件是用户界面小部件，提供了提高可重用性的方法。它们可以以即插即用的方式使用，因为每个组件都是一个独立的用户界面小部件，其中包含自己的一组 Go 源文件和静态资产，如 Go 模板文件，以及 CSS 和 JavaScript 源文件。

在本章中，我们将重点创建**cogs**——可在同构 Go web 应用程序中使用的可重用组件。术语`cog`表示 Go 中的**组件对象。cog 是可重用的用户界面小部件，可以专门在 Go 中实现（一种**纯 cog**），也可以使用 Go 和 JavaScript 实现（一种**混合 cog**）。**

我们可以创建一个`cog`的多个实例，并通过向`cog`（称为**道具**提供输入参数（以键值对的形式）来控制 cog 的行为。当对道具进行后续更改时，`cog`为**反应性**，这意味着它可以自动重新渲染自身。因此，齿轮有能力根据对其道具的更改来更改其外观。

也许，COG 最吸引人的特点是它们易于重用。cog 实现为独立的 Go 包，其中包含一个或多个 Go 源文件以及 cog 实现所需的任何静态资产。

在本章中，我们将介绍以下主题：

*   基本概念
*   实现纯齿轮
*   实现混合 cogs

# 基本齿轮概念

**Cogs**（Go 中的组件对象）是在 Go 中实现的可重用组件。cogs 背后的指导思想是允许开发人员以惯用的方式在前端创建可重用组件。COG 是自包含的，定义为它们自己的 Go 包，这使得它们易于重用和维护。由于 COG 是自包含的，所以可以使用 COG 创建可组合的用户界面。

cog 遵循明确的关注点分离，其中`cog`的表示层使用一个或多个 Go 模板实现，cog 的控制器逻辑在 Go 包中包含的一个或多个 Go 源文件中实现。这些 Go 源文件可以从标准库或第三方库导入 Go 包。当我们在本章的*实现纯 cog*部分中实现时间前 cog 时，我们将看到一个例子。

COG 还可能具有与之相关联的 CSS 样式表和 JavaScript 代码，允许`cog`开发人员/维护人员根据需要利用预构建的 JavaScript 解决方案，而不是直接移植 JavaScript 小部件。这使得 cogs 可以与现有的 JavaScript 解决方案进行互操作，并防止出现开发人员不必重新发明众所周知的轮子就能节省宝贵时间的情况。例如，Pikaday（[https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday) 是一个成熟的日历日期选择器 JavaScript 小部件。在本章的*实现混合 cogs*部分中，我们将学习如何实现利用 Pikaday JavaScript 小部件提供的功能的日期选择器`cog`。使用日期选择器`cog`的 Go 开发人员不需要任何 JavaScript 知识，只需要具备 Go 知识就可以使用它。

每个`cog`都有一个**虚拟 DOM 树**，这是其实际 DOM 树的内存表示。操纵 cog 的内存中虚拟 DOM 树比操纵实际的 DOM 树本身要高效得多。*图 9.1*是一个维恩图，描绘了 cog 的虚拟 DOM 树、两棵树之间的差异以及实际的 DOM 树：

![](Images/53478aff-9055-402c-8a14-4400ab176f58.png)

图 9.1：描述虚拟 DOM、差异和实际 DOM 的维恩图

随着 cog 属性的更改（*道具*），cog 的渲染引擎将利用其虚拟 DOM 树来确定更改，然后将更改与实际 DOM 树协调。这使得`cog`可以*反应*，这意味着`cog`可以在其道具更新时自动重新呈现自身。以这种方式，COG 降低了更新用户界面时所涉及的复杂性。

# 用户体验工具包

UX 工具包提供了在`cog`包中实现 cogs 的功能，可使用以下`go get`命令安装：

```go
$ go get -u github.com/uxtoolkit/cog
```

所有 COG 必须实现`Cog`接口：

```go
type Cog interface {
  Render() error
  Start() error
}
```

`Render`方法负责在网页上呈现`cog`。如果渲染过程中出现任何错误，该方法将返回一个`error`对象。

`Start`方法负责激活`cog`。如果`cog`无法启动，该方法将返回一个`error`对象。

`cog`包包含两个重要的导出变量，`ReactivityEnabled`和`VDOMEnabled`。这两个导出变量的类型均为`bool`，默认情况下，它们都设置为`true`。

当变量`ReactivityEnabled`设置为`true`时，COG 会随着道具的更改而重新呈现。如果`ReactivityEnabled`设置为`false`，则必须显式调用 cog 的`Render`方法来重新渲染 cog。

当变量`VDOMEnabled`设置为`true`时，将利用 cog 的虚拟 DOM 树呈现 cog。如果`VDOMEnabled`设置为`false`，则`cog`将通过替换内部 HTML 操作使用实际的 DOM 树进行渲染。这可能是一个昂贵的操作，可以通过利用 cog 的虚拟 DOM 树来避免。

`UXCog`类型实现`Cog`接口的`Render`方法。以下是`UXCog struct`的外观：

```go
type UXCog struct {
  Cog
  cogType reflect.Type
  cogPrefixName string
  cogPackagePath string
  cogTemplatePath string
  templateSet *isokit.TemplateSet
  Props map[string]interface{}
  element *dom.Element
  id string
  hasBeenRendered bool
  parseTree *reconcile.ParseTree
  cleanupFunc func()
}
```

`UXCog`类型提供使齿轮工作的基本功能。这意味着为了实现我们自己的 COG，我们必须在我们创建的所有 COG 的类型定义中嵌入[T1]类型。我们特别感兴趣的是`UXCog`类型的以下方法（为简洁起见，仅提供方法签名）：

```go
func (u *UXCog) ID() string

func (u *UXCog) SetID(id string) 

func (u *UXCog) CogInit(ts *isokit.TemplateSet)

func (u *UXCog) SetCogType(cogType reflect.Type)

func (u *UXCog) SetProp(key string, value interface{})

func (u *UXCog) Render() error
```

`ID`方法是一个 getter 方法，它返回 DOM 中 cog 的`div`容器的 ID。cog 的`div`容器称为其**安装点**。

`SetID`方法是一种 setter 方法，用于在 DOM 中设置 cog 的`div`容器的 ID。

`CogInit`方法用于将`cog`与应用程序的`TemplateSet`对象关联。这种方法有两个重要目的。首先，该方法用于在服务器端注册一个`cog`，使得给定`cog`的所有模板都包含在`isokit`内置的静态资产捆绑系统生成的模板捆绑中。其次，在客户端调用 cog 的`CogInit`方法提供了对客户端应用程序`TemplateSet`对象的`cog`访问，允许`cog`在网页上呈现自己。

`SetCogType`方法允许我们通过对新实例化的`cog`执行运行时反射来动态设置 cog 的类型。这提供了 isokit 的静态资产绑定系统所需的钩子，用于绑定与给定`cog`关联的模板文件、CSS 源文件和 JavaScript 源文件。

`SetProp`方法用于在 cog 的`Props`映射中设置一个键值对，类型为`map[string]interface{}`。地图的`key`代表道具的名称，值代表道具的值。

`Render`方法负责将`cog`呈现给 DOM。如果在`cog`被渲染后对其进行了更改（其属性值被更新），则`cog`将被重新渲染。

您可以访问 UX 工具包网站了解有关 cogs 的更多信息：[http://uxtoolkit.io](http://uxtoolkit.io) 。

现在我们已经熟悉了`UXCog`型，是时候检查`cog`的解剖结构了。

# 齿轮的解剖

对于 IGWEB 项目，我们将在`$IGWEB_APP_ROOT/shared/cogs`文件夹中创建 COG。在阅读本节时，您可以浏览一下[T1]之前的版本，其实现可以在[T2]文件夹中找到，以查看本文所述概念的具体实现

仅出于说明目的，我们将引导您完成创建名为`widget`的简单`cog`的过程。

包含在`widget`文件夹中的小部件`cog`的项目结构按以下方式组织：

```go
  ⁃ widget
    ⁃ widget.go
    ⁃ templates
    ⁃ widget.tmpl
```

`widget.go`源文件将包含小部件`cog`的实现。

`templates`文件夹包含用于实现`cog`的模板源文件。如果要在网页上呈现`cog`，则必须至少存在一个模板源文件。模板源文件的名称必须与`cog`的包名称匹配。例如，对于`cog`包`widget`，模板源文件的名称必须为`widget.tmpl`。

COG 在命名包名和源文件时遵循*约定而非*策略。由于我们选择了名称`widget`，我们必须在`widget.go`源文件中声明一个名为`widget`的 Go 包：

```go
package widget
```

所有 COG 需要在其进口分组中包括`errors`包、`reflect`包和`cog`包：

```go
import (
  "errors"
  "reflect"
  "github.com/uxtoolkit/cog"
)
```

我们必须声明一个名为`cogType`的未导出的包范围变量：

```go
var cogType reflect.Type
```

此变量表示 cog 的类型。我们调用`reflect`包中的`TypeOf`函数，传入新创建的`cog`实例，在`cog`包的`init`函数中动态设置 cog 的类型：

```go
func init() {
  cogType = reflect.TypeOf(Widget{})
}
```

这为 isokit 的静态捆绑系统提供了一个钩子，让它知道在哪里寻找，以获取实现`cog`功能所需的静态资产。

`cog`实现了一个特定的类型。对于小部件，我们实现了`Widget`类型。以下是`Widget struct`：

```go
type Widget struct {
  cog.UXCog
}
```

为了实现`cog`，我们必须嵌入`cog.UXCog`类型，以便从`cog.UxCog`类型中获得所需的所有功能。

`struct`可能包含实现`cog`所需的其他字段定义，具体取决于`cog`的用途。

每个`cog`实现都应该包含一个构造函数：

```go
func NewWidget() *Widget {
  w := &Widget{}
  w.SetCogType(cogType)
  return f
}
```

与任何典型的构造函数一样，其目的是创建 cog 的新实例`Widget`。

cog 的构造函数必须包含调用`SetCogType`方法的行（以粗体显示）。isokit 的自动静态资产捆绑系统将其用作挂钩，以捆绑 cog 所需的静态资产。

根据 cog 的实现，可以设置`Widget`类型的附加字段来初始化`cog`。

为了实现`Cog`接口的实现，所有 COG 必须实现`Start`方法：

```go
func (w *Widget) Start() error {

  var allRequiredConditionsHaveBeenMet bool = true
```

`Start`方法负责激活`cog`，包括将`cog`初始呈现到网页。`Start`方法返回`error`对象，如果`cog`启动失败，则返回`nil`值。

为了便于说明，我们定义了一个[T0]条件块，其中包含一个名为[T1]的布尔变量：

```go
  if allRequiredConditionsHaveBeenMet == false {
    return errors.New("Failed to meet all requirements, cog failed to start!")
  }
```

如果满足启动`cog`的所有条件，该变量将等于`true`。否则，它将等于`false`。如果是`false`，则返回一个新的`error`对象，表示`cog`无法启动，因为没有满足所有要求。

我们可以通过调用`SetProp`方法在 cog 的`Props`映射中设置键值对：

```go
  w.SetProp("foo", "bar")
```

在本例中，我们已将名为`foo`的道具设置为值`bar`。`Props`映射将自动用作数据对象，输入 cog 的模板。这意味着 cog 的模板可以访问`Props`地图中定义的所有道具。

按照惯例，cog 的模板源文件名必须命名为`widget.tmpl`，以匹配 cog 的包名`widget`，并且模板文件应位于 cog 文件夹`widget`中的`templates`文件夹中。

让我们快速查看一下 Type T0.源文件的外观：

```go
<p>Value of Foo is: {{.foo}}</p>
```

请注意，我们可以打印出模板中键为`foo`的道具的值。

让我们回到小部件 cog 的`Start`方法。我们称 cog 的`Render`方法在 web 浏览器中呈现`cog`：

```go
  err := w.Render()
  if err != nil {
    return err
  }
```

如果在渲染`cog`时遇到错误，`Render`方法返回`error`对象，否则返回值`nil`表示`cog`渲染成功。

如果`cog`渲染成功，cog 的`Start`方法返回`nil`值，表示`cog`已成功启动：

```go
return nil
```

为了将我们的`cog`呈现给真实的 DOM，我们需要一个地方将`cog`呈现给。容纳`cog`渲染内容的`div`容器称为其**装入点**。挂载点是在 DOM 中呈现[T4]的位置。为了在主页上呈现小部件`cog`，我们将向主页的内容模板添加以下标记：

```go
<div data-component="cog" id="widgetContainer"></div>
```

通过将`data-component`属性设置为`"cog"`，我们表示`div`元素将用作 cog 的挂载点，cog 的渲染内容将包含在此元素中。

在客户端应用程序中，小部件`cog`可以如下实例化：

```go
w := widget.NewWidget()
w.CogInit(env.TemplateSet)
w.SetID("widgetContainer")
w.Start()
w.SetProp("foo", "bar2")
```

我们创建一个新的`Widget`实例并将其分配给变量`w`。我们必须调用`cog`的`CogInit`方法将应用程序的`TemplateSet`对象与`cog`关联起来。`cog`使用`TemplateSet`以便获取呈现`cog`所需的相关模板。我们称 cog 的`SetID`方法，将`id`传递给`div`元素，作为 cog 的安装点。我们调用 cog 的`Start`方法来激活`cog`。由于`Start`方法调用 cog 的`Render`方法，cog 将在指定的装入点呈现，即 id 为`"widgetContainer"`的`div`元素。最后，当我们调用`SetProp`方法并将`"foo"`道具的值更改为`"bar2"`时，`cog`将自动重新渲染。

现在我们已经研究了一个 Ty0 T0 的基本解剖结构，让我们考虑如何使用虚拟 DOM 渲染 COG。

# 虚拟 DOM 树

每个`cog`实例都有一个与之关联的虚拟 DOM 树。这个虚拟 DOM 树是由 cog 的`div`容器的所有子级组成的解析树。

*图 9.2*是一个流程图，描述了将`cog`重新呈现（通过应用对账）到 DOM 的过程：

![](Images/d0aea435-af93-438d-9ce3-b88c23d6edd5.png)

图 9.2：绘制和重新绘制 cog 的流程图

当在 DOM 中首次呈现[T0]时，将执行替换内部 HTML 操作。替换 DOM 中元素的内部 HTML 内容的操作是一项昂贵的操作。因此，它不会在`cog`的后续渲染上执行。

对 cog 的`Render`方法的所有后续调用都将利用 cog 的虚拟 DOM 树。cog 的虚拟 DOM 树用于跟踪 cog 的当前虚拟 DOM 树和 cog 的新虚拟 DOM 树之间的更改。更新 cog 的 prop 值后，`cog`将有一个新的虚拟 DOM 树与当前的虚拟 DOM 树进行比较。

让我们考虑一个带有小部件 COG 的示例场景。调用小部件 cog 的`Start`方法将执行`cog`的初始渲染（因为 cog 的`Render`方法在`Start`方法中被调用）。`cog`将有一个虚拟 DOM 树，该树将是保存 cog 呈现内容的`div`容器的解析树。如果我们通过调用`cog`上的`SetProp`方法来更新`"foo"`道具（在 cog 的模板中呈现），那么`Render`方法将自动被调用，因为`cog`是被动的。在`cog`上执行后续渲染操作后，cog 的当前虚拟 DOM 树将与 cog 的新虚拟 DOM 树（更新 cog 道具后创建的虚拟 DOM 树）不同。

如果当前虚拟 DOM 树和新虚拟 DOM 树之间没有更改，则无需执行任何操作。但是，如果当前虚拟 DOM 树和新虚拟 DOM 树之间存在差异，那么我们必须将构成差异的更改应用于实际 DOM。应用这些变更的过程称为**对账**。执行对账可以避免执行昂贵的替换内部 HTML 操作。成功应用协调后，cog 的新虚拟 DOM 树将被视为 cog 的当前虚拟 DOM 树，为下一个渲染周期准备`cog`：

![](Images/f1b661e1-dbf9-40f0-a649-2349e36cf1c2.png)

图 9.3:cog 的现有虚拟 DOM 树（左）和 cog 的新虚拟 DOM 树（右）

*图 9.3*在左侧描绘了 cog 的现有虚拟 DOM 树，在右侧描绘了 cog 的新虚拟 DOM 树。在对两个虚拟 DOM 树（新的和现有的）执行`diff`操作后，确定最右边的`div`元素（包含`ul`元素）及其子元素已更改，并且协调操作将仅更新实际 DOM 中的`div`元素及其子元素。

# 齿轮的生命周期

*图 9.4*描述了一个`cog`的生命周期，它从服务器端开始，我们首先在服务器端注册`cog`。cog 的类型必须在服务器端注册，以便 cog 的关联模板以及其他静态资产可以自动绑定并提供给客户端应用程序：

![](Images/39a0e440-a9ed-406b-a79c-9aa495618c26.png)

图 9.4：cog 的生命周期

`cog`生命周期中的后续步骤在客户端进行。我们通过引入一个数据组件属性等于`"cog"`的`div`元素来声明`cog`的装入点，以指示`div`元素是`cog`的装入点。

下一步是通过调用`cog`的构造函数来创建`cog`的新实例。我们通过调用`cog`的`CogInit`方法初始化`cog`并传入客户端应用程序的`TemplateSet`对象。初始化`cog`还包括调用 cog 的`SetID`方法将挂载点关联到`cog`（以便`cog`知道渲染到哪里）。`Cog`初始化还包括在调用`Start`方法之前通过调用 cog 的`Props map`方法来设置道具。

请注意，在调用 cog 的`Start`方法之前调用 cog 的`SetProp`方法不会呈现`cog`。`cog`只有在`cog`通过调用其`Start`方法呈现到挂载点后，才会在调用其`SetProp`方法时重新呈现。

调用 Cog 的`Start`方法将激活`cog`并将 Cog 的内容呈现到指定的装入点。

对 cog 的`SetProp`方法的任何后续调用都将导致`cog`的重新呈现。

当用户导航到网站上的另一个页面时，`cog`所在的容器被移除，有效地破坏了`cog`。用户可以指定一个清理函数，该函数应该在销毁[T2]之前调用。这可以在 cog 销毁之前以负责任的方式释放资源。我们将在本章后面看到一个实现清理功能的示例。

# 实现纯齿轮

现在我们已经对 cogs 有了基本的了解，是时候在实践中实现一些 cogs 了。尽管 COG 在客户端运行，但需要注意的是，服务器端应用程序需要通过注册它们来确认它们的存在。出于这个原因，COG 的代码被战略性地放在`shared/cogs`文件夹中

纯齿轮仅在 Go 中实现。正如您将看到的，我们可以利用现有 Go 包的功能来实现 cogs。

在`igweb.go`源文件的 main 函数中，我们调用传入应用程序模板集的`initailizeCogs`函数：

```go
initializeCogs(env.TemplateSet)
```

`initializeCogs`函数负责初始化将在同构 Go web 应用程序中使用的所有 COG：

```go
func initializeCogs(ts *isokit.TemplateSet) {
  timeago.NewTimeAgo().CogInit(ts)
  liveclock.NewLiveClock().CogInit(ts)
  datepicker.NewDatePicker().CogInit(ts)
  carousel.NewCarousel().CogInit(ts)
  notify.NewNotify().CogInit(ts)
  isokit.BundleStaticAssets()
}
```

注意，`initializeCogs`函数只接受一个输入参数`ts`，即`TemplateSet`对象。我们调用 cog 的构造函数来创建`cog`的新实例，并立即调用`cog`的`CogInit`方法，将`TemplateSet`对象`ts`作为该方法的输入参数传入。这允许`cog`将其模板包括在应用程序的模板集中，以便后续生成的模板包将包括与`cog`关联的模板。

我们调用`BundleStaticAssets`方法来生成每个`cog`所需的静态资产（CSS 和 JavaScript 源文件）。将生成两个文件。第一个文件是`cogimports.css`，它将包含所有 COG 所需的 CSS 源代码，第二个文件是`cogimports.js`，它将包含所有 COG 所需的 JavaScript 源代码。

# 前段时间的齿轮

现在，我们已经看到了 COG 是如何在服务器端初始化的，现在是时候来看看制作`cog`的原因了。我们将首先制作一个非常简单的`cog`，一段时间前的`cog`，它以人类可以理解的格式显示时间。

是时候在 about 页面上重新访问 gopher bios 了。在[第 3 章](03.html)中的*自定义模板函数*部分*与 GopherJS*一起进入前端，我们学习了如何使用自定义模板函数以 Ruby 格式显示 gopher 的开始日期时间。

我们将更进一步，通过实现一个 time ago`cog`，以人类可以理解的格式显示开始日期时间。*图 9.5*以默认 Go 格式、Ruby 格式和人类可理解格式显示 Molly 的开始日期：

![](Images/2f766aa0-f732-486e-bb0f-b66f8b102f43.png)

图 9.5：描述时间间隔 cog 的插图，这是以人类可读格式显示时间的最后一行

Molly 于 2017 年 5 月 24 日加入了 IGWEB 团队，这是 6 个月前以人类可读的格式出现的（在撰写本文时）。

在`about_content.tmpl`模板源文件中，我们为之前的`cog`引入了一个`div`容器：

```go
<h1>About</h1>

<div id="gopherTeamContainer">
  {{range .Gophers}}

    <div class="gopherContainer">

      <div class="gopherImageContainer">
        <img height="270" src="{{.ImageURI}}">
      </div>

      <div class="gopherDetailsContainer">
          <div class="gopherName"><h3><b>{{.Name}}</b></h3></div>
          <div class="gopherTitle"><span>{{.Title}}</span></div> 
          <div class="gopherBiodata"><p>{{.Biodata}}</p></div>
          <div class="gopherStartTime">
            <p class="standardStartTime">{{.Name}} joined the IGWEB team on <span class="starttime">{{.StartTime}}.</p>
            <p class="rubyStartTime">That's <span class="starttime">{{.StartTime | rubyformat}}</span> in Ruby date format.</p>
            <div class="humanReadableGopherTime">That's
 <div id="Gopher-{{.Name}}" data-starttimeunix="{{.StartTime | unixformat}}" data-component="cog" class="humanReadableDate starttime"></div>
 in Human readable format.
 </div>
          </div>
      </div>
    </div>

  {{end}}
</div>
```

请注意，我们已经为名为`data-component`的属性分配了一个值`cog`。这表示该`div`容器将用作装入点，容纳`cog`的渲染内容。我们将容器的`id`属性设置为地鼠的名字，前缀为`"Gopher-"`。

稍后您将看到，当我们实例化一个`cog`时，我们必须为一个 cog 的`div`容器提供一个 ID，以便`cog`实例知道它的装入点是`cog`应该向其提供输出的位置。我们定义了另一个自定义数据属性`starttimeunix`，并将其设置为 Gopher 开始为 IGWEB 工作时的 Unix 时间戳值。

回想一下，该值是通过调用模板操作获得的，该操作将通过将`StartTime`属性管道化到自定义模板函数`unixformat`获得的值放入其中。

`unixformat`自定义模板函数是`shared/templatefuncs/funcs.go`源文件中定义的`UnixTime`函数的别名：

```go
func UnixTime(t time.Time) string {
  return strconv.FormatInt(t.Unix(), 10)
}
```

对于给定的`Time`实例，此函数将以 Unix 格式以`string`值的形式返回时间。

返回到`about_content.tmpl`源文件，注意提供给`div`容器的`humanReadableDate`CSS`className`。稍后，我们将使用此 CSS`className`获取 About 页面上的所有`timeago`cog`div`容器。

现在，我们已经看到了如何在大约页上声明 COG 的 Tyt0}容器，让我们来看看如何实现前一次的 Tyl T1。

前一次`cog`是一次纯粹的围棋`cog`。这意味着它只使用 Go 实现。Go 包`go-humanize`为我们提供了以人类可读格式显示时间所需的功能。我们将利用此软件包来实现时间之前的`cog`。以下是`go-humanize`包的 GitHub 页面的 URL:[https://github.com/dustin/go-humanize](https://github.com/dustin/go-humanize) 。

让我们检查一下`shared/cogs/timeago/timeago.go`源文件。我们首先将包名声明为`timeago`：

```go
package timeago
```

在我们的导入分组中，我们包括`github.com/uxtoolkit/cog`，该软件包为我们提供了实现`cog`的功能（以粗体显示）。我们将`go-humanize`分组包含在我们的导入分组中，并将其别名为`"humanize"`（粗体显示）：

```go
import (
  "errors"
  "reflect"
  "time"

 humanize "github.com/dustin/go-humanize"
  "github.com/uxtoolkit/cog"
)
```

所有 COG 必须声明一个名为`cogType`的未报告变量，其类型为`reflect.Type`：

```go
var cogType reflect.Type
```

在`init`函数中，我们通过对新创建的`TimeAgo`实例调用`reflect.TypeOf`函数返回的值来分配`cogType`变量：

```go
func init() {
  cogType = reflect.TypeOf(TimeAgo{})
}
```

我们实现的每个`cog`都需要初始化`cogType`变量。正确设置`cogType`允许静态资产绑定系统在 web 应用程序中考虑 cog 的静态资产依赖关系。`cogType`将用于收集实现`cog`功能所需的所有模板和静态资产。

以下是我们用来定义`TimeAgo cog`的`struct`：

```go
type TimeAgo struct {
  cog.UXCog
  timeInstance time.Time
}
```

请注意，我们在`struct`定义中嵌入了`ux.UXCog`。如前所述，`cog.UXCog`类型将为我们提供必要的功能，使我们能够呈现`cog`。除了嵌入`ux.UXCog`之外，我们还声明了一个名为`timeInstance`的未报告字段，类型为`time.Time`。这将包含我们将转换为人类可读格式的`time.Time`实例。

我们创建了一个名为`NewTimeAgo`的构造函数，它返回一个新的`TimeAgo cog`实例：

```go
func NewTimeAgo() *TimeAgo {
  t := &TimeAgo{}
  t.SetCogType(cogType)
  return t
}
```

我们这里的构造函数遵循与 Go 中实现的任何其他构造函数相同的模式。注意，我们将`cogType`传递给新创建的`TimeAgo`实例的`SetCogType`方法。这是必需的，以便 cog 的静态资产包含在由 isokit 的静态资产捆绑系统生成的静态资产捆绑中。

我们为`TimeAgo`结构的`timeInstance`字段创建一个名为`SetTime`的 setter 方法：

```go
func (t *TimeAgo) SetTime(timeInstance time.Time) {
  t.timeInstance = timeInstance
}
```

客户端应用程序将使用此 setter 方法设置`TimeAgo`cog 的时间。我们将使用`SetTime`方法设置 gopher 加入 IGWEB 团队的开始日期。

为了实现`Cog`接口，`cog`必须定义`Start`方法。`Start`方法是`cog`中的动作发生的地方。通过阅读`cog`的`Start`方法，您应该能够大致了解`cog`的功能。以下是`TimeAgo`cog 的`Start`方法：

```go
func (t *TimeAgo) Start() error {

  if t.timeInstance.IsZero() == true {
    return errors.New("The time instance value has not been set!")
  }

  t.SetProp("timeAgoValue", humanize.Time(t.timeInstance))

  err := t.Render()
  if err != nil {
    return err
  }

  return nil
}
```

`Start`方法返回一个错误对象，通知调用方`cog`是否正确启动。在执行任何活动之前，检查是否设置了`timeInstance`值。我们使用一个`if`条件语句来检查`timeInstance`值是否为零值，表明它尚未设置。如果出现这种情况，该方法将返回一个新创建的`error`对象，指示尚未设置时间值。如果设置了`timeInstance`值，我们继续前进。

我们调用 cog 的`SetProp`方法，用人类可以理解的时间值设置`timeAgoValue`属性。我们通过从`go-humanize`包（别名为`humanize`）调用`Time`函数并将 cog 的`timeInstance`值传递给它，从而获得人类可以理解的时间值。

我们调用 cog 的`Render`方法来呈现`cog`。如果在尝试呈现`cog`时出错，`Start`方法将返回`error`对象。否则，将返回一个值`nil`，表示启动`cog`时没有错误。

此时，我们已经实现了[T0]cog 的 Go 部分。为了使人类可读的时间出现在网页上，我们必须实现 cog 的模板。

`timeago.tmpl`文件（位于`shared/cogs/timeago/templates`目录中）是一个简单的单行模板。我们声明以下`span`元素，并且我们有一个模板操作来呈现`timeAgoValue`属性：

```go
<span class="timeagoSpan">{{.timeAgoValue}}</span>
```

按照惯例，我们必须将在`cog`包的`templates`文件夹中找到的`cog`的主模板命名为与 cog 包同名。例如，对于`timeago`包，`cog`的主模板将是`timeago.tmpl`。您可以自由定义和使用任何自定义模板函数，该函数已与`cog`模板一起注册到应用程序的模板集。您还可以自由创建任意数量的子模板，这些子模板将由 cog 的主模板调用。

现在我们有了`TimeAgo`cog 的模板，我们就有了在 About 页面上实例化`cog`所需的一切。

让我们检查一下`client/handlers/about.go`源文件中的`InitializeAboutPage`函数：

```go
func InitializeAboutPage(env *common.Env) {
  humanReadableDivs := env.Document.GetElementsByClassName("humanReadableDate")
  for _, div := range humanReadableDivs {
    unixTimestamp, err := strconv.ParseInt(div.GetAttribute("data-starttimeunix"), 10, 64)
    if err != nil {
      log.Println("Encountered error when attempting to parse int64 from string:", err)
    }
    t := time.Unix(unixTimestamp, 0)
 humanTime := timeago.NewTimeAgo()
 humanTime.CogInit(env.TemplateSet)
 humanTime.SetID(div.ID())
 humanTime.SetTime(t)
 err = humanTime.Start()
    if err != nil {
      println("Encountered the following error when attempting to start the timeago cog: ", err)
    }
  }
}
```

由于 About 页面上列出了三个 gopher，因此页面上将总共运行三个`TimeAgo`cog 实例。我们使用`env.Document`对象上的`GetElementByClassName`方法收集 COG 的`div`容器，并提供一个类名称`humanReadableDate`。然后我们循环遍历每个`div`元素，这就是实例化`cog`的所有操作发生的地方。

首先，我们从`div`容器中包含的自定义数据属性中提取 Unix 时间戳值。回想一下，我们已经使用自定义模板函数`unixformat`用地鼠开始时间的 Unix 时间戳填充了`starttimeunix`自定义数据属性。

然后，我们使用`time`包中可用的`Unix`函数创建一个新的`time.Time`对象，并提供我们从`div`容器的自定义数据属性中提取的`unixTimestamp`。实例化和设置`TimeAgo`cog 的代码以粗体显示。我们首先通过调用构造函数`NewTimeAgo`并将其分配给`humanTime`变量来实例化一个新的`TimeAgo`cog。

然后我们在`humanTime`对象上调用`CogInit`方法，并为其提供`env.TemplateSet`对象。我们调用`SetID`方法注册`div`容器的`id`属性，将其与`cog`实例关联。然后我们调用`TimeAgo`cog 上的`SetTime`方法，传入`time.Time`对象`t`，该对象是我们使用从`div`容器中提取的`unixTimestamp`创建的。

我们现在已经准备好了通过调用`Start`方法启动`cog`的一切。我们将`Start`方法返回的`error`对象分配给`err`。如果`err`不等于`nil`，则表示启动`cog`时发生错误，在这种情况下，我们会在 web 控制台中打印出一条有意义的消息。如果没有错误，`cog`将被呈现到网页上。*图 9.6*以人类可读的格式显示了 Molly 开始时间的屏幕截图。

![](Images/15fecc9b-375a-4b05-89b6-9892c784b211.png)

图 9.6：运行中的时间间隔

# 活钟齿轮

当我们在时间`cog`之前调用`Start`方法时，时间使用虚拟 DOM 呈现在网页上，而不是进行替换内部 HTML 操作。由于时间在`cog`之前，只更新一次时间，调用`cog`的`Start`方法，很难理解 cog 的虚拟 DOM 在运行。

在本例中，我们将构建一个实时时钟`Cog`，它能够显示世界上任何地方的当前时间。由于我们将以秒为单位显示时间，因此我们将每秒执行一次`SetProp`操作，以重新渲染实时时钟`Cog`。

*图 9.7*为实时时钟示意图：

![](Images/aa3d10d9-cfda-475d-952d-b54caf49810b.png)

图 9.7：描绘实时时钟 cog 的图示

我们将渲染四个地方的当前时间：您当前所在的地方、金奈、新加坡和夏威夷。在`shared/templates/index_content.tmpl`模板源文件中，我们声明了四个`div`容器，作为我们将实例化的四个实时时钟齿轮的安装点：

```go
 <div data-component="cog" id="myLiveClock" class="liveclockTime"></div>
 <div data-component="cog" id="chennaiLiveClock" class="liveclockTime"></div>
 <div data-component="cog" id="singaporeLiveClock" class="liveclockTime"></div>
 <div data-component="cog" id="hawaiiLiveClock" class="liveclockTime"></div>
```

请再次注意，我们通过声明包含属性`"data-component"`的`div`容器并将其值设置为`"cog"`，定义了实时时钟的挂载点。我们为所有四个`cog`容器分配唯一 ID。我们在`div`容器中声明的类名`liveclockTime`用于样式设计。

现在我们已经为四个活时钟 COGS 设置了安装点，让我们来看看如何实现实时时钟 To0T0。

实时时钟`Cog`的实现可以在`shared/cogs/liveclock`文件夹中的`liveclock.go`源文件中找到。

我们为 cog 的包名声明名称`liveclock`：

```go
package liveclock
```

请注意，在我们的进口分组中，我们包含了`github.com/uxtoolkit/cog`包：

```go
import (
  "errors"
  "reflect"
  "time"
 "github.com/uxtoolkit/cog"
)
```

我们定义`cogType`未报告的包变量：

```go
var cogType reflect.Type
```

在`init`函数中，我们通过对新创建的`LiveClock`实例调用`reflect.TypeOf`函数返回的值来分配`cogType`变量：

```go
func init() {
  cogType = reflect.TypeOf(LiveClock{})
}
```

这是实施`cog`的必要步骤。

此时，我们已经确定，声明和初始化`cog`的`cogType`是实现`cog`必须执行的基线要求的一部分。

以下是`LiveClock`cog 的结构：

```go
type LiveClock struct {
  cog.UXCog
  ticker *time.Ticker
}
```

我们在 cog 的结构定义中嵌入了[T0]类型。我们引入一个`ticker`字段，它是指向`time.Ticker`的指针。我们将使用这个`ticker`为实时时钟每秒滴答作响。

以下是`LiveClock`cog 的构造函数：

```go
func NewLiveClock() *LiveClock {
  liveClock := &LiveClock{}
 liveClock.SetCogType(cogType)
  liveClock.SetCleanupFunc(liveClock.Cleanup)
  return liveClock
}
```

`NewLiveClock`函数作为实时时钟`cog`的构造函数。我们声明`liveClock`变量并将其初始化为一个新的`LiveClock`实例。我们调用`liveClock`对象的`SetCogType`方法并传递`cogType`。回想一下，这是一个必需的步骤（以粗体显示），必须出现在 cog 的构造函数中。

然后我们调用`liveClock`对象的`SetCleanupFunc`方法，并为其提供一个清理函数`liveClock.Cleanup`。`SetCleanUp`方法包含在`cog.UXCog`类型中。它允许我们指定在从 DOM 中删除[T5]之前应该调用的清理函数。最后，我们返回`LiveClock cog`的新实例。

让我们检查一下`Cleanup`函数：

```go
func (lc *LiveClock) Cleanup() {
  lc.ticker.Stop()
}
```

这个函数非常简单。我们只需在 cog 的`ticker`对象上调用`Stop`方法来停止`ticker`。

以下是 cog 的`Start`方法，其中`ticker`将启动：

```go
func (lc *LiveClock) Start() error {
```

我们首先声明时间布局常量`layout`，并将其设置为`RFC1123Z`时间格式。我们声明一个`location`变量，一个指向`time.Location`类型的指针：

```go
  const layout = time.RFC1123
  var location *time.Location
```

在启动`LiveClock`cog 之前，`cog`的用户必须设置两个重要道具`"timezoneName"`和`"timezoneOffset"`：

```go
  if lc.Props["timezoneName"] != nil && lc.Props["timezoneOffset"] != nil {
    location = time.FixedZone(lc.Props["timezoneName"].(string), lc.Props["timezoneOffset"].(int))
  } else {
    return errors.New("The timezoneName and timezoneOffset props need to be set!")
  }
```

这些值用于初始化位置变量。如果没有提供这些道具中的任何一种，将返回一个`error`。

如果两个道具都存在，我们继续将实时时钟`cog`的`ticker`属性分配给一个新创建的`time.Ticker`实例，该实例将每秒打勾：

```go
lc.ticker = time.NewTicker(time.Millisecond * 1000)
```

当一个值到达时，我们在股票代码的通道上`range`每一秒迭代一次，我们设置`currentTime`属性，为它提供一个格式化的时间值（以粗体显示）：

```go
  go func() {
    for t := range lc.ticker.C {
 lc.SetProp("currentTime", t.In(location).Format(layout))
    }
  }()
```

请注意，我们使用位置和时间布局来设置时间格式。一旦`cog`被呈现，每秒对`SetProp`的调用将自动调用`Render`方法重新呈现`cog`。

我们调用 cog 的`Render`方法将`cog`呈现到网页：

```go
  err := lc.Render()
  if err != nil {
    return err
  }
```

在方法的最后一行中，我们返回一个`nil`值，表示没有发生错误：

```go
 return nil
```

我们已经在`liveclock.tmpl`源文件中为`cog`定义了模板：

```go
<p>{{.timeLabel}}: {{.currentTime}}</p>
```

我们打印出时间标签和当前时间。`timeLabel`道具用于向`cog`提供时间标签，并且将是我们想要知道当前时间的地点的名称。

现在我们已经了解了制作实时时钟`cog`的过程，以及它如何显示时间，让我们继续在主页上添加一些实时时钟齿轮。

以下是源文件`index.go`的`InitializeIndexPage`函数中的代码部分，我们在其中实例化了本地时区的实时时钟 cog：

```go
  // Localtime Live Clock Cog
  localZonename, localOffset := time.Now().In(time.Local).Zone()
  lc := liveclock.NewLiveClock()
  lc.CogInit(env.TemplateSet)
  lc.SetID("myLiveClock")
  lc.SetProp("timeLabel", "Local Time")
  lc.SetProp("timezoneName", localZonename)
  lc.SetProp("timezoneOffset", localOffset)
  err = lc.Start()
  if err != nil {
    println("Encountered the following error when attempting to start the local liveclock cog: ", err)
  }
```

为了实例化本地时间的 cog，我们首先获取本地时区名称和本地时区偏移量。然后我们创建一个名为`lc`的`LiveClock cog`的新实例。我们调用`CogInit`方法来初始化 cog。我们调用`SetID`方法来注册 cog 安装点的`id`，即`cog`将输出到的`div`容器。我们调用`SetProp`方法来设置`"timeLabel"`、`"timezoneName"`和`"timezoneOffset"`道具。最后，我们调用`Start`方法来启动`LiveClock`cog。像往常一样，我们检查`cog`是否正确启动，如果没有，我们在 web 控制台中打印`error`对象。

以类似的方式，我们为金奈、新加坡和夏威夷实例化了`LiveClock`齿轮，与我们对当地时间的实例化方式基本相同，除了一件事。对于其他地方，我们明确提供每个地方的时区名称和 GMT 时区偏移：

```go
  // Chennai Live Clock Cog
  chennai := liveclock.NewLiveClock()
  chennai.CogInit(env.TemplateSet)
  chennai.SetID("chennaiLiveClock")
  chennai.SetProp("timeLabel", "Chennai")
  chennai.SetProp("timezoneName", "IST")
  chennai.SetProp("timezoneOffset", int(+5.5*3600))
  err = chennai.Start()
  if err != nil {
    println("Encountered the following error when attempting to start the chennai liveclock cog: ", err)
  }

  // Singapore Live Clock Cog
  singapore := liveclock.NewLiveClock()
  singapore.CogInit(env.TemplateSet)
  singapore.SetID("singaporeLiveClock")
  singapore.SetProp("timeLabel", "Singapore")
  singapore.SetProp("timezoneName", "SST")
  singapore.SetProp("timezoneOffset", int(+8.0*3600))
  err = singapore.Start()
  if err != nil {
    println("Encountered the following error when attempting to start the singapore liveclock cog: ", err)
  }

  // Hawaii Live Clock Cog
  hawaii := liveclock.NewLiveClock()
  hawaii.CogInit(env.TemplateSet)
  hawaii.SetID("hawaiiLiveClock")
  hawaii.SetProp("timeLabel", "Hawaii")
  hawaii.SetProp("timezoneName", "HDT")
  hawaii.SetProp("timezoneOffset", int(-10.0*3600))
  err = hawaii.Start()
  if err != nil {
    println("Encountered the following error when attempting to start the hawaii liveclock cog: ", err)
  }
```

现在，我们将能够看到活动的时钟齿轮。*图 9.8*是主页上显示的实景木屐的屏幕截图。

![](Images/7e166fd4-a7db-4b49-8d19-07f012ac9d5c.png)

图 9.8：运行中的实时时钟 cog

每过一秒，每个实时时钟都会更新为新的时间值。虚拟 DOM 启动并只渲染更改内容的差异，每秒高效地重新渲染实时时钟。

到目前为止，我们已经实现的前两个 COG 是完全在 Go 中实现的纯 COG。如果我们想利用现有的 JavaScript 解决方案来提供特定的功能，该怎么办？这种情况需要实现一个混合 cog，一个用 Go 和 JavaScript 实现的[T0]。

# 实现混合 cogs

JavaScript 已经存在了二十多年。在这段时间内，使用该语言创建了许多健壮的、生产就绪的解决方案。同构 Go 不能存在于它自己的岛上，我们必须承认，JavaScript 生态系统中有许多有用的现成解决方案。在许多场景中，我们可以通过创建利用现有 JavaScript 解决方案的解决方案来节省大量时间和精力，而不是以纯粹的方式重新实现整个解决方案。

混合 COG 是使用 Go 和 JavaScript 实现的。混合 cogs 的主要目的是利用现有 JavaScript 解决方案中的功能，并将该功能公开为一个`cog`。这意味着`cog`实现者需要同时了解 Go 和 JavaScript 才能实现混合 COG。记住，混合 cogs 的用户只需要知道 Go，因为 JavaScript 的使用是`cog`的内部实现细节。这使得可能不熟悉 JavaScript 的 Go 开发人员可以随时使用 COG。

# 日期选择器齿轮

让我们考虑一个场景，保证实现混合式 To0T0。Molly，IGWEB 事实上的产品经理，想出了一个杀手锏来提供更好的客户支持。她向技术团队提出的功能要求是允许网站用户在联系人表单上提供可选的优先日期，用户可以通过该日期从 IGWEB 团队的地鼠那里得到回复

Molly 发现了一个独立的日期选择器小部件，它是用香草 JavaScript（无框架/库依赖项）实现的，名为 Pikaday:[T0]https://github.com/dbushell/Pikaday 。

Pikaday 是 JavaScript 日期选择器小部件，它突出显示了本节开头介绍的事实。JavaScript 并没有消失，已经有很多有用的解决方案使用它。这意味着，如果有必要，我们必须能够利用现有的 JavaScript 解决方案。Pikaday 日期选取器是一个特殊的用例，在这个用例中，利用这个现有的 JavaScript 日期选取器小部件比实现一个纯`cog`的小部件更为有利：

![](Images/72dbbc90-5aa2-4242-a10a-c8bb83c6cfb7.png)

图 9.9：描述时间敏感日期输入字段和日历日期选择器小部件的线框设计

*图 9.9*是一个线框设计，描绘了带有时间敏感输入字段的联系人表单，点击该字段将显示日历日期选择器。让我们看看如何通过实现日期选择器 cog 来满足 Molly 的请求，这是一个混合 cog，由 Go 和 JavaScript 制成

我们首先将 Pikaday、日期选择器小部件所需的 JavaScript 和 CSS 源文件分别放在 cog 的`static`文件夹中的`js`和`css`文件夹中。

在`shared/templates/partials/contactform_partial.tmpl`源文件中，我们声明日期选择器 cog 的装入点（以粗体显示）：

```go
    <fieldset class="pure-control-group">
      <div data-component="cog" id="sensitivityDate"></div>
    </fieldset>
```

`div`容器满足所有`cog`悬置点的两个基本要求：我们设置了`"data-component"`属性，值为`"cog"`，我们为`cog`容器指定了`id`为`"sensitivityDate"`。

让我们逐节检查`shared/cogs/datepicker/datepicker.go`源文件中定义的日期选择器 cog 的实现。首先，我们首先声明包名：

```go
package datepicker
```

以下是 cog 的导入分组：

```go
import (
  "errors"
  "reflect"
  "time"

  "github.com/gopherjs/gopherjs/js"
  "github.com/uxtoolkit/cog"
)
```

请注意，我们在导入分组中包含了`gopherjs`包（以粗体显示）。我们需要`gopherjs`的功能来查询 DOM。

在我们声明了`cogType`之后，我们立即将`JS`变量初始化为`js.Global`：

```go
var cogType reflect.Type
var JS = js.Global
```

您可能还记得，这为我们节省了一点打字时间。我们可以直接将`js.Global`称为`JS`。

从 Pikaday 项目网页，[https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday) ，我们可以学习日期选择器小部件接受的所有输入参数。输入参数作为单个 JavaScript 对象提供。日期选择器`cog`将公开这些输入参数的子集，仅足以满足 Molly 的特征请求。我们创建一个名为`DatePickerParams`的`struct`，作为日期选择器小部件的输入参数：

```go
type DatePickerParams struct {
  *js.Object
  Field *js.Object `js:"field"`
  FirstDay int `js:"firstDay"`
  MinDate *js.Object `js:"minDate"`
  MaxDate *js.Object `js:"maxDate"`
  YearRange []int `js:"yearRange"`
}
```

我们嵌入了`*js.Object`来表示这是一个 JavaScript 对象。然后，我们为 JavaScript 输入对象的各个属性声明`struct`的各个 Go 字段。例如，名为`Field`的字段用于`field`属性。我们为每个字段提供的`"js"``struct`标记允许 GopherJS 将`struct`及其字段从指定的 Go 名称转换为等效的 JavaScript 名称。正如我们声明了名为 field 的字段一样，我们还声明了`FirstDay`（`firstDay`）、`MinDate`（`minDate`）、`MaxDate`（`maxDate`）和`YearRange`（`yearRange`的字段。

阅读 Pikaday 文档，[T0]https://github.com/dbushell/Pikaday ，我们可以了解这些输入参数的用途：

*   `Field`-用于将日期选择器绑定到表单字段。
*   `FirstDay`-用于指定一周的第一天。（周日 0，周一 1 等）。
*   `MinDate`-可在日期选择器小部件中选择的最早日期。
*   `MaxDate`-可在日期选择器小部件中选择的最新日期。
*   `YearRange`-要显示的年份范围。

现在我们已经定义了日期选择器的输入参数结构`DatePickerParams`，现在是实现日期选择器`cog`的时候了。我们首先声明[T2]结构：

```go
type DatePicker struct {
  cog.UXCog
  picker *js.Object
}
```

像往常一样，我们嵌入了`cog.UXCog`以提供我们所需的所有 UXCog 功能。我们还声明了一个字段`picker`，它是指向`js.Object`的指针。`picker`属性将用于引用 Pikaday 日期选择器 JavaScript 对象。

然后，我们为日期选择器`cog`实现一个名为`NewDatePicker`的构造函数：

```go
func NewDatePicker() *DatePicker {
  d := &DatePicker{}
  d.SetCogType(cogType)
  return d
}
```

现在，cog 构造函数对您来说应该很熟悉了。它的职责是返回一个`DatePicker`的新实例并设置 cog 的`cogType`。

现在我们的构造函数已经就位，是时候检查日期选择器 cog 的`Start`方法了：

```go
func (d *DatePicker) Start() error {

  if d.Props["datepickerInputID"] == nil {
    return errors.New("Warning: The datePickerInputID prop need to be set!")
  }

  err := d.Render()
  if err != nil {
    return err
  }
```

我们首先检查`"datepickerInputID"`道具是否已设置。这是输入字段元素的`id`，将用作`DatePickerParams``struct`中的`Field`值。这是一个硬要求，在启动`cog`之前，该道具必须由调用者设置。未能设置此道具将导致错误。

如果设置了`"datepickerInputID"`道具，我们调用 cog 的`Render`方法来渲染 cog。这将呈现日期选择器 JavaScript 小部件对象所依赖的输入字段的 HTML 标记。

然后，我们继续声明并实例化，`params`，输入参数 JavaScript 对象，该对象将发送到日期选择器 JavaScript 小部件：

```go
params := &DatePickerParams{Object: js.Global.Get("Object").New()}
```

日期选择器输入参数对象`params`是一个 JavaScript 对象。Pikaday JavaScript 对象将使用`params`对象进行初始配置。

我们使用 cog 的`Props`属性来确定 cog 属性的范围。对于每个迭代，我们获取属性的名称（`propName`）和属性的值（`propValue`：

```go
 for propName, propValue := range d.Props {
```

我们声明的[T0]块对于可读性非常重要：

```go
 switch propName {

    case "datepickerInputID":
      inputFieldID := propValue.(string)
      dateInputField := JS.Get("document").Call("getElementById", inputFieldID)
      params.Field = dateInputField

    case "datepickerLabel":
      // Do nothing

    case "datepickerMinDate":
      datepickerMinDate := propValue.(time.Time)
      minDateUnix := datepickerMinDate.Unix()
      params.MinDate = JS.Get("Date").New(minDateUnix * 1000)

    case "datepickerMaxDate":
      datepickerMaxDate := propValue.(time.Time)
      maxDateUnix := datepickerMaxDate.Unix()
      params.MaxDate = JS.Get("Date").New(maxDateUnix * 1000)

    case "datepickerYearRange":
      yearRange := propValue.([]int)
      params.YearRange = yearRange

    default:
      println("Warning: Unknown prop name provided: ", propName)
    }
  }
```

`switch`块中的每个`case`语句都告诉我们日期选择器`cog`接受的所有属性作为输入参数，这些参数将传递给 Pikaday JavaScript 小部件。如果无法识别道具名称，我们将在 web 控制台中打印一条警告，指出道具未知。

第一个案例，处理`"datepickerInputID"`道具。它将用于指定激活 Pikaday 小部件的输入元素的`id`。在这个`case`中，我们通过调用`document`对象上的`getElementById`方法并将`inputFieldID`传递给该方法来获取输入元素字段。我们将 input`params`属性`Field`设置为从`getElementById`方法调用获得的 input field 元素。

第二个案例处理`"datepickerLabel"`道具。`"datepickerLabel"`道具的值将在 cog 的模板源文件中使用。因此，不需要处理这一特殊情况。

第三个案例处理`"datepickerMinDate"`道具。它将用于获取 Pikaday 小部件应显示的最小日期。我们将调用方提供的`type time.Time`的`"datepickerMinDate"`值转换为其 Unix 时间戳表示形式。然后，我们使用 Unix 时间戳创建一个新的 JavaScript`date`对象，该对象适用于`minDate`输入参数。

第四个案例处理`"datepickerMaxDate"`道具。它将用于获取日期选择器小部件应显示的最大日期。我们在这里遵循相同的策略，就像我们在`minDate`参数中所做的一样。

第五个案例处理`"datepickerYearRange"`道具。它将用于指定显示的日历将覆盖的年份范围。年份范围是一个切片，我们使用 prop 的值填充输入参数对象的`YearRange`属性。

如前所述，`default``case`处理调用方提供未知道具名称的场景。如果我们到达`default``case`，我们将在 web 控制台中打印一条警告消息。

现在我们可以实例化 Pikaday 小部件，并向其提供输入参数 obect，`params`，如下所示：

```go
d.picker = JS.Get("Pikaday").New(params)
```

最后，通过返回一个`nil`值，我们表明启动 cog 时没有错误：

```go
return nil
```

现在我们已经实现了日期选择器 COG，让我们来看看在损坏的 To0t0 源文件中定义的 COG 的主要模板，看起来是这样的：

```go
 <label class="datepickerLabel" for="datepicker">{{.datepickerLabel}}</label>
 <input class="datepickerInput" type="text" id="{{.datepickerInputID}}" name="{{.datepickerInputID}}">
```

我们声明一个`label`元素，以使用 prop`"datepickerLabel"`显示日期选择器 cog 的标签。我们声明一个`input`元素，它将作为输入元素字段，与 Pikaday 小部件一起使用。我们使用`"datepickerInputID"`属性指定输入元素字段的`id`属性。

现在我们已经实现了日期选择器 cog，是时候开始使用它了。我们在`InitializeContactPage`函数中实例化`cog`，在`client/handlers/contact.go`源文件中找到：

```go
  byDate := datepicker.NewDatePicker()
  byDate.CogInit(env.TemplateSet)
  byDate.SetID("sensitivityDate")
  byDate.SetProp("datepickerLabel", "Time Sensitivity Date:")
  byDate.SetProp("datepickerInputID", "byDateInput")
  byDate.SetProp("datepickerMinDate", time.Now())
  byDate.SetProp("datepickerMaxDate", time.Date(2027, 12, 31, 23, 59, 0, 0, time.UTC))
  err := byDate.Start()
  if err != nil {
    println("Encountered the following error when attempting to start the datepicker cog: ", err)
  }
```

首先，我们创建一个新的`DatePicker cog`实例。然后我们调用 cog 的`CogInit`方法来注册应用程序的模板集。我们调用`SetID`方法来设置 cog 的安装点。我们调用 cog 的`SetProp`方法来设置`datePickerLabel`、`datepickerInputID`、`datepickerMinDate`和`datepickerMaxDate`道具。我们称之为 cog 的`Start`方法来激活它。如果启动`cog`时出现任何错误，我们会将错误消息打印到 web 控制台。

这就是全部！我们可以使用 date picker hybrid`cog`利用 Pikaday 小部件所需的功能。这种方法的优点是，使用日期选择器`cog`的 Go 开发人员不需要了解 Pikaday 小部件的内部工作（JavaScript）就可以使用它。相反，他们可以使用日期选择器`cog`在 Go 范围内向他们公开的功能。

*图 9.10*显示了日期选择器`cog`的屏幕截图：

![](Images/8e47b957-a807-4bb5-8ccf-4950f4ddd950.png)

图 9.10：运行中的日历日期选择器小部件

即使 cog 用户没有提供任何道具，除了所需的`datepickerInputID`来自定义配置日期选择器`cog`，Pikaday 小部件也可以正常启动。但是，如果我们需要为`cog`提供一组默认参数，该怎么办？在下一个示例中，我们将构建另一个混合`cog`，一个旋转木马（图像滑块）`cog`，在其中我们将定义默认参数。

# 旋转木马齿轮

在本例中，我们将创建一个图像旋转齿轮，如图 9.11 中的线框设计所示。

![](Images/bc822f06-91d8-4abd-ad46-dee1c7ecf5f3.png)

图 9.11：描绘旋转木马齿轮的线框设计

转盘齿轮将由小型滑块小部件提供动力，该小部件使用香草 JavaScript 实现。以下是小滑块项目的 URL:[T0]https://github.com/ganlanyuan/tiny-slider 。

我们将小滑块小部件的 JavaScript 源文件`tiny-slider.min.js`放在 cog 的`static/js`文件夹中。我们将与小滑块小部件相关联的 CSS 文件`tiny-slider.css`和`styles.css`放在`static/css`文件夹中。

我们将构建的转盘齿轮将公开 tiny slider 小部件提供的以下输入参数：

```go
container Node | String Default: document.querySelector('.slider').
```

`container`参数表示滑块容器元素或选择器：

```go
items Integer Default: 1.
```

`items`参数表示正在显示的幻灯片数量：

```go
slideBy Integer | 'page' Default: 1.
```

`slideBy`参数表示一次“点击”的幻灯片数量：

```go
autoplay Boolean Default: false.
```

`autoplay`参数切换幻灯片的自动更改：

```go
autoplayText Array (Text | Markup) Default: ['start', 'stop'].
```

`autoplayText`参数控制自动播放开始/停止按钮中显示的文本或标记。

```go
controls Boolean Default: true.
```

`controls`参数用于切换控件（上一个/下一个按钮）的显示和功能

图像转盘将显示 IGWEB 上提供的一组特色产品。我们已经在`shared/templates/index_content.tmpl`源文件中声明了 cog 的安装点：

```go
<div data-component="cog" id="carousel"></div>
```

我们已经声明了`div`容器将作为转盘齿轮的安装点。我们已经声明了属性`"data-component"`，并将其赋值为`"cog"`。我们还声明了`"carousel"`的`id`属性。

转盘 cog 在`shared/cogs/carousel`文件夹中找到的`carousel.go`源文件中实现。以下是程序包声明和导入分组：

```go
package carousel

import (
  "errors"
  "reflect"

  "github.com/gopherjs/gopherjs/js"
  "github.com/uxtoolkit/cog"
)
```

小滑块小部件是用一个输入参数 JavaScript 对象实例化的。我们将使用`CarouselParams struct`对输入参数对象建模：

```go
type CarouselParams struct {
  *js.Object
  Container string `js:"container"`
  Items int `js:"items"`
  SlideBy string `js:"slideBy"`
  Autoplay bool `js:"autoplay"`
  AutoplayText []string `js:"autoplayText"`
  Controls bool `js:"controls"`
}
```

嵌入指向`js.Object`的指针后，`struct`中定义的每个字段都对应于其等价的 JavaScript 参数 object 属性。例如，`Container`字段映射到输入参数对象的`container`属性。

下面是定义`carousel`cog 的结构：

```go
type Carousel struct {
  cog.UXCog
  carousel *js.Object
}
```

像往常一样，我们嵌入了`cog.UXCog`类型以借用`UXCog`的功能。`carousel`字段将用于引用小滑块小部件，它是一个 JavaScript 对象。

到现在为止，您应该能够猜出旋转齿轮的构造函数是什么样子的：

```go
func NewCarousel() *Carousel {
  c := &Carousel{}
  c.SetCogType(cogType)
  return c
}
```

除了创建对`Carousel`实例的新引用外，构造函数还设置 cog 的`cogType`。

现在是时候检查旋转木马 cog 实现的最大部分了，这可以在 cog 的`Start`方法中找到：

```go
func (c *Carousel) Start() error {
```

我们首先检查`cog`的用户是否设置了`contentItems`和`carouselContentID`道具。`contentItems`属性是应该出现在转盘中的图像的服务器相对图像路径的字符串片段。`carouselContentID`属性是保存旋转木马内容的`div`容器的`id`属性的值。

如果这两个道具中有一个没有设置，我们返回一个`error`，指示这两个道具都必须设置。如果设置了两个道具，我们将继续渲染 cog：

```go
  if c.Props["contentItems"] == nil || c.Props["carouselContentID"] == nil {
    return errors.New("The contentItems and carouselContentID props need to be set!")
  }

  err := c.Render()
  if err != nil {
    return err
  }
```

我们在此时呈现[T0]，因为网页上需要存在 HTML 标记，才能使[T1]正常工作。值得注意的是，存放转盘内容的`div`容器，我们使用所需的`carouselContentID`道具提供其`id`。如果有`error`呈现`cog`，我们返回`error`表示`cog`无法启动。如果在呈现`cog`时没有遇到`error`，我们继续实例化输入参数对象：

```go
 params := &CarouselParams{Object: js.Global.Get("Object").New()}
```

这个`struct`表示我们将在微小滑块对象实例化时提供给它的输入参数。

代码的下一部分很重要，因为这是我们定义默认参数的地方：

```go
  // Set the default parameter values
  params.Items = 1
  params.SlideBy = "page"
  params.Autoplay = true
  params.AutoplayText = []string{PLAYTEXT, STOPTEXT}
  params.Controls = false
```

当 cog 维护人员查看这段代码时，他们可以很容易地确定 cog 的默认行为是什么。通过查看默认参数，可以看出滑块一次只显示一个项目。滑块设置为“按页面滑动”模式，滑块将自动启动幻灯片放映。我们为`AutoplayText`属性提供了一个字符串片段，分别使用`PLAYTEXT`和`STOPTEXT`常量为播放和停止按钮提供文本符号。我们已将`Controls`属性设置为`false`，因此默认情况下，图像转盘上不会出现“下一个”和“上一个”按钮。

我们继续迭代`cog`用户提供的所有属性，访问每个道具，包括`propName`（`string`）和`propValue`（`interface{}`）：

```go
 for propName, propValue := range c.Props {
```

我们在`propName`上声明`switch`块：

```go
 switch propName {

    case "carouselContentID":
      if propValue != nil {
        params.Container = "#" + c.Props["carouselContentID"].(string)
      }

    case "contentItems":
      // Do nothing

    case "items":
      if propValue != nil {
        params.Items = propValue.(int)
      }

    case "slideBy":
      if propValue != nil {
        params.SlideBy = c.Props["slideBy"].(string)
      }

    case "autoplay":
      if propValue != nil {
        params.Autoplay = c.Props["autoplay"].(bool)
      }

    case "autoplayText":
      if propValue != nil {
        params.AutoplayText = c.Props["autoplayText"].([]string)
      }

    case "controls":
      if propValue != nil {
        params.Controls = c.Props["controls"].(bool)
      }

    default:
      println("Warning: Unknown prop name provided: ", propName)
    }
  }
```

使用`switch`块可以很容易地看到定义的每个`case`语句中所有有效道具的名称。如果道具名称未知，则属于`default`情况，我们在 web 控制台中打印警告消息。

第一个`case`处理所需的`"carouselContentID"`道具。用于指定包含转盘内容项的`div`容器。

第二个`case`处理所需的`"contentItems"`道具。这个道具是一个`string`切片，它将用于 cog 的模板中，因此我们无需对其执行任何操作。

第三个`case`处理`"items"`道具。这是处理 tns slider 对象的`items`参数的道具，该参数显示在给定时间要显示的幻灯片数量。如果道具值不是`nil`，我们将道具值的`int`值指定给`params.Items`属性。

第四个`case`处理`slideBy`道具。如果 prop 值不是`nil`，我们将 prop 值（断言为`string`的类型）分配给`params`对象的`SlideBy`属性。

第五个`case`操作`"autoplay"`道具。如果 prop 值不是`nil`，我们将 prop 值（断言为`bool`的类型）分配给`params`对象的`Autoplay`属性。

第六个`case`操作`"autoplayText"`道具。如果 prop 值不是`nil`，我们将 prop 值（断言为`[]string`的类型）分配给`params`对象的`AutoplayText`属性。

第七个`case`处理`"controls"`道具。如果 prop 值不是`nil`，我们将属性值（类型断言为`bool`）分配给`params`对象的`Controls`属性。

如果物业名称不属于上述七种情况中的任何一种，则由`default case`处理。回想一下，如果我们到达这个`case`，它表示`cog`的用户提供了一个未知的道具名称。

我们现在可以实例化小滑块小部件并将其分配给 cog 的`carousel`属性：

```go
c.carousel = JS.Get("tns").New(params)
```

`Start`方法返回`nil`值，表示启动`cog`时没有遇到错误：

```go
return nil
```

`shared/cogs/carousel/templates/carousel.tmpl`源文件定义转盘`cog`的模板：

```go
<div id="{{.carouselContentID}}" class="carousel">
{{range .contentItems}}
  <div><img src="{{.}}"></div>
{{end}}
</div>
```

我们申报了一个`div`容器来存放旋转木马的图像。`contentItems``string`切片中的每个项目都是一个与图像相关的服务器路径。我们使用`range`模板操作来迭代`contentItems`属性（一个`string`切片）以打印出每个图像的地址，这些图像位于其自己的`div`容器中。注意，我们提供了点（`.`模板动作作为`img`元素的`src`属性的值。点模板动作表示迭代`contentItems`切片时的当前值。

现在我们已经实现了旋转木马`cog`并创建了它的模板，现在是在主页上实例化并启动`cog`的时候了。我们将在`client/handlers/index.go`源文件中的`InitializeIndexPage`函数开头添加转盘`cog`的代码：

```go
  c := carousel.NewCarousel()
  c.CogInit(env.TemplateSet)
  c.SetID("carousel")
  contentItems := []string{"/static/images/products/watch.jpg", "/static/images/products/shirt.jpg", "/static/images/products/coffeemug.jpg"}
  c.SetProp("contentItems", contentItems)
  c.SetProp("carouselContentID", "gophersContent")
  err := c.Start()
  if err != nil {
    println("Encountered the following error when attempting to start the carousel cog: ", err)
  }
```

我们首先创建一个新的旋转木马`cog``c`，调用构造函数`NewCarousel`。我们调用`CogInit`方法将应用程序的模板集与`cog`相关联。我们调用`SetID`方法将`cog`与其装入点相关联，即`cog`将向其输出的`div`容器。我们使用包含图像文件路径的`string`切片文本创建`string`切片。我们调用`SetProp`方法来设置所需的`contentItems`和所需的`carouselContent`道具。我们不设置任何其他道具，因为我们对旋转齿轮的默认行为感到满意。我们启动`cog`并检查在执行此操作时是否遇到任何错误。如果遇到任何错误，我们将在 web 控制台中打印错误消息。

*图 9.12*是渲染旋转木马齿轮的屏幕截图：

![](Images/4be2b386-51b2-4bd6-899d-d06b545241a2.png)

图 9.12：旋转木马齿轮的作用

现在，我们已经完成了转盘齿轮，我们将在下一节中创建一个通知齿轮，在网页上显示动画通知消息。

# 通知齿轮

到目前为止，我们考虑的所有`cog`实现都已将输出呈现到 web 页面。让我们考虑一个不提供任何输出到 Web 页面的 Oracle T1。我们将要实现的 notify`cog`将利用 Alertify JavaScript 库在网页上显示动画通知消息。

*图 9.13*是一幅插图，描绘了当用户向购物车添加商品时，出现在网页右下角的通知消息：

![](Images/132cedbc-64e4-4837-8316-8be30cb47e23.png)

图 9.13：描述通知的图示

由于`cog`将完全依赖 JavaScript 库来满足其呈现需求，因此我们不必为`cog`实现模板，也不必为 cog 声明装入点。

我们将利用 AlertifyJavaScript 库的功能来显示通知。以下是 Alertify 项目的 URL:[T0]https://github.com/MohammadYounes/AlertifyJS 。

查看`shared/cogs/notify`文件夹内部，注意不存在模板文件夹。我们已经将 Alertify 的 CSS 和 JavaScript 源文件的静态资产分别放在了`shared/cogs/notify/static/css`和`shared/cogs/notify/static/js`文件夹中。

通知`cog`在`shared/cogs/notify`文件夹中找到的`notify.go`源文件中实现。由于客户端 web 应用程序只有一个 notify`cog`提供的通知系统是有意义的，因此只应启动一次`cog`实例。为了跟踪并确保只能启动一个 notify`cog`实例，我们将声明`alreadyStarted`布尔变量：

```go
var alreadyStarted bool
```

`Notify`结构定义通知`cog`的字段：

```go
type Notify struct {
  cog.UXCog
  alertify *js.Object
  successNotificationEventListener func(*js.Object)
  errorNotificationEventListener func(*js.Object)
}
```

我们键入嵌入的`cog.UXCog`是为了提供实现`Cog`接口所需的功能。`alertify`字段用于引用`alertify`JavaScript 对象。

我们正在构建的通知`cog`是事件驱动的。例如，当从客户端应用程序的任何页面触发自定义成功通知事件时，将显示成功通知。我们定义了两个字段，`successNotificationEventListener`和`errorNotificationEventListener`，这两个字段都是将 JavaScript 对象指针作为输入变量的函数。我们已经定义了这些字段，这样我们就可以跟踪自定义事件侦听器函数，我们设置这些函数来侦听成功和错误通知。当需要删除事件监听器时，访问它们变得很容易，因为它们是 notify`cog`实例的属性。

`NewNotify`函数用作构造函数：

```go
func NewNotify() *Notify {
  n := &Notify{}
  n.SetCogType(cogType)
  n.SetCleanupFunc(n.Cleanup)
  return n
}
```

请注意，我们已经注册了一个清理函数（以粗体显示），该函数将在销毁[T0]之前调用。

让我们检查 cog 的`Start`方法：

```go
func (n *Notify) Start() error {
  if alreadyStarted == true {
    return errors.New("The notification cog can be instantiated only once.")
  }
```

我们首先通过检查`alreadyStarted`布尔变量的值来检查 notify`cog`实例是否已经启动。如果`alreadyStarted`的值为`true`，则表示之前的 notify`cog`实例已经启动，所以我们返回一个`error`，表示 notify`cog`无法启动。

如果`cog`尚未启动，我们继续实例化 Alertify JavaScript 对象：

```go
 n.alertify = js.Global.Get("alertify")
```

我们调用 cog 的`StartListening`方法来设置侦听自定义成功和错误通知消息事件的事件侦听器：

```go
  n.StartListening()
  return nil
```

以下是 cog 的`StartListening`方法：

```go
func (n *Notify) StartListening() {

  alreadyStarted = true
  D := dom.GetWindow()
  n.successNotificationEventListener = D.AddEventListener("displaySuccessNotification", false, func(event dom.Event) {
    message := event.Underlying().Get("detail").String()
    n.notifySuccess(message)
  })

  n.errorNotificationEventListener = D.AddEventListener("displayErrorNotification", false, func(event dom.Event) {
    message := event.Underlying().Get("detail").String()
    n.notifyError(message)
  })
}
```

如果我们达到了这个方法，则表示`cog`启动成功，所以我们将`alreadyStarted`布尔变量设置为`true`。我们设置了一个事件侦听器，它将侦听`displaySuccessNotification`自定义事件。我们通过将正在创建的事件侦听器函数分配给`cog`实例的`successNotificationEventListener`属性来跟踪它。我们声明并实例化`message`变量，并将其设置为`event`对象的`detail`属性，该属性将包含应在网页上显示给用户的`string``message`。然后我们调用 cog 的`notifySuccess`方法在网页上显示成功通知消息。

我们按照类似的过程为`displayErrorNotification`设置事件侦听器。我们将事件侦听器函数分配给 cog 的`errorNotificationEventListener`属性。我们从`event`对象中提取`detail`属性，并将其分配给`message`变量。我们调用 cog 的`notifyError`方法在网页上显示错误通知消息。

`notifySuccess`方法负责在网页上显示成功通知消息：

```go
func (n *Notify) notifySuccess(message string) {
  n.alertify.Call("success", message)
}
```

我们调用 alertify 对象的`success`方法来显示成功通知消息。

`notifyError`方法负责在网页上显示错误通知消息：

```go
func (n *Notify) notifyError(message string) {
  n.alertify.Call("error", message)
}
```

我们调用 alertify 对象的`error`方法来显示错误通知消息。

cog 的`CleanUp`方法只是调用 cog 的`StopListening`方法：

```go
func (n *Notify) Cleanup() {
  n.StopListening()
}
```

`StopListening`方法用于在`cog`被销毁之前移除事件侦听器：

```go
func (n *Notify) StopListening() {
  D := dom.GetWindow()
  if n.successNotificationEventListener != nil {
    D.RemoveEventListener("displaySuccessNotification", false, n.successNotificationEventListener)
  }

  if n.errorNotificationEventListener != nil {
    D.RemoveEventListener("displayErrorNotification", false, n.errorNotificationEventListener)
  }

}
```

我们调用 DOM 对象的`RemoveEventListener`方法来删除处理`displaySuccessNotification`和`displayErrorNotification`自定义事件的事件侦听器函数。

`notify`包的导出`Success`功能用于广播自定义成功事件通知消息：

```go
func Success(message string) {
  var eventDetail = js.Global.Get("Object").New()
  eventDetail.Set("detail", message)
  customEvent := js.Global.Get("window").Get("CustomEvent").New("displaySuccessNotification", eventDetail)
  js.Global.Get("window").Call("dispatchEvent", customEvent)
}
```

在函数内部，我们创建了一个名为`eventDetail`的新 JavaScript 对象。我们将应该显示在网页上的`string``message`分配给`eventDetail`对象的`detail`属性。然后我们创建一个名为`customEvent`的新自定义`event`对象。我们将自定义事件的名称`displaySuccessNotification`与`eventDetail`对象一起作为输入参数传递给`CustomEvent`类型的构造函数。最后，为了调度事件，我们在`window`对象上调用`dispatchEvent`方法并提供`customEvent`。

notify 包的导出`Error`功能用于广播自定义错误事件通知消息：

```go
func Error(message string) {
  var eventDetail = js.Global.Get("Object").New()
  eventDetail.Set("detail", message)
  customEvent := js.Global.Get("window").Get("CustomEvent").New("displayErrorNotification", eventDetail)
  js.Global.Get("window").Call("dispatchEvent", customEvent)
}
```

此函数的实现与`Success`函数几乎相同。唯一的区别是我们发送了一个`displayErrorNotification`定制事件。

我们在`client/handlers/initpagelayoutcontrols.go`源文件中找到的`InitializePageLayoutControls`函数中实例化并启动 notify`cog`（粗体显示）：

```go
func InitializePageLayoutControls(env *common.Env) {

 n := notify.NewNotify()
 err := n.Start()
 if err != nil {
 println("Error encountered when attempting to start the notify cog: ", err)
 }

  liveChatIcon := env.Document.GetElementByID("liveChatIcon").(*dom.HTMLImageElement)
  liveChatIcon.AddEventListener("click", false, func(event dom.Event) {

    chatbox := env.Document.GetElementByID("chatbox")
    if chatbox != nil {
      return
    }
    go chat.StartLiveChat(env)
  })

}
```

将商品添加到购物车的通知消息（成功或错误）可在`client/handlers/shoppingcart.go`源文件内的`addToCart`函数中找到：

```go
func addToCart(productSKU string) {

  m := make(map[string]string)
  m["productSKU"] = productSKU
  jsonData, _ := json.Marshal(m)

  data, err := xhr.Send("PUT", "/restapi/add-item-to-cart", jsonData)
  if err != nil {
    println("Encountered error: ", err)
    notify.Error("Failed to add item to cart!")
    return
  }
  var products []*models.Product
  json.NewDecoder(strings.NewReader(string(data))).Decode(&products)
  notify.Success("Item added to cart")
}
```

如果无法将商品添加到购物车，则调用`notify.Error`函数（粗体显示）。如果商品成功添加到购物车，则调用`notify.Success`函数（以粗体显示）。

在`client/handlers/shoppingcart.go`源文件的`removeFromCart`函数中可以找到从购物车中移除物品的通知消息：

```go
func removeFromCart(env *common.Env, productSKU string) {

  m := make(map[string]string)
  m["productSKU"] = productSKU
  jsonData, _ := json.Marshal(m)

  data, err := xhr.Send("DELETE", "/restapi/remove-item-from-cart", jsonData)
  if err != nil {
    println("Encountered error: ", err)
    notify.Error("Failed to remove item from cart!")
    return
  }
  var products []*models.Product
  json.NewDecoder(strings.NewReader(string(data))).Decode(&products)
  renderShoppingCartItems(env)
  notify.Success("Item removed from cart")
}
```

如果商品无法从购物车中移除，则调用`notify.Error`函数（粗体显示）。如果商品成功从购物车中移除，则调用`notify.Success`函数（粗体显示）。

*图 9.14*是当我们向购物车添加产品时，通知 cog 的截图：

![](Images/6776f61a-1404-4129-8eb4-8815fef218c1.png)

图 9.14：运行中的通知 cog

# 总结

在本章中，我们介绍了 cogs 可重用组件，这些组件可以专门在 Go（纯 cogs）中实现，也可以使用 Go 和 JavaScript（混合 cogs）实现。齿轮有很多好处。我们可以以即插即用的方式使用它们，创建它们的多个实例，由于它们是自包含的，因此易于维护它们，并且可以轻松地重用它们，因为它们可以作为自己的 Go 包及其所需的静态资产（模板文件、CSS 和 JavaScript 源文件）存在。

我们向您介绍了 UX 工具包，它为我们提供了实现 cogs 的技术。我们研究了 cog 的解剖结构，并探索了 cog 的文件结构在 Go、CSS、JavaScript 和模板文件的放置方面可能是什么样子。我们考虑了 COG 如何利用虚拟 DOM 来呈现其内容，而不是执行昂贵的替换内部 HTML 操作。我们介绍了 cog 生命周期的各个阶段。我们向您展示了如何实现我们散布在整个 IGWEB 上的各种齿轮，包括纯齿轮和混合齿轮。

在[第 10 章](10.html)*测试同构的 Go Web 应用程序*中，我们将学习如何执行 IGWEB 的自动化端到端测试。这将包括在服务器端和客户端实施测试以实现功能。