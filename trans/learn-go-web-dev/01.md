# 第一章 Go 的介绍与设置

从围棋开始，你会听到一个最常见的说法，那就是它是一种系统语言。

事实上，Go 团队自己对 Go 的早期描述之一是，该语言被构建为一种现代系统语言。它的构建是为了将 C 语言的速度和能力与 Python 等现代解释语言的语法优雅和简洁结合起来。只要看几段 Go 代码，就可以看到这个目标实现了。

从 Go 常见问题解答中了解创建 Go 的原因：

> *“Go 诞生于对现有语言和系统编程环境的失望中。”*

也许当今系统编程的最大部分是设计后端服务器。很明显，网络在这个世界中占了很大的比例，但不是排他性的。

直到最近，围棋才被认为是一种网络语言。毫不奇怪，开发人员花了几年时间涉猎、试验并最终接受了该语言，才开始将其带到新的领域。

虽然 Go 是现成的 web 产品，但它缺少很多人们现在经常认为是理所当然的 web 开发关键框架和工具。随着围棋社区的发展，脚手架开始以许多新的令人兴奋的方式显现出来。结合现有的辅助工具，Go 现在是端到端 web 开发的一个完全可行的选项。但回到首要问题：为什么要去？公平地说，这并不适用于每一个 web 项目，但任何能够从高性能、安全的现成 web 服务中获益并具有漂亮并发模型的附加好处的应用程序都将是一个很好的候选者。

在本书中，我们将探讨这些方面和其他方面，以概述什么可以使 Go 成为适合您的 web 架构和应用程序的正确语言。

我们不打算处理 Go 语言的许多低级方面。例如，我们假设您熟悉变量和常量声明。我们假设您了解控制结构。

在本章中，我们将介绍以下主题：

*   安装围棋
*   构建项目
*   导入包
*   介绍 net 软件包
*   你好，韦伯

# 安装 Go

当然，最关键的第一步是确保 Go 可用并准备好启动我们的第一台 web 服务器。

### 注

虽然 Go 最大的卖点之一是它的跨平台支持（在本地构建和使用，同时瞄准其他操作系统），但在与 Nix 兼容的平台上，您的生活会轻松得多。

如果你在窗户上，不要害怕。在本机上，使用[T0]命令运行时，您可能会遇到不兼容的软件包、防火墙问题和其他一些怪癖，但 Go 生态系统的 95%将对您可用。您还可以非常轻松地运行虚拟机，事实上，这是模拟潜在生产环境的好方法。

深入的安装说明见[https://golang.org/doc/install](https://golang.org/doc/install) ，但在继续之前，我们将在这里讨论一些奇怪的问题。

对于 OSX 和 Windows，Go 是作为二进制安装包的一部分提供的。对于任何带有包管理器的 Linux 平台来说，事情都非常简单。

### 注

**通过普通 Linux 软件包管理器安装：**

Ubuntu:[T0]

CentOS:[T0]

在 OSX 和 Linux 上，都需要在路径[T0]和[T1]中添加几行代码。首先，您需要找到 Go binary 的安装位置。这在不同的发行版中有所不同。一旦您找到了，您就可以配置`PATH`和`GOPATH`，如下所示：

```
export PATH=$PATH:/usr/local/go/bin
export GOPATH="/usr/share/go"

```

虽然要使用的路径没有严格定义，但一些约定已经结合在一起，从用户主目录下的子目录开始，例如`$HOME/go`或`~Home/go`。只要这个位置是永久设置的并且不改变，您就不会遇到冲突或丢失包的问题。

您可以通过运行`go env`命令来测试这些更改的影响。如果您发现任何问题，这意味着您的目录是不正确的。

请注意，根据 GOBIN 目录是否正确设置，这可能不会阻止 Go 运行，但会阻止您在整个系统中全局安装软件包。

要测试安装，您可以通过`go get`命令获取任何 Go 包，并在某处创建 Go 文件。作为一个简单的例子，首先随机获取一个包，我们将使用 Gorilla 框架中的一个包，因为在本书中我们将大量使用这个包。

```
go get github.com/gorilla/mux

```

如果运行时没有任何问题，Go 将正确找到您的`GOPATH`。为了确保 Go 能够访问您下载的软件包，起草一个非常快速的软件包，尝试利用 Gorilla 的 mux 软件包并运行它来验证是否找到了软件包。

```
package main

import (
  "fmt"
  "github.com/gorilla/mux"
  "net/http"
)

func TestHandler(w http.ResponseWriter, r *http.Request) {

}

func main() {
  router := mux.NewRouter()
  router.HandleFunc("/test", TestHandler)
  http.Handle("/", router)
  fmt.Println("Everything is set up!")
}
```

在命令行中运行`go run test.go`。它不会做太多，但会带来好消息，如以下屏幕截图所示：

![Installing Go](graphics/B04294_01_01.jpg)

# 构建项目

当你刚开始玩游戏时，懒散地设置你的应用程序并没有什么问题。

例如，为了尽快开始，你可以在任何你喜欢的地方创建一个简单的`hello.go`文件，并且编译时不会出现问题。

但是，当您进入需要多个或不同软件包（稍后将详细介绍）或具有更明确的跨平台需求的环境时，以便于使用 go build 工具的方式设计项目是有意义的。

以这种方式设置代码的价值在于 go build 工具的工作方式。如果您有本地（您的项目）包，构建工具将首先在`src`目录中查找，然后在`GOPATH`目录中查找。在为其他平台构建时，go build 将利用本地 bin 文件夹来组织二进制文件。

在构建用于大规模使用的软件包时，您还可能会发现，在`GOPATH`目录下启动应用程序，然后将其象征性地链接到另一个目录，或者执行相反的操作，都将允许您进行开发，而无需随后获取自己的代码。

## 代码约定

与任何语言一样，成为 Go 社区的一部分意味着永远考虑其他人创建代码的方式。特别是如果您要在开放源代码存储库中工作，您将希望以其他人的方式生成代码，以减少人们获取或包含代码时的摩擦。

Go 团队包含的一个非常有用的工具是 Go`fmt`。`fmt`这里当然是指格式化，而这正是这个工具所做的，它会根据设计的约定自动格式化代码。

通过强制执行样式约定，Go 团队帮助缓解了许多其他语言中最常见、最普遍的争论之一。

虽然语言社区倾向于推动编码惯例，但在个人编写程序的方式上总是存在一些小的特质。让我们使用一个最常见的例子来说明如何放置开口支架。

一些程序员喜欢它与语句在同一行：

```
for (int i = 0; i < 100; i++) {
  // do something
}
```

而其他人则喜欢在后续行中使用：

```
for (int i = 0; i < 100; i++)
{
  // do something
}
```

这些细微的差异引发了近乎宗教的大辩论。Gofmt 工具允许您屈服于 to Go 的指令，从而有助于缓解这种情况。

现在，Go 绕过了编译器中这个明显的争用源，方法是格式化代码，类似于前面讨论的后一个示例。编译器会抱怨，你只会得到一个致命的错误。但是，其他样式选择具有一定的灵活性，当您使用该工具格式化时，会强制执行这些灵活性。

例如，这里是 Go before`go fmt`中的一段代码：

```
func Double(n int) int {

  if (n == 0) {
    return 0
  } else {
    return n * 2
  }
}
```

当涉及到共享和读取代码时，任意空白可能是团队存在的祸根，特别是当每个团队成员不在同一个 IDE 上时。

通过运行`go fmt`，我们可以清理这些内容，从而根据 Go 的惯例转换我们的空白：

```
func Double(n int) int {
  if n == 0 {
    return 0
  } else {
    return n * 2
  }
}
```

长话短说：在发送或推送代码之前，始终运行`go fmt`。

# 进口包装

除了绝对和最琐碎的应用程序，甚至不能产生**Hello World**输出，您必须在 Go 应用程序中有一些导入包。

比如说**Hello World**，我们需要某种方式来生成输出。与许多其他语言不同，即使是核心语言库也可以通过名称空间包访问。在 Go 中，名称空间由存储库端点 URL 处理，该 URL 为[github.com/nkozyra/gotest](http://github.com/nkozyra/gotest)，可直接在 github（或任何其他公共位置）上打开以供审查。

## 处理私有存储库

goget 工具可以轻松处理存储库中托管的包，如 GitHub、Bitbucket 和 Google 代码（以及其他一些）。您也可以在其他地方托管自己的项目，理想情况下是 git 项目，尽管它可能会引入一些您可能希望避免的依赖项和错误源。

但私人回购协议呢？虽然 go-get 是一个很好的工具，但您会发现自己看到一个错误，而没有一些额外的配置、SSH 代理转发等等。

您可以通过几种方法解决这个问题，但一种非常简单的方法是直接使用版本控制软件在本地克隆存储库。

## 处理版本控制

当您阅读关于在 Go 应用程序中定义和导入名称空间的方式时，可能已暂停。如果您正在使用应用程序的版本 1，但希望引入版本 2，会发生什么情况？在大多数情况下，这必须在`import`的路径中明确定义。例如：

```
import (
  "github.com/foo/foo-v1"
)
```

与：

```
import (
  "github.com/foo/foo-v2"
)
```

正如您可能想象的那样，这可能是 Go 处理远程软件包的一个特别棘手的方面。

与许多其他包管理器不同，go-get 是分散的，也就是说，没有人维护包和版本的规范参考库。这有时会成为新开发人员的痛处。

在大多数情况下，包总是通过`go get`命令导入，该命令读取远程存储库的主分支。这意味着在同一端点上维护一个包的多个版本在很大程度上是不可能的。

正是利用 URL 端点作为名称空间允许分散，但同时也缺少对版本控制的内部支持。

作为一名开发人员，您最好在执行`go get`命令时将每个包都视为最新版本。如果您需要更新的版本，您可以始终遵循作者决定的任何模式，如前面的示例。

作为您自己软件包的创建者，请确保您也坚持这一理念。保持您的主分支负责人是最新的，这将确保您的代码符合其他 Go 作者的约定。

# 推出网络套餐

Go 中所有网络通信的核心是名称恰当的网络包，它不仅包含非常相关的 HTTP 操作的子包，还包含其他 TCP/UDP 服务器、DNS 和 IP 工具的子包。

简而言之，创建健壮的服务器环境所需的一切。

当然，在本书中，我们关心的主要是`net/http`包，但我们将了解一些利用包的其余部分的其他功能，例如 TCP 连接以及 WebSocket。

让我们快速看一下刚才我们讨论的 Hello World（本例中为 Web）示例的执行情况。

# 你好，韦伯

以下应用程序在`/static`位置作为静态文件，在`/dynamic`位置作为动态`response`：

```
package main

import (
  "fmt"
  "net/http"
  "time"
)

const (
  Port = ":8080"
)

func serveDynamic(w http.ResponseWriter, r *http.Request) {
  response := "The time is now " + time.Now().String()
  fmt.Fprintln(w,response)
}
```

正如`fmt.Println`将在控制台级别生成所需的内容一样，`Fprintln`允许您将输出定向到任何编写器。我们将在[第 2 章](02.html "Chapter 2. Serving and Routing")、*服务和路由*中进一步介绍作者，但他们代表了一个基本、灵活的界面，在许多 Go 应用程序中使用，而不仅仅是在 Web 上：

```
func serveStatic(w http.ResponseWriter, r *http.Request) {
  http.ServeFile(w, r, "static.html")
}
```

我们的`serveStatic`方法只服务于一个文件，但允许它直接服务于任何文件并将 Go 用作只服务于静态内容的老式 web 服务器是很简单的：

```
func main() {
  http.HandleFunc("/static",serveStatic)
  http.HandleFunc("/",serveDynamic)
  http.ListenAndServe(Port,nil)
}
```

随意选择您选择的可用端口更高的端口将更容易绕过内置的安全功能，尤其是在 Nix 系统中。

如果我们以前面的示例为例，在本例中访问相应的 URL 根目录`/`和静态页面`/static`，我们应该看到预期的输出，如图所示：

在根目录`/`处，输出如下：

![Hello, Web](graphics/B04294_01_02.jpg)

在`/static`处，输出如下：

![Hello, Web](graphics/B04294_01_03.jpg)

正如您所看到的，为 Web 生成非常简单的输出在 Go 中非常简单。内置软件包允许我们使用本机软件包创建一个基本但速度极快的站点，只需几行代码即可。

这可能不是很刺激，但在我们能跑之前，我们必须先走路。生成前面的输出引入了几个关键概念。

首先，我们看到了`net/http`如何使用 URI 或 URL 端点将请求定向到助手函数，助手函数必须实现`http.ResponseWriter`和`http.Request`方法。如果他们不实现它，我们会在这方面得到一个非常明显的错误。

以下是尝试以这种方式实现它的示例：

```
func serveError() {
  fmt.Println("There's no way I'll work!")
}

func main() {
  http.HandleFunc("/static", serveStatic)
  http.HandleFunc("/", serveDynamic)
  http.HandleFunc("/error",serveError)
  http.ListenAndServe(Port, nil)
}
```

以下屏幕截图显示了您将从 Go 中获得的结果错误：

![Hello, Web](graphics/B04294_01_04.jpg)

您可以看到，`serveError`没有包含所需的参数，因此导致编译错误。

# 总结

本章介绍了围棋和围棋中的网络制作的最基本概念，但这些要点是在语言和社区中实现高效的关键基础要素。

我们研究了编码约定、包设计和组织，并制作了我们的第一个程序——非常熟悉的 Hello，World 应用程序，并通过我们的本地主机访问它。

显然，我们离真正的、成熟的 Web 应用还有很长的路要走，但是构建块对于实现这一目标至关重要。

在[第 2 章](02.html "Chapter 2. Serving and Routing")*服务和路由*中，我们将了解如何使用 Go`net/http`包中的内置路由功能以及两个第三方路由器包将不同的请求定向到不同的应用程序逻辑。