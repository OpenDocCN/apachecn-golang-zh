# 函子、幺半群和泛型

“这是我在围棋中对函数编程的尝试。我认为这是个好主意，但我真的不确定。”

我在十几篇博客文章中看到过这样的评论。我希望通过阅读本章和示例，您会对函数式编程（FP）产生新的爱好。这并不是因为它太单纯，以至于你担心副作用编程会让你下地狱，而是因为你对构成纯 FP 基础的概念感到满意，并且你看到它的好处大于学习如何使用它的成本。

本章的目标如下：

*   理解 Go 中缺少泛型支持是一件好事
*   了解如何使用泛型代码生成工具来解决样板问题
*   深入理解函数组合的工作原理
*   建立一些函子，了解如何在世界之间映射
*   构建几个幺半群并学习如何编写自己的 reduce 函数

## 理解函子

函子是类别之间保持结构的变换。换句话说，函子是一种可映射类型。让我们用一个例子来看看这意味着什么。

### 命令式与纯 FP 示例

假设我们从一片 int 开始，`ints := []int{1,2,3}`。

在命令式编程中，我们编写了所有的脚手架代码，以准确地实现如何处理这部分 int。然而，在纯 FP 中，我们告诉函子我们希望循环做什么：

![](../Images/bb333e07-c020-4551-a72f-6f87db47d65b.jpg)

以下是输出：

```go
imperative loop: [2 3 4]
fp map: [2 3 4]
```

让我们看看这是怎么回事。

#### 地图功能为我们做了什么？

`Map`函数抽象了循环。我们不必费心编写相同的旧范围/循环代码。我们只需传入原始的`ints`列表，并告诉函子将该片段映射到一个片段中，其中每个元素都比以前大一个。这与 SQL 非常相似，在 SQL 中，我们声明所需的数据，并让数据库引擎担心如何获取数据。

#### 这可能给我们带来什么好处？

我们是否必须更改 SQL 查询代码才能从提高查询性能的数据库引擎更新中获益？答案是否定的，我们的纯 FP 代码也是如此。

如果我们所要做的就是编写`Functor(list).Map(add1)`并定义我们的自定义`add1`函数呢？如果`Functor`是 Go 标准库（或另一个非常稳定的第三方软件包）的一部分，如果下一个版本的 Go 问世，并且它知道如何根据我们传递的列表大小优化性能，该怎么办？使用最新版本的 Go（或其他非常稳定的第三方软件包）进行编译，这难道不是一个自动的、显著的好处吗？

就编写的代码行数而言，甚至就清晰性而言，这似乎不是一个大的胜利。在这种情况下，在较小的实用程序或管理程序中，它可能不会带来很大的好处。使用 FP 样式提供最大好处的地方是在业务用例逻辑中。我们寻找需要小心的地方，不要让嘈杂的代码（如 for 循环脚手架和错误检查代码块）扰乱业务意图。这些都是 FP 风格编程的好地方。其他好地方是我们希望横向扩展我们的应用程序，而不用担心种族条件或副作用。

### 神奇的建筑

函子可以被认为是一个可以映射的魔法结构，其中魔法结构可以被认为是一个具有恒定元素集的形状，并能够对每个元素应用转换操作。

让我们看一些例子。

#### 色块函子

函子由结构（通常为 Go 中的切片）和变换操作（即映射函数）组成：

| **结构** | 八块，每一块都用不同的颜色填充 |
| **变换操作** | `f(x) = x - 30`，其中`x`为色调 |

下面是一个函子，它将八个彩色块映射到八个相应的块，这些块的颜色已通过应用上面的变换操作来调整框中显示的颜色的色调而改变。

![](../Images/7001a6f6-694a-4b8b-b94a-8166e7ebf186.png)

上图显示了一个**f（x）**箭头，以将杂波保持在最小，但更准确的表示方式将显示从每个原始元素到其相应的新转换元素的箭头。这就是实际发生的情况——每个元素都在结构内部处理，并转换为在结构内部返回的新值：

![](../Images/cf666dbf-d617-46f4-b833-058bb997d673.png)

#### 手指乘以 10 函子

如前所述，函子由结构和转换操作组成：

| **结构** | 五个手指，每个手指代表一个整数 |
| **变换操作** | `f(x) = x * 10` |

![](../Images/573afd21-9780-4895-b8d5-926181d3aa15.png)

从上一章中，我们知道类别包括以下内容：

*   对象分组
*   **对象**：点/点/无属性、无结构的原语
*   **态射（箭头）**：介于两个对象/元素之间的东西

你能看到物体（每个手指上的数字）吗？

你能看到映射（**1**到**10**、**2**到**20**、**3**到**30**等等）吗？

我们的范畴在乘法下是封闭的，有一个恒等元素，有一个映射函数（乘以 10），这意味着我们有一个函子。看到了吗？

这是一个形状保持贴图，从一个类别映射到另一个类别；因此，函子被称为范畴同态。**f（x）**说明函子是两个类别之间的函数。

依靠我们的手指（函子）更能证明我们真正需要知道的是，我们是在幼儿园接受教育的！

### Haskell 中函子的定义

在前一章的类型类层次结构图中，我们已经看到了一个**函子**。函子只有一个类型类方法`fmap`，其类型为`fmap :: (a -> b) -> f a -> f b`。它说——给我一个函数，它接受一个`a`并返回一个`b`，一个内部有一个`a`的结构，我会给你一个内部有一个`b`的结构。该函数应用于结构内部的每个元素。`fmap`函数用于转换结构内部的值。

我们可以互换使用以下术语：

*   结构
*   容器
*   盒

需要记住的重要一点是，函子对对象（结构/容器/盒）内的元素进行操作，并返回带有转换值（而不是原始值）的结构。

### 种类

Haskell 中的函子必须具有`* -> *`类。种类是另一层类型，在 Haskell 的具体类型之上。种类允许我们定义行为类型的功能，然后将它们与适当的类型类连接起来。例如，**Int**可以像一个可显示、可读、有序或可枚举的东西一样工作。Haskell 中的值可以按其类型进行分类。让我们使用 Haskell 的简明语法来查看一些示例：

| **型（类）** | **【种类】** | **说明** |
| **国际** | `*` | `*`表示具体类型（如 Bool、Char 或 Int）。 |
| **字符** | `*` | `*`表示具体类型（如 Bool、Char 或 Int）。 |
| **【】** | `* -> *` | []获取单一类型的种类`*`并返回新类型的种类`*`。 |
| **可能** | `* -> *` | 更高种类的类型，接受单一种类`*`并返回新种类`*`。 |
| **或者** | `* -> * -> *` | 一种更高种类的类型，它接受单一种类`*`并返回新种类`*`或新种类`*`。 |
| **函子** | `(* -> *) ->`约束 | 函子是类型类，而不是类型。我们定义了更高级类型的行为，这是一个函子，它接受一种`*`并将其映射到另一种`*`。约束是指函子必须遵守其代数中定义的规则这一事实。约束强制执行某种限制。例如，数值约束可能会将数值类型的所有值约束为数值。123 次通过，但数值约束的“ABC”失败。 |

#### 大概

**可能**是一个函子，它将每个类型映射到具有附加`Nothing`值的相同类型。`Maybe`类似于一个可选值（注意类型是我们类别中的对象）：

`data Maybe a = Just a | Nothing`

`Maybe Int`的值可以是一个数字，如 2，也可以是零。

`Maybe`类型将类型映射到类型。例如，它将**字符**映射为**字符**。以下代码段中定义的`fmap`显示了每个`a -> b`函数如何有一个对应的版本`Maybe a -> Maybe b`，当给出`Nothing`时，该版本仅返回`Nothing`，否则其行为正常：

```go
instance Functor Maybe where
fmap f Nothing = Nothing
fmap f (Just x) = Just (f x)
```

### 更高层次的多态性

Haskell 丰富的类型特性（类型类、参数化代数数据类型、递归数据类型等）使我们能够在比 Go 更高的级别上实现多态性。

在 Go 中实现多态行为是可能的。但是，由于语言限制（缺少泛型），它需要额外的代码来指定实现所需行为的每种类型。

有关演示如何利用结构和方法派生多态行为的 Golang 代码示例，请参见[http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html](http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html) 。

### 没有泛型会导致大量样板代码

如果不支持泛型，当我们实现一个列表函数时，我们必须为应用程序需要的每种类型实现它。这是大量重复的样板代码。例如，如果我们必须为`int8`、`int32`、`float64`和`complex128`实现一个`Sum`函数，它可能是这样的：

```go
package main

import (
   "fmt"
)

func int8Sum(list []int8) (int8) {
   var result int8 = 0
 for x := 0; x < len(list); x++ {
      result += list[x]
   }
   return result
}

func int32Sum(list []int32) (int32) {
   var result int32 = 0
 for x := 0; x < len(list); x++ {
      result += list[x]
   }
   return result
}

func float64Sum(list []float64) (float64) {
   var result float64 = 0
 for x := 0; x < len(list); x++ {
      result += list[x]
   }
   return result
}

func complex128Sum(list []complex128) (complex128) {
   var result complex128 = 0
 for x := 0; x < len(list); x++ {
      result += list[x]
   }
   return result
}

func main() {
   fmt.Println("int8Sum:", int8Sum([]int8 {1, 2, 3}))
   fmt.Println("int32Sum:", int32Sum([]int32{1, 2, 3}))
   fmt.Println("float64Sum:", float64Sum([]float64{1, 2, 3}))
   fmt.Println("complex128Sum:", complex128Sum([]complex128{1, 2, 3}))
}
```

以下是输出：

```go
int8Sum: 6
int32Sum: 6
float64Sum: 6
complex128Sum: (6+0i)
```

对于泛型，我们只需要实现一个类似于以下函数的`Sum`函数。`<T>`是我们传入的支持`+`操作符的`Sum`类型的占位符：

```go
func Sum(list []<T>) (<T>) {
   var ret <T> = 0
   for item := range list {
      ret += item
   }
   return ret
}
```

如果不必编写所有重复的样板代码就好了。还有其他选择吗？

对我们可以在任何地方使用空的`interface{}`并执行反射和类型转换，将数据从列表结构中拉出来，并将其放回泛型`interface{}`，但这并没有实现，而且需要大量额外的代码。

## 用元编程解决泛型的缺乏

**元编程**（**MP**是关于编写编写代码的代码。在 MP 中，我们编写的程序将程序（甚至程序本身）视为输入数据。我们的 MP 将读取、分析、转换和生成代码。

也许我们可以使用 MP 来修复 Go 中由于缺少对泛型的支持而缺少的东西？

大概首先，让我们更好地了解 MP 是关于什么的。

以下是一些例子：

*   词法分析器、解析器、解释器和编译器
*   **领域特定语言**（**DSLs**）
*   **面向方面编程**（**AOP**）
*   属性（.NET）
*   注释（Java）
*   泛型（.NET，Java）
*   模板（C++）
*   宏（C）
*   缺少方法（Ruby）
*   反射（Go、C#、Ruby）

MP 有几种类型。

支持`eval`函数的程序可以通过连接表示可执行命令的字符串来生成新代码。注意：这可能会带来安全风险，通常不是最佳做法。

一些语言（如 LISP）可以根据状态信息更改自己的应用程序代码，这提供了在运行时做出新决策的灵活性。

其他静态类型语言，例如 C++，具有评估表达式和编译时间决策的能力，以便生成静态编译到最终可执行文件中的代码。这是我们将在下一节中介绍的 MP 类型。

反射是 MP 的一种形式，程序可以在其中观察和修改自己的结构和行为，例如通过确定指针引用的数据类型或返回对象所有属性的列表。

Go 不支持宏或泛型，所以看起来我们必须使用反射。反射允许我们的程序操作在编译时类型未知的对象。

例如，我们可以使用空的`interface{}`创建项目的链接列表。这将允许我们在列表中添加任何类型的数据。当我们从列表中取出一个项目时，我们必须使用类型断言为它分配一个数据类型，以便使用它。问题是，这不是一个类型安全的操作，使用起来很麻烦，而且是一个缓慢的操作。使用反射通常不是最佳实践。一些可能的用例包括以下（没有一个对我们的泛型有帮助）：

*   调用函数
*   识别接口
*   验证字段

有关围棋反思的更多信息，请查看以下信息：
[golang.org/pkg/reflect/](http://golang.org/pkg/reflect/)
[blog.golang.org/laws-of-reflection](http://blog.golang.org/laws-of-reflection)
[blog.ralch.com/tutorial/golang-reflection/](http://blog.ralch.com/tutorial/golang-reflection/)
[blog.gopheracademy.com/birth-bash-2014/advanced-reflection-with-go-at-hashicorp/](http://blog.gopheracademy.com/birthday-bash-2014/advanced-reflection-with-go-at-hashicorp/)

如果我们不应该使用反射，那么我们如何解决重复的样板代码问题呢？

## 泛型代码生成工具

我们怎么能不编写所有重复的代码，不受性能的影响，也不失去强类型语言的任何类型安全性呢？

让我们看看如何使用 Go 工具为我们生成样板代码。我们将使用它将代码中的`interface{}`替换为`<T>`。这里，`<T>`表示在发现它的上下文中工作的任何类型。

因为我们将使用实类型，所以我们将获得编译时类型安全性。

### clipperhouse/gen 工具

尽管有几种泛型代码生成工具可用，但让我们看看我个人最喜欢的 clipperhouse/gen。

我们通过 clipperhouse/gen 工具免费获得以下功能：

| **聚合** | **过滤器** | **地图** | **杂项** |
| [骨料【T】](https://clipperhouse.github.io/gen/slice/#aggregatet) | [全部](https://clipperhouse.github.io/gen/slice/#all) | [选择【T】](https://clipperhouse.github.io/gen/slice/#selectt) | [列表](https://clipperhouse.github.io/gen/optional/#list) |
| [平均值](https://clipperhouse.github.io/gen/slice/#average) | [任何](https://clipperhouse.github.io/gen/slice/#any) | [其中](https://clipperhouse.github.io/gen/slice/#where) | [环](https://clipperhouse.github.io/gen/optional/#ring) |
| [平均值【T】](https://clipperhouse.github.io/gen/slice/#averaget) | [清晰](https://clipperhouse.github.io/gen/slice/#distinct) |  | [套](https://clipperhouse.github.io/gen/optional/#set) |
| [计数](https://clipperhouse.github.io/gen/slice/#count) | [区别于](https://clipperhouse.github.io/gen/slice/#distinctby) |  | [纵梁](https://clipperhouse.github.io/gen/stringer/#) |
| [最大值](https://clipperhouse.github.io/gen/slice/#max) | [第一](https://clipperhouse.github.io/gen/slice/#first) |  |  |
| [最大[T]](https://clipperhouse.github.io/gen/slice/#maxt) | [分组依据【T】](https://clipperhouse.github.io/gen/slice/#groupbyt) |  |  |
| [MaxBy](https://clipperhouse.github.io/gen/slice/#maxby) | [洗牌](https://clipperhouse.github.io/gen/slice/#shuffle) |  |  |
| [分钟](https://clipperhouse.github.io/gen/slice/#min) | [排序](https://clipperhouse.github.io/gen/slice/#sort) |  |  |
| [分钟【T】](https://clipperhouse.github.io/gen/slice/#mint) | [排序为](https://clipperhouse.github.io/gen/slice/#sortby) |  |  |
| [明比](https://clipperhouse.github.io/gen/slice/#minby) |  |  |  |

`gen`是 Go 的代码生成工具。它旨在为您的类型提供类似泛型的功能。开箱即用，它提供了 LINQ/下划线启发的方法。

*   [https://github.com/clipperhouse/gen](https://github.com/clipperhouse/gen)
*   [https://en.wikipedia.org/wiki/Language_Integrated_Query](https://en.wikipedia.org/wiki/Language_Integrated_Query)
*   [https://en.wikipedia.org/wiki/Underscore.js](https://en.wikipedia.org/wiki/Underscore.js)

使用 gen 工具，我们将获得泛型的大部分好处，而不会受到反射或类型断言的性能影响。

泛型为我们所做的很像代码生成。在运行时，当我们将类型为`A`的`a`传递给函数时，我们的函数能够接受`a`并做正确的事情似乎很神奇。在运行时的大部分时间（由 JIT 或常规 Go 编译器，取决于具体情况）发生的情况是 Go 执行代码生成替换操作。运行时发生的情况是，我们的 a 在代码中的 a 形孔中被交换。这与我们的泛型代码生成工具用于为我们生成泛型代码的模式相同：

```go
"List <A>".Replace("<A>", a)
```

我们将使用泛型生成工具替换适合 T 形孔的任何类型：

```go
"List <T>".Replace("<T>", "Foo")
"List <T>".Replace("<T>", "Bar")
```

我们可以在开发时使用 gen 工具生成代码。它为我们输出代码，就像 IDE 一样。

我们在代码的**类型**上方的注释行中使用**注释**标记我们的类型，我们希望为其生成代码。

让我们来看一个例子。首先，让我们转到正确的目录，通过获取 init 脚本、运行 glide update 并将 gen 拉入供应商目录来初始化 go 环境。

以下是我们使用的命令列表：

```go
cd <DEVDIR>/fp-go/4-purely-functional/ch11-functor-monoid/03_generics_cars
. init
glide-update
go get github.com/clipperhouse/gen
```

这是我们的目录结构在运行`gen`之前的样子：

![](../Images/71ef883b-c503-4457-ae04-1e836013159e.png)

下面是我们运行`gen`后的目录结构：

![](../Images/dc46692b-f53c-4fb9-8087-295c00a04762.jpg)

现在，让我们看看`src/car/types.go`中的项目代码：

```go
package car

// +gen slice:"Where,Sum[Dollars],GroupBy[string],Select[Dollars]"
type Car struct {
   Make string
   Model string
   Price Dollars
}

type Dollars int
```

你看到`// +gen slice:"Where,Sum[Dollars],GroupBy[string],Select[Dollars]`注释了吗？它告诉我们的 gen 工具生成一个`Car`切片，并给出以下方法：

*   `CarSlice.Where`
*   `CarSlice.SelectDollars`
*   `CarSlice.SumDollars`

当我们在带有`types.go`的目录下运行 gen 时，gen 将生成一个**src/cars/car_slice.go**文件，文件内容如下：

```go
// Generated by: gen
// TypeWriter: slice
// Directive: +gen on Car

package car

// CarSlice is a slice of type Car. Use it where you would use []Car.
type CarSlice []Car

// Where returns a new CarSlice whose elements return true for func. See: http://clipperhouse.github.io/gen/#Where
func (rcv CarSlice) Where(fn func(Car) bool) (result CarSlice) {
   for _, v := range rcv {
      if fn(v) {
         result = append(result, v)
      }
   }
   return result
}

// SumDollars sums Car over elements in CarSlice. See: http://clipperhouse.github.io/gen/#Sum
func (rcv CarSlice) SumDollars(fn func(Car) Dollars) (result Dollars) {
   for _, v := range rcv {
      result += fn(v)
   }
   return
}

// GroupByString groups elements into a map keyed by string. See: http://clipperhouse.github.io/gen/#GroupBy
func (rcv CarSlice) GroupByString(fn func(Car) string) map[string]CarSlice {
   result := make(map[string]CarSlice)
   for _, v := range rcv {
      key := fn(v)
      result[key] = append(result[key], v)
   }
   return result
}

// SelectDollars projects a slice of Dollars from CarSlice, typically called a map in other frameworks. See: http://clipperhouse.github.io/gen/#Select
func (rcv CarSlice) SelectDollars(fn func(Car) Dollars) (result []Dollars) {
   for _, v := range rcv {
      result = append(result, fn(v))
   }
   return
}
```

所以，gen 正在为我们生成所有样板代码。这使我们的源文件保持干净整洁。如果 Go 支持泛型，我们的代码将类似于我们编写的与 gen 一起使用的代码。类似程度如何？让我看看。

这是我们的`main.go`文件：

```go
package main

import (
   "fmt"
 . "car"
)

func main() {
   var cars = CarSlice{
      Car{"Honda", "Accord", 3000},
      Car{"Lexus", "IS250", 40000},
      Car{"Toyota", "Highlander", 3500},
      Car{"Honda", "Accord ES", 3500},
   }
   fmt.Println("cars:", cars)
```

以下是输出：

```go
Output:cars: [{honda accord 3000} {lexus is250 40000} {toyota highlander 3500} {honda accord es 3500}]
```

看到那个`CarSlice`类型了吗？这就是 gen 为我们创造的。我们必须输入实际的结构类型，例如`Car`，gen 将创建`CarSlice`类型以及我们在注释中告诉它为我们生成的所有方法（就在类型定义之上）。

#### If-Go 支持的泛型

如果 Go 支持泛型，则相同的代码块可能是这样的：

```go

   var cars = Slice<Car>{
      Car{"Honda", "Accord", 3000},
      Car{"Lexus", "IS250", 40000},
      Car{"Toyota", "Highlander", 3500},
      Car{"Honda", "Accord ES", 3500},
   }
   fmt.Println("cars:", cars)
```

从一个懒惰的程序员的角度来看这个代码块，如果 Go 支持泛型，我们就必须输入两个额外的字符，`<`和`>`。

看起来通用代码支持的最大功能刚刚被抵消。当我们考虑这些信息以及我们用 Gen 免费获得的函数和性能命中保证在编译时（而不是运行时）发生时，它使得 GO 对泛型的直接支持看起来像是一个好处，或者至少，问题少得多。

##### 添加新方法

如果我们想添加 gen 没有提供给我们的`CarSlice`的方法，我们可以将它们放在一个单独的文件中。我们需要记住的是不要在 gen 生成的文件中键入任何源代码。这是因为我们的代码将在下次告诉 gen 运行时被覆盖。

##### 定义过滤函数

在`main.go`文件的下面几行，让我们定义一个`filter`函数，它将返回`Make`为`Honda.`的车辆。我们使用新的`Where`方法，并将`honda`文本函数传递给它：

```go
honda := func (c Car) bool {
   return c.Make == "Honda"
}
fmt.Println("filter cars by 'Honda':", cars.Where(honda))
```

以下是输出：

```go
filter cars by 'honda': [{honda accord 3000} {honda accord es 3500}]
```

凉的接下来，让我们创建一个映射函数来返回 price 字段：

```go
price := func (c Car) Dollars {
   return c.Price
}
fmt.Println("Hondas prices:", cars.Where(honda).SelectDollars(price))
```

以下是输出：

```go
hondas prices: [3000 3500]
```

由于我们已经对本田进行了筛选，结果只包含本田汽车的价格。

聚合？当然，我们可以做聚合。让我们调用运行注释时免费获得的`SumDollars`函数：

```go
fmt.Println("Hondas sum(prices):", cars.Where(honda).SumDollars(price))
```

以下是输出：

```go
hondas sum(prices): 6500
```

### 重新访问 Nums

还记得我们在没有泛型的情况下实现了`Sum`方法的那四种数字类型吗？让我们重温一下这些代码，看看既然我们了解了 gen，我们是否可以改进我们的代码库：

```go
cd <DEVDIR>/fp-go/4-purely-functional/ch11-functor-monoid/04_generics_nums
. init
glide-update
```

请注意，我们需要运行 glide update，以便为我们创建供应商目录。它将首先放置在我们的 GOPATH 中，这样当我们运行下一个命令时，gen 包及其依赖项将进入我们的供应商目录，而不是我们项目的 src 目录：

```go
go get github.com/clipperhouse/gen
```

现在，让我们 cd 到**~/dev/04_generics\u nums/src/num**并运行 gen:

```go
cd src/num;gen;cd -
```

我们可以看到 gen 创建了四个文件，每个切片类型一个：

![](../Images/e19e1fb0-d162-4e12-b621-5ba5ed88711b.jpg)

我们必须定义每个类型并注释，我们希望 gen 为每个切片创建一个`Sum`方法。请注意，我们不需要为切片创建类型，只需要创建类型。Gen 为我们创建每种类型的切片，以及我们在 Gen 切片注释中请求的方法。

以下是来自`src/num/types.go`的代码：

```go
package num

// +gen slice:"Sum[Int8]"
type Int8 int8

// +gen slice:"Sum[Int32]"
type Int32 int32

// +gen slice:"Sum[Float64]"
type Float64 float64

// +gen slice:"Sum[Complex128]"
type Complex128 complex128
```

这是其中一个生成的文件（`src/num/int8_slice.go`）的外观：

```go
// Generated by: gen
// TypeWriter: slice
// Directive: +gen on Int8

package num

// Int8Slice is a slice of type Int8\. Use it where you would use []Int8.
type Int8Slice []Int8

// SumInt8 sums Int8 over elements in Int8Slice. See: http://clipperhouse.github.io/gen/#Sum
func (rcv Int8Slice) SumInt8(fn func(Int8) Int8) (result Int8) {
   for _, v := range rcv {
      result += fn(v)
   }
   return
}
```

还记得我们在前面的 cars 示例中传递给`Select<T>`函数的价格函数吗？让我们来看看：

```go
price := func (c Car) Dollars {
   return c.Price
}
fmt.Println("Hondas prices:", cars.Where(honda).SelectDollars(price))
```

这就是我们将在`src/num/vars.go`文件中创建的函数类型：

```go
package num

var (
   Int8fn = func (n Int8) Int8 { return n }
   Int32fn = func (n Int32) Int32 { return n }
   Float64fn = func (n Float64) Float64 { return n }
   Complex128fn = func (n Complex128) Complex128 { return n }
)
```

我们只需返回在`fmt.Println`语句中传递到文本函数定义中的值：

```go
package main

import (
   "fmt"
 . "num"
)

func main() {
   fmt.Println("int8Sum:", Int8Slice{1, 2, 3}.SumInt8(Int8fn))
   fmt.Println("int32Sum:", Int32Slice{1, 2, 3}.SumInt32(Int32fn))
   fmt.Println("float64Sum:", Float64Slice{1, 2, 3}.SumFloat64(Float64fn))
   fmt.Println("complex128Sum:", Complex128Slice{1, 2, 3}.SumComplex128(Complex128fn))
}
```

以下是输出：

```go
int8Sum: 6
int32Sum: 6
float64Sum: 6
complex128Sum: (6+0i)
```

即使有了这个简单的求和数字示例，我们也可以看到，我们的 gen 工具使我们不必键入求和数字的样板循环结构。

我们只使用了`Sum`方法，但还有大约 24 种方法可供选择。

描述`Aggregate`方法的文档片段可在[中找到 https://clipperhouse.github.io/gen/slice/#](https://clipperhouse.github.io/gen/slice/#) 。

#### 片式打字机

默认情况下，切片打字机内置在 gen 中。它生成的功能方便的方法对于 C#的 LINQ 或 JavaScript 的数组方法的用户来说很熟悉。它旨在使用传递函数模式为您保存一些循环。它提供了更简单的临时排序。

注释如下所示：

```go
// +gen slice:"Where,GroupBy[int],Any"
 type Example struct {}
```

此处，`Example`用作您的类型的占位符。

生成一个新类型`ExampleSlice`，并成为以下方法的接收者：

##### 合计[T]

`AggregateT`迭代一个切片，将每个元素聚合为一个结果。`AggregateT`可与 LINQ 的聚合进行比较，并强调了 reduce 函数。

签名如下：

```go
func (ExampleSlice) AggregateT(func(T, Example) T) T
```

在下面的示例中，我们在注释注释中指定，我们希望 gen 创建一个在字符串切片上操作的`Aggregate`函数。我们定义了一个传递给执行连接操作的`AggregateString,`的`join`函数：

```go
// +gen slice:"Aggregate[string]"
 type Employee struct{
 Name   string
 Department string
 }

 employees := EmployeeSlice {
 {"Alice", "Accounting"},
 {"Bob", "Back Office"},
 {"Carly", "Containers"},
 }

 join := func(state string, e Employee) string {
    if state != "" {
        state += ", "
    }
    return state + e.Name
 }

 employees.AggregateString(join) // => "Alice, Bob, Carly"
```

## 泛型实现选项

下面是一个决策矩阵，可用于评估哪种泛型实现最好。

![](../Images/384b20d6-080a-4b7a-8021-792e51da8da6.png)

当我们思考如何实施泛型时，有很多方面需要考虑。例如，让我们考虑 Haskell 的参数多态性和 C++的 Ad Hoc 多态性之间的差异。

在 Haskell 中，多态函数是为所有类型统一定义的。我们可以称之为编译时多态性。

在 C++中，动态多态性通过替换、虚拟函数和接口实现多态行为，但是在具体类型替换其参数时，在运行时决定是否实现了针对任何特定类型的工作。

C++模板提供了类似的功能，而没有动态多态性的运行时开销。折衷是灵活性在编译时是固定的。

Haskell 中的类型类允许我们为不同类型的同一函数定义不同的行为。在 C++中，我们使用模板特化和函数重载来实现这一点。

请注意，我们只是触及问题的表面，只讨论了两种语言（C++和 Haskell）。有很多边缘情况需要考虑。例如，Go 编译器是否应该执行积极的优化？如果是这样的话，那就意味着为使用多态函数的所有类型专门化多态函数，这将为管理打开另一个复杂级别。

如果将仿制药支持添加到 Go 中，则会涉及成本和风险。无论是在编译时还是在运行时，成本都会提前到来。在所有情况下，每种方法的利弊都应该仔细评估，我们应该仔细考虑我们的要求。我们将在下一章中更多地讨论泛型。

For more information on generics and Go, including more tools like gen, you can refer to [docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4). Another resource is [golang.org/doc/faq#generics.](https://golang.org/doc/faq#generics)

### 我们使用了 gen 工具

我们使用了 gen 工具，它更符合 C++/模板方法。虽然使用 gen 使我们编写了更多的代码，但我们控制住了，并且我们获得了一些现成的类似 LINQ 的功能，这使我们不必编写大量用于处理切片的样板代码。美好的

那么，Go 支持泛型吗？没有。但是我们可以使用像 gen 这样的工具来解决重复样板代码的大问题。我们仍然有我们的类型安全性，并且不会因为使用反射而支付性能罚款。

## 函子的形状

函子是一种代数类型，它接受一个值（通常是一个值列表），并具有一个映射函数，该函数应用于列表中的每个元素，以生成相同形状的新函子。什么是形状？

让我们看一个命令式示例：

```go
ints := []int{1,2,3}
impInts := []int{}
for _, v := range ints {
   impInts = append(impInts, v + 2)
}
fmt.Println("imperative loop:", impInts)
```

以下是输出：

```go
imperative loop: [3 4 5]
```

本例中的形状表示具有三个整数的切片。我们从一个包含三个 int 的片段开始，运行命令式代码，最后得到一个包含三个 int 的片段。

函子得到相同的结果（三个元素进入，三个元素退出），但函子的方式不同。

我们给函子三个整数的相同切片。函子对每个 int 执行`add2`，并返回一个包含三个 int 的切片（每个 int 比之前大两个）：

```go
add2 := func(i int) int { return i + 2 }
fpInts := Functor(ints).Map(add2)
fmt.Println("fp map:", fpInts)
```

以下是输出：

```go
fp map: [3 4 5]
```

函子肯定不止这些，对吧？

对魔鬼在于细节。那么，让我们来给它照点光。

### 函子实现

让我们看看我们的 ints 函子实现。

#### 整数函子

像我们这些优秀的程序员一样，我们在文件的顶部声明了我们的接口。我们的接口，即我们的契约，只有一个函数，`Map.`我们的`IntFunctor`类型接受一个`func(int) int`函数并返回另一个`IntFunctor`。

什么它返回一个`IntFunctor?`这是什么，它是如何正确打印的？

我们来看看`src/functor/ints.go`：

```go
package functor

import (
   "fmt"
)

type IntFunctor interface {
   Map(f func(int) int) IntFunctor
}
```

函子的一个特点是它在容器中应用`f`函数。现在，什么是容器？

```go
type intBox struct {
   ints []int
}
```

那是我们函子的容器。我们将其称为`box`，因为盒子是一个容器，因为我们是优秀、懒惰的程序员，所以我们更喜欢简短的名称。

可以我看见那个盒子了。我们的魔法`box`发生了什么？

```go
func (box intBox) Map(f func(int) int) IntFunctor {
   for i, el := range box.ints {
      box.ints[i] = f(el)
   }
   return box
}
```

首先，我们注意到`Map`是一个方法，box 是接收者。`Map`接受一个函数并返回另一个`IntFunctor.`啊，那么我们从一个`IntFunctor`映射到另一个？是的，的确如此。

因为函子需要将一个结构映射到另一个结构，并且可能有多个元素需要映射（当我们说 map 时，我们指的是元素的变换元素/3 in，3 out）。可以安全地假设我们将映射元素列表。

Go 中的列表形状通常是如何实现的？吃一片，对吗？毫无疑问，我们的`Map`方法的接收者是一个切片。每个片段都可以使用`range,`进行迭代，这就是我们用来迭代元素列表并将我们的函数（`f`应用于每个元素并返回传递的`box`。不同之处在于`box`现在包含转换后的元素。

等一下，在纯 FP 世界中，有迭代器变量`i`和`el`的`range`在变异，这是什么？更令人不安的是，我们正在改变盒子的内容。没错，突变确实发生了，但只发生在盒子里。这很神奇，记得吗？在这个盒子里，事情可以改变，不会影响我们原本纯净的 FP 世界。

我们怎样才能在纯洁和不纯之间划清界限？我们就是这样做的：

```go
func Functor(ints []int) IntFunctor {
   return intBox{ints: ints}
}
```

就这样。这就是我们允许我们的死刑被降低到变异的阴沟里的地方：

```go
fpInts := Functor(ints).Map(add2)
```

参见前一行的`Functor(ints)`部分？这就是我们将`ints`包裹在魔法盒中的地方，也就是我们允许顽皮的`add2`突变函数应用于我们切片中的每个 int。

将元素降低到突变槽中的这种动作通常称为提升。我认为，根据即将到来的类比，提升是一种用词不当的行为。“降低”将是一个更合适的名称。更多信息，请参见[https://en.wikipedia.org/wiki/Lambda_lifting](https://en.wikipedia.org/wiki/Lambda_lifting) 。

函子盒中发生的事情与一个人接受不纯思想时发生的事情没有什么不同。在人们的心目中，这座建筑将是三只穿着圆点裙的可爱奶牛的名单。不纯的人会允许他们的思想被降低到一个地方，在那里他们会应用`Undress<T>`字面功能，在这种情况下`T`类型将是一头牛：

![](../Images/900ee368-8112-4bb9-ad0a-bbeb777329c2.jpg)

纯 FP 下地狱

当人们知道自己的大脑是一个神奇的盒子，允许各种不纯的变异时，他们可能会感到安全。当这种情况发生时，一个人练习一个`Undress`函子，将可爱的、穿着整齐的奶牛从一个世界映射到另一个世界。

当你妈妈说，*“让你的思想离开阴沟！”*时，这正是她所说的。

我们在`src/functor.ints.go`中做的最后一件事是创建`String()`方法：

```go
func (box intBox) String() string {
   return fmt.Sprintf("%+v", box.ints)
}
```

由于我们已经实现了这一个`String()`方法，根据 Go 的鸭子打字规则，我们的`IntFunctor`是一个`Stringer`：

```go
type Stringer interface {
    String() string
}
```

这是一个漂亮的单一方法界面。`fmt`查找此接口以打印值。

Go 标准库非常容易访问，是一个了解实际工作情况的好地方。在我们的示例中，我们看到我们在`print.go`文件中的*行 577*附近传递了`v`作为动词（当我们返回`fmt.Sprintf("%+v", box.ints)`时）。以下是从*第 577 行*开始的`print.go`片段：

```go
// /usr/local/Cellar/go/1.9/libexec/src/fmt/print.go
// If a string is acceptable according to the format, see if
// the value satisfies one of the string-valued interfaces.
// Println etc. set verb to %v, which is "stringable".
switch verb {
case 'v', 's', 'x', 'X', 'q':
   // Is it an error or Stringer?
 // The duplication in the bodies is necessary:
 // setting handled and deferring catchPanic
 // must happen before calling the method.
 switch v := p.arg.(type) {
   case error:
      handled = true
 defer p.catchPanic(p.arg, verb)
      p.fmtString(v.Error(), verb)
      return

 case Stringer:
      handled = true
 defer p.catchPanic(p.arg, verb)
      p.fmtString(v.String(), verb)
      return
 }
}
```

### 函子定义

函子（[https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html#t:Functor](https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html#t:Functor) 类用于可映射到的类型。

我们将使用 Haskell 语法，因为它非常清楚地定义了 FP 代数数据类型，包括它们的结构、规则和逻辑。`fmap`是地图功能。句点`.`符号是`compose`运算符。

函子实例应满足以下恒等式和结合性定律：

```go
fmap id  ==  id
fmap (f . g)  ==  fmap f . fmap g
```

我们应该从应用于的[第 11 章](11.html)和*范畴理论中认识这两条规则。*

#### 身份操作

我们范畴的同一律说，**A**的同一态射是**A**：

![](../Images/45776db5-ff12-437d-b841-76c5c71611b4.png)

如果我们的操作是一个映射，并且列表中的元素是数字，那么标识态射是+0。如果我们将 0 添加到输入列表的每个元素，那么转换后的列表将由相同的元素组成。

小心！我们将反复强调构图的概念。你对什么是组合以及它是如何工作的理解对于你在纯函数式编程中的生产力是至关重要的。如果你只读了这本书的几页，现在就开始读吧。

## 合成操作

**f**之后的合成操作**g.f**或**g**将函数**f**应用于 x（将我们从**A**带到**B**，并将结果传递给**g**（将我们从**B**带到**C**），并且该嵌套操作集等价于**g.f**的合成操作。

在 Haskell 中，我们在第一行定义合成操作，并在第二行请求查看合成操作的类型定义。第三行是构图的意思：

```go
> (.) g f = \x -> g (f x)
> :t (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
```

上面的`a`、`b`和`c`对应于下图中的**A**、**B**和**C**。

它说，当我们将**A**到**B**函数（**f**传递到**B**到**C**函数（**g**时，我们得到**A**到**C**函数（【T16 g.f。

这是基本的组成。假设我们从**A**开始，这个图表显示我们可以通过**B**（**A**到**B**到**C**或者直接从**A**到**C**到达**C**。当我们选择短路径（**A**到**C**或**g.f**时，我们以嵌套方式组合**g**和**f**，如 g（f（x）），其中 x 是我们从【T26 A 得到的值：

![](../Images/85c1f822-890f-4447-b754-920dafc3f1c8.png)

不太好？坚持住。举几个例子之后，你就会明白了。

### 围棋中的组合示例

我们将创建两个函数`Humanize`和`Emphasize`（表示 f 和 g），以及一个组合函数`Emphasize(Humanize(true))`，以说明**a**到**B**到**C**的路径：

![](../Images/04e03132-a800-4159-a025-6386d4dd9684.png)

`src/compose/compose.go`文件包含以下代码：

```go
package compose

func Humanize(b bool) string {
   if b { return "yes" } else { return "no" }
}

func Emphasize(s string) string {
   return s + "!!"
}

func EmphasizeHumanize(b bool) string {
   return Emphasize(Humanize(b))
}
```

`main.go`看起来像这样：

```go
package main

import (
   "fmt"
 . "compose"
)

func main() {
   fmt.Println("A to B - Humanize(true):", Humanize(true))
   fmt.Println("B to C - Emphasize(\"yes\"):", Emphasize("yes"))
   fmt.Println("A to C - EmphasizeHumanizeFG(true)", EmphasizeHumanizeFG(true))
}
```

如果您使用的是 init 脚本，那么您的终端应该如下所示：

![](../Images/9b514e34-af68-4690-b047-b3642323ccd0.png)

如果这是一个包含外部包的更复杂的示例，那么您将运行以下程序（按此顺序）：

`. init`、`glide-update`和`go-run`

### Haskell 版本的 compose

我们将介绍 Haskell 版本的《人性化》并强调：

```go
humanize b = if b then "yes" else "no"
emphasize str = str ++ "!"
compose g f = \x -> g (f x)
emphasizeHumanize = compose emphasize humanize
emphasizeHumanize True
```

就这样！这五行代码相当于 25 行 Go 代码！

我一点也不主张任何地鼠转向 Haskell——这里有太多的理由需要继续编码和部署 Go 解决方案。我包含 Haskell 代码以供参考。正如本书前面提到的，范畴理论从数学家的大脑中直接渗透到哈斯克尔。所以，如果我们想成为优秀的、纯函数式编程的地鼠，那么我们应该学习 Haskell。

以下是我们会话的 REPL 终端日志：

![](../Images/a5e2627c-878c-4bcf-b32a-5fd0636440ad.png)

让我们仔细看一下其中的一些行。

我们可以让 Haskell REPL 告诉我们使用`:t <symbol>`定义的类型。

例如，`:t humanize`告诉我们它是一个函数（`->`），它接受一个`Bool`并返回一个字符列表：

```go
:t humanize
humanize :: Bool -> [Char]
```

`\x`告诉 Haskell compose 是一个 lambda 表达式。我们将 lambda 命名为`compose`并将`g`和`f`函数作为参数传递。

`g (f x)`表示，将`f`应用于`x`，将结果传递给`g`：

```go
compose g f = \x -> g (f x)
```

现在，让我们看看 compose 是什么类型：

```go
:t compose
 compose :: (t2 -> t1) -> (t -> t2) -> t -> t1
```

这有点难理解。那么，让我们看看 Haskell 是如何说该类型是其 compose 操作符的默认实现的：

```go
:t (.)
 (.) :: (b -> c) -> (a -> b) -> a -> c
```

我们以前见过：

![](../Images/2b57e872-3fab-4a46-b5bf-a87286883296.png)

伟大的现在我们正在取得进展。是时候定义我们的`emphasizeHumanize`组合 lambda 了：

```go
emphasizeHumanize = compose emphasize humanize
```

`compose`是我们的函数，我们将两个参数传递给它--`emphasize`和`humanize`。作为优秀、细心的程序员，我们将检查函数文字的类型：

```go
:t emphasizeHumanize
 emphasizeHumanize :: Bool -> [Char]
```

坚如磐石！它接受一个布尔值并返回一个字符串。

到目前为止，一切顺利。现在是运行 Haskell`compose`函数的时候了，看看我们是否能得到与 Go 相同的结果：

```go
emphasizeHumanize True
 "yes!"
```

呜！

考虑到许多哈斯凯尔人都是数学家，我们知道他们喜欢用符号代替文字。此外，我们知道他们喜欢他们的代码看起来像数学方程。所以，让我们像优秀的数学程序员一样思考，并为语法增添趣味。

让我们用`.`符号重新定义组合函数名（注意，我们必须将`.`放在括号中；否则，Haskell 会抱怨）：

```go
(.) g f = \x -> g (f x)
```

现在让我们检查一下它的类型：

```go
:t (.)
(.) :: (t2 -> t1) -> (t -> t2) -> t -> t1
```

好的，我们现在可以开始了…这是基本的构图。我们可以用我们的句号代替作曲：

```go
emphasizeHumanize = (.) emphasize humanize
emphasizeHumanize True
 "yes!" 
```

但这还不够好。我们可以做得更好。让我们通过在两个参数之间移动（.）来使用中缀符号，如下所示：

```go
emphasizeHumanize = emphasize . humanize
```

让我们验证一下它是否有效：

```go
emphasizeHumanize True
 "yes!"
emphasizeHumanize False
 "no!"
```

### （g.f）（x）=Go 中的 g（f（x））成分

这是 Go 中合成的最后一个示例的图形表示：

>![](../Images/ecafc22b-274b-4a39-8856-eea7314ee282.png)

不要掩饰那张图表。研究它。让它沉下去。

这就是组合，函数式编程的基本原则。

**（g.f）（x）=g（f（x））**方程是非常字面的。它说我们可以执行**f**功能**人性化（真）**，然后将该值**“是”**传递给**g**。。。**强调**（**“是”**）得到**“是！！”**。

**（g.f）（x）=g（f（x））**方程说明了另一件事。它说我们可以嵌套我们的函数，**g（f（x）】**，就像从**A**到**B**再到**B**到**C**，或者我们可以通过执行**emphasistatione（true）**直接从**A**到**C**。

因此，根据左图，**（g.f）（x）==g（f（x））**，同样，根据右图，**强调人性化（真）==强调人性化（真））**。

![](../Images/7df60447-1a1e-4479-ac5e-6c7c2fb8d0e6.png)

砰！

#### （g.f）（x）=g（f（x））实现

现在让我们看一下代码。

以下是上图中的**f**和**g**功能：

```go
package compose

func Humanize(b bool) string {
   if b { return "yes" } else { return "no" }
}

func Emphasize(s string) string {
   return s + "!!"
}

func EmphasizeHumanize(b bool) string {
   return Emphasize(Humanize(b))
}
```

现在来看看新东西。

我们将创建两种类型。Fbs 表示**f**（或**A**到**B**），它接受 bool（true），并返回字符串`"yes"`。Fss 代表**g**（或**B**至**C**）。`Fss`获取字符串`"yes"`，并返回字符串`"yes!!"`：

```go
type Fbs func(bool) string
type Fss func(string) string
```

以下是我们的`Compose`功能：

```go
func Compose(g Fss, f Fbs) Fbs {
   return func(x bool) string {
      return g(f(x))
   }
}
```

嵌套在`Compose`函数中的是一个匿名函数。这是我们的 Lambda。在 Haskell 中，它看起来像`\x -> g (f x)`。

lambda 是表达式，我们可以在任何地方传递它们。我们需要一个接受布尔值并返回`"yes!!"`或`"no!!"`的函数。

最后，我们定义我们的`g.f`函数文字：

```go
var Emphasize_Humanize = Compose(Emphasize, Humanize)
```

#### 关于 Go 中组合命名约定的一点注记

在 Go 中，我们没有必要用。符号或一种方法，可以轻松地将类似于**组合（f，g）**的函数调用转换为类似于**g 组合 f**的函数调用，更不用说类似于**g 的函数调用了。f**。但是别担心！我们将仅使用以下命名约定来表示一个组合函数：`Emphasize_Humanize`（其内容为`g . f`，其中`g`为`Emphasize`，而`f`为`Humanize`。通常，骆驼套符号看起来像`EmphasizeHumanize`，但由于`_`将骆驼驼峰分开，很明显这是一个特殊的符号。

这是 main.go：

```go
package main

import (
   "fmt"
 . "compose"
)

func main() {
   fmt.Println("A to B - Humanize(true):", Humanize(true))
   fmt.Println("B to C - Emphasize(\"yes\"):", Emphasize("yes"))
   fmt.Println("A to C - EmphasizeHumanize(true):", EmphasizeHumanize(true))
   fmt.Println("A to C - Emphasize_Humanize(true):", Emphasize_Humanize(true))
}
```

下面是我们运行它时的样子：

![](../Images/29458000-fc00-4eee-8684-6eaaee0acfbe.png)

### 箭头的方向很重要

在最后一章中，我们使用下表来求解*f（x）=x+2:*

![](../Images/eb3c1664-0764-49e2-9751-e8222a3db109.png)

还记得我们用*g（x）=x2+1*组合*f（x）=x+2*的时候吗？我们解出了**g（f（1））=10**：

![](../Images/8b95812f-0f1a-47a6-bf5d-02a5fbaf3658.png)

我们还证明了**f（g（1））=4**，这显然不是**10**。所以，我们知道函数组合是不可交换的。箭只向一个方向射出。

#### 强调人性化订购错误

当我们试图颠倒操作顺序时，这就是我们试图做的：

![](../Images/0499e2cc-9754-426f-8d2f-c0e33c2d6854.png)

这不计算。

我们首先将布尔值**true**传递给**强调**，但这意味着什么？我们想做什么？我们不是在改变箭头的方向，而是在试图改变我们称之为箭头的顺序。考虑到我们从布尔值开始并试图得到一个`"yes!!"`或`"no!!"`的上下文，只有在一个方向上应用`Humanize`和`Emphasize`函数才有意义。事实上，我们正试图反向创作：

```go
func Compose(f Fss, g Fbs) Fbs {
   return func(n bool) string {
      return g(f(n))
   }
}
```

请注意，代码的其余部分与前面相同。在我们的返回语句中，我们只交换了**f**和**g**的嵌套顺序。

调用`Compose`函数的函数文本如下所示：

```go
var EmphasizeHumanizeFoG = Compose(Emphasize, Humanize)
```

也就是说，*强调真实，然后将*的结果人性化，这显然是行不通的（见上图）。

此代码甚至不会编译：

![](../Images/6d32204b-2ad1-45ba-83f4-3fa6407afc60.png)

### 函数组合是关联的

因此，函数合成不会相互转换，但它是关联的：

![](../Images/0c6f1211-4f95-468c-8aee-f8824c3dd744.png)

该图显示，我们可以通过选择上限（**A****来组合从**A**到**D**的函数→C**→ **D**路径或下方（**A**路径）→ **B**→ **D**路径。

函子的概念是，它将我们可以在一个类别中绘制的图表转换为另一个类别中的图表。这通常使我们能够将想法和定理从一个类别转换为另一个类别。

让我们看一个特定的函子的例子，健忘函子，以便更好地理解将事物从一个类别转换为另一个类别意味着什么。

## 法律义务背景下的功能构成

假设拉里同意在 10 月 1 日之前向露西支付 5000 美元，并且该日期已经过去。露西想得到 5000 美元，拉里想付给她，但他没有钱。

露西应该起诉拉里让他付钱吗？

以下类别图描述了它们的情况：

![](../Images/b6196744-65f1-403c-8569-d9979a00200c.png)

类别国家如下：

*   **A**=我们今天的处境（10 月 12 日）
*   **B**=露西要求起诉
*   **C**=露西得到报酬

类别态射如下所示：

*   **f**=法律费用（两者均为$2000+）
*   **g**=拉里付给露西 5000 美元
*   **h**=拉里付给露西 5000 美元

### 决策决定状态转换

如果拉里真诚地向露西传达以下信息，露西会选择哪条道路？

明确地说，我只是要求有更多的时间来支付，或者你允许我直接向你支付预定的款项，而无需通过法院系统。

你的想法？

拉里

很明显，这两条路最终会从**A**到**C**，但哪条路最短？在时间和财务费用方面，哪条道路的成本更高？

### 范畴理论述评

我们连接了两个从**A**到**B**和**B**到**C**的箭头，以及另一个从**A**到**C**的等效箭头。**A**、**B**和**C**称为对象。他们可以代表任何东西。在本例中，它们表示状态——开始（**A**）、中间（**B**）和最终（**C**状态。在下一个示例中，域和范围代表不同的法院案例、不同的世界。每一个案件的事实构成了每一个案件的结构，两个世界之间的箭头是律师在陈述案件时所做的映射。

#### 分类规则

只有两条规则必须遵守：

*   身份
*   结合性

#### 注重成果

范畴理论是以结果为导向的。这一切都是从**A**到**C**的过程。箭头是单向的。当我们组合两条路径时（**A**→ **B**和**B**→ **C**，我们得到一条等价路径（**A**→ **C**。这就是我们在编写函数时所做的。我们可以调用一个`Compose`函数（如下代码片段所示），而不是两个函数（`f`和`g`：

```go
func Compose(g Fss, f Fbs) Fbs {
   return func(x bool) string {
      return g(f(x))
   }
}
```

### 健忘函子与法律

假设露西选择了较长的路径；露西的律师将如何为他们的当事人辩护？

让我们假设这个故事还有更多。让我们假设露西过去曾以某种方式伤害过拉里，现在露西正迫使拉里提起诉讼，他反过来会选择将这一新信息传达给他的律师，以便提起反诉。

#### 法治

当他们上法庭时，法律将如何运作？律师们研究法律，从先前的法庭案例中找到一个可能对他们的客户产生有利结果的案例。然后，他们将该案件的裁决作为先例，为客户赢得当前案件。

不可能参考全部案例来证明他们的观点。因此，双方的律师都会使用一种修辞手段，被分类理论家称为健忘函子。健忘的函子必然会留下一些结构。很难从过去找到一个在各个方面都与当前情况相同的案例。

每一位律师都试图说服其他人，他们所呈现的结构——也就是说，一个法庭案例，如果被选择，将为他们的当事人带来最好的结果——是应该应用的结构。

事实是，过去有大量的法院裁决可以适用，但每位律师都会试图说服法官和/或陪审团，他们选择的案件就是法律的实际情况。

胜诉方将有效地将来自不同当事人（原告、被告和案件事实）的先前法庭裁决映射到当前案件中。一些细节可能会有所不同，但胜诉律师是最能传达他们已经确定了最相关和最适用的案件以在今天的法庭上申请的人。

每一位律师都确定了最有助于其委托人的旧案件和当前法庭案件之间的双边对称性，并尽其所能说服其他人适用该案件。我们可能会听到争论是这样开始的，*“女士们先生们，你们需要应用的基本结构是这个**。*

#### 露西健忘函子

考虑到 G 是他们当前的案件，根据其当前的一组事实，Lucy 的律师绘制了该案件（**E**中对 Lucy 帮助最大的事实：

![](../Images/0e32e19a-3dfd-40db-94ea-248a677711f2.png)

**f<sub>Lucy</sub>**是案例**E**事实的映射函数，优先于 Lucy。

#### 拉里健忘函子

拉里的律师从案件（**F**中找出了对拉里帮助最大的事实：

![](../Images/2b9faa05-5037-48ac-af96-bd719c58b1d4.png)

由法官和/或陪审团决定哪种映射最适合当前正在审查的案件。具有最佳映射的一方获胜。

现在是编写另一个函子（双关语）的时候了。

## 构建一个 12 小时的时钟函子

我们将构建一个 12 小时的时钟函子，如下所示：

| **结构** | 有 12 个小时位置的钟 |
| **变换操作** | *f（x）=x+12*，其中*x*为小时 |

![](../Images/3da5772f-617f-406d-b8a1-9163d5f7c878.png)

首先，让我们检查函子实现：

```go
// src/functor/clock.go

package functor

import (
   "fmt"
)
```

将我们的`ClockFunctor`接口定义为包含单个功能（`Map`：

```go
type ClockFunctor interface {
   Map(f func(int) int) ClockFunctor
}
```

创建一个容器来保存 12 小时的列表：

```go
type hourContainer struct {
   hours []int
}
```

调用时，`Map`将被执行/应用于容器中的每个元素：

```go
func (box hourContainer) Map(f func(int) int) ClockFunctor {
   for i, el := range box.hours {
      box.hours[i] = f(el)
   }
   return box
}
```

只要副作用局限于变量，比如循环变量，作用域为`Map`函数，那么`Map`的实现可以不纯净。请注意，返回容器，我们称之为`box`，其元素已通过映射器函数**f**以某种方式进行了转换。

接下来，我们创建一个名为 Functor 的函数，将 12 小时的列表包装到神奇的转换框中。这就是我们将价值降低到沟中的地方。有人将此过程称为提升，即从一个世界到另一个世界的映射转换（有关详细信息，请参阅本章前面的*Pure FP goes to Hell*：

```go
func Functor(hours []int) ClockFunctor {
   return hourContainer{hours: hours}
}
```

### 时钟函子助手

在`clock.go`文件的末尾，我们将添加一些帮助程序，如下部分所述。

#### 单位函数

我们的`Unit`功能就是我们的身份功能。当应用于切片中的元素时，它将没有效果。这很简单，但这是满足函子代数定律的要求：

```go
var Unit = func(i int) int {
   return (i)
}
```

#### ampmapper 函数

这是当我们想从上午改为下午时应用的映射器。它将被传递到`Map`方法，并应用于盒子中包含的每个小时。它将 AM 小时（1，2…12）转换为相应的 PM 小时（13，14…0）。

```go
var AmPmMapper = func(i int) int {
   return (i + 12) % 24
}
```

#### AmHoursFn 助手

我们可以在任何时候调用这个方便的函数，只要我们想要 AM 小时的列表。请注意，如果我们创建一个`AmHours`变量来传递给时钟的函子，它的值可以更改。这就像是 AM 小时的切片常数：

```go
func AmHoursFn()  []int {
   return []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
}
```

在现实场景中，我们将按预期使用函子，也就是说，我们将传入一个初始值片，并允许每个函子在每次调用新函子的`Map`函数时转换该值片。在我们的`main.go`文件中，我们希望为学习目的重置时间设置。

#### 字符串辅助函数

创建打印函子内容时要使用的字符串辅助函数：

```go
func (box hourContainer) String() string {
   return fmt.Sprintf("%+v", box.hours)
}
```

#### 梅因，加油

我们从典型的`package main`和`import`语句以及`main()`函数开始：

```go
package main

import (
   . "functor"
 "fmt"
)

func main() {
```

请注意，我们在内部`functor`包（位于`src`目录）前面加了一个点。这使得我们可以引用它输出的符号，例如`Functor`和`Map.`

首先，我们调用`Functor`方法并传入`AmHours`片段。`Functor`将我们的时间结构包装在`ClockFunctor:`类型的函数中

```go
fmt.Println("initial state :", Functor(AmHoursFn()))
```

以下是输出：

```go
initial state : [1 2 3 4 5 6 7 8 9 10 11 12]
```

`Functor`功能是连接我们两个世界的纽带：上午的世界和下午的世界（反之亦然）。我们可以说，`Functor`将我们的时间降低到一个神奇的盒子中，在这个盒子中，变换映射函数`amPmMapper`应用于每个元素，将其转换为相应的 PM（或 AM）小时。

请注意，映射器功能必须没有任何副作用：

```go
fmt.Println("unit application :", Functor(AmHoursFn()).Map(Unit))
```

以下是输出：

```go
unit application : [1 2 3 4 5 6 7 8 9 10 11 12]
```

我们可以看到，当我们将函子的身份函数 unit 传递给它的`Map`方法时，它返回我们传递给它的内容，即 AM 小时数。

现在来看有趣的部分。让我们将映射函数传递给函子：

```go
fmt.Println("1st application :", Functor(AmHoursFn()).Map(AmPmMapper))
```

以下是输出：

```go
1st application : [13 14 15 16 17 18 19 20 21 22 23 0]
```

令人惊叹的我们的上午时间列表已转换为下午时间列表。

现在，让我们展示并链接两个`Map`呼叫：

```go
fmt.Println("chain applications:", Functor(AmHoursFn()).Map(AmPmMapper).Map(AmPmMapper))
```

以下是输出：

```go
chain applications: [1 2 3 4 5 6 7 8 9 10 11 12]
```

为什么要炫耀？看起来没有什么变化。瘸的正当

错误的我们把我们的函子锁起来了。

![](../Images/2330d241-2d2b-4a81-9b91-50bb0bfad2fb.png)

输出看起来没有改变的原因是它从上午到下午，再回到上午。

#### 终端输出日志

以下是我们的终端的外观：

![](../Images/243541e1-0f3c-4980-aab4-e6517bfb0c19.png)

#### 函子摘要

我们的时钟函子包含一个可容纳 12 小时的结构（一个 int 片）和一个接受映射函数的`Map`方法，该映射函数用于将 12 小时中的每一小时转换为随后的 12 小时集（AM/PM）。每次执行`Map`方法时，返回一个新的函子；由于这个特性，我们可以链接我们的`Map`方法调用。

换句话说，请看以下示例：

```go
Functor([]int{1, 2, 3}).Map(mapperFn).Map(mapperFn))
```

我们看到，通过函子，我们包装和`Map`（并且可以链接我们的地图）。

## 汽车函子

让我们使用一个函子升级（和降级）一些汽车！我们首先打开`functor`包中的`car.go`文件。

### 函子包

我们来看看`src/functor/car.go`：

```go
package functor

import (
   "fmt"
 "strings"
)

type (
   Car struct {
      Make string `json:"make"`
 Model string `json:"model"`
 }
)
```

最好在顶部定义我们的类型。将它们放在类型块中有助于保持代码干净整洁。另一个好的做法是向结构的每个字段添加 JSON 注释，以便将 JSON 轻松（取消）编组到`Car`结构中。

如果要从结构中省略空字段，可以将`omitempty`子句添加到字段注释的末尾。例如，如果`Make`是可选的或有时不包含，并且我们不希望从`Car`结构创建的`json`包含空的`Make`字段，那么我们的结构定义将如下所示：

`Car struct {`
`Make string `json:"make"``
`Model string `json:"model,omitempty"``
`}`

接下来是我们的接口定义，其中包括单个`Map`方法：

```go
type CarFunctor interface {
   Map(f func(Car) Car) CarFunctor
}
```

这是我们的神奇盒子，由我们将要转换的切片组成：

```go
type carContainer struct {
   cars []Car
}
```

这是我们的`Map`方法实现，我们迭代了我们神奇盒子中汽车切片的元素，将映射函数`f`应用于每个元素：

```go
func (box carContainer) Map(f func(Car) Car) CarFunctor {
   for i, el := range box.cars {
      box.cars[i] = f(el)
   }
   return box
}
```

以下是我们的`Wrap`方法，用于将我们的汽车片放入魔法盒中进行改造：

```go
func Wrap(cars []Car) CarFunctor {
   return carContainer{cars: cars}
}
```

这里我们定义了助手函数。`Unit`我们以前见过——这是我们的身份形态。另外两个是`Upgrade`和`Downgrade.`我们将保持简单，当我们升级或删除车型以降级汽车时，只需在车型名称的末尾添加一个`" LX"`：

```go
var (
   Unit = func(i Car) Car {
      return (i)
   }

   Upgrade = func(car Car) Car {
      if !strings.Contains(car.Model, " LX") {
         car.Model += " LX"
 } else if !strings.Contains(car.Model, " Limited") {
         car.Model += " Limited"
 }
      return car
   }

   Downgrade = func(car Car) Car {
      if strings.Contains(car.Model, " Limited") {
         car.Model = strings.Replace(car.Model, " Limited", "", -1)
      } else if strings.Contains(car.Model, " LX") {
         car.Model = strings.Replace(car.Model, " LX", "", -1)
      }
      return car
   }
)
```

最后，我们加入了一个`String`方法，以便我们的`fmt`包知道如何打印我们的汽车：

```go
func (box carContainer) String() string {
   return fmt.Sprintf("%+v", box.cars)
}
```

### 梅因，加油

我们将处理字符串和一些 JSON，以及一个`car`函子：

```go
package main

import (
   "encoding/json"
 "fmt"
 "functor"
 "strings"
)
```

创建一个`cars`变量来保存`Car`类型，并用两辆车对其进行初始化。由于我们用`'json'`注释了我们的`Make`和`Model`字段，我们可以很容易地将`Toyota Highlander`解组到汽车中：

```go
func main() {

   cars := []functor.Car{
      {"Honda", "Accord"},
      {"Lexus", "IS250"}}

   str := `{"make": "Toyota", "model": "Highlander"}`
 highlander := functor.Car{}
   json.Unmarshal([]byte(str), &highlander)
   cars = append(cars, highlander)
```

现在，让我们练习我们的`car`函子，并验证它是否正常工作：

```go
fmt.Println("initial state :", functor.Wrap(cars))
fmt.Println("unit application:", functor.Wrap(cars).Map(functor.Unit))
fmt.Println("one upgrade :", functor.Wrap(cars).Map(functor.Upgrade))
fmt.Println("chain upgrades :", functor.Wrap(cars).Map(functor.Upgrade).Map(functor.Upgrade))
fmt.Println("one downgrade :", functor.Wrap([]functor.Car{{"Honda", "Accord"}, {"Lexus", "IS250 LX"}, {"Toyota", "Highlander LX Limited"}}).Map(functor.Downgrade))
```

#### 比较一行 FP 和一堆命令行

只需一行 FP 样式的代码即可对汽车进行升级和降级。诚然，`Upgrade`和`Downgrade`映射器函数是在`functor`包中定义的，但这是一个很大的好处。我们可以将循环通过汽车片段的样板实现与我们的业务用例逻辑分开。

使用命令式实现风格，我们首先实现`for...range`迭代块，在其中插入升级/降级逻辑：

```go
// FUNCTIONAL STYLE
fmt.Println("up and downgrade:", functor.Wrap(cars).Map(functor.Upgrade).Map(functor.Downgrade))

// IMPERATIVE STYLE
cars2 := []functor.Car{}
for _, car := range cars {
   // upgrade
 if !strings.Contains(car.Model, " LX") {
      car.Model += " LX"
 } else if !strings.Contains(car.Model, " Limited") {
      car.Model += " Limited"
 }
   cars2 = append(cars2, car)
}
cars3 := []functor.Car{}
for _, car := range cars2 {
   // downgrade
 if strings.Contains(car.Model, " Limited") {
      car.Model = strings.Replace(car.Model, " Limited", "", -1)
   } else if strings.Contains(car.Model, " LX") {
      car.Model = strings.Replace(car.Model, " LX", "", -1)
   }
   cars3 = append(cars3, car)
}
fmt.Println("up and downgrade:", cars3)
```

看到区别了吗？

哪种类型的编码更容易维护？

#### 汽车函子终端会话

让我们运行汽车函子示例：

![](../Images/ff3b748b-7219-4d67-a60a-26b586fc36ea.png)

## 独异点

幺半群是组合任何值的最基本方法。幺半群是在结合二元运算下闭合的代数，它有一个单位元。

我们可以将幺半群视为一种设计模式，它允许我们以并行方式快速减少（或折叠）单个类型的集合。

### 幺半群规则

幺半群是任何满足以下规则的东西：

*   闭包规则
*   结合规则
*   身份规则

让我们简要地讨论一下这些规则。

#### 闭包规则

如果合并两个相同类型的值，则会得到另一个相同类型的值

给定两个相同类型的输入，幺半群返回一个与输入类型相同的值。

##### 闭包规则示例

1+2=3，3 是一个整数。

1+2+3 也等于一个整数。

1+2+3+4 也等于一个整数。

我们的二进制操作已经扩展为一个在列表上工作的操作！

##### 闭包公理

如果 a，b∈ S、 然后 a+b∈ s

也就是说，如果 a 和 b 是整数集合 S 中的任意两个值，并且如果我们对任意两个值应用二进制运算+，那么加法运算的结果将是一个也在整数集合中的值。

#### 结合规则

如果组合多个值，则组合顺序无关紧要

```go
( 1 + 2 ) + 3 == 1 + ( 2 + 3 )   // left and right associativity
```

如果我们有 1+2+3+4，我们可以把它转换成（1+2）+（3+4）。

请注意，关联性适用于加法、乘法和字符串串联，但不适用于减法和除法。

#### 身份规则

“有一个标识元素不起任何作用。”

-身份规则

幺半群将接受两个相同类型的值，并返回一个相同类型的值。

##### 标识规则示例

在+运算符下，整数集的标识为 0。

| 规则 | 实例 |
| 左身份 | 0 + 1 == 1 |
| 正确身份 | 1 + 0 == 1 |

请注意，运算符是二进制的，即它接受两个输入，并且这些输入必须是相同类型的。

将标识元素（有时称为空或零）与 x 组合的结果始终是 x。

##### 0 的标识

在*运算符下，整数集的标识为 1。

```go
1 * 0 == 0
1 * 2 == 2
```

### 编写归约函数

根据前面的三条规则，我们可以编写一个缩减函数。当我们使用加法对整数数组进行约简时，我们使用 0（identity 元素）作为操作的种子。

当我们使用乘法对整数数组进行约简时，我们使用 1（标识元素）作为操作的种子。

这就是我的想法。下表总结了一些可能的减少：

| **型** | **操作** | **单位/零/中性值** |
| ints | + | 0 |
| ints | * | 1. |
| 一串 | +（混凝土串） | “” |
| 布尔 | && | 符合事实的 |
| 布尔 | &#124;&#124; | 错误的 |
| 列表 | < | [] |
|  |  |  |

### 半群是缺少的中立值

如果我们缺少单位/零/中性值，那么我们没有幺半群，我们有一个半群。注意，半群可以转化为幺半群。

这是一个关于幺半群代数的非常有趣的讨论，但是它们到底有什么用，我们为什么要关心呢？

这里有几个关于幺半群的好用法。

#### 将二进制操作转换为对列表起作用的操作

考虑以下操作：

```go
1 + 2 + 3   ⇒   [1,2,3] |> List.reduce(+)
```

我们不必编写所有的代码，在其中键入一个数字，键入一个`+`，再键入另一个数字，我们就可以将一个数字列表输入到 reduce 函数中，reduce 函数将`+`操作应用于每个项并累加总和。

下面是一个附加字符串的示例：

```go
"a" + "b" + "c"   ⇒   ["a", "b", "c] |> List.reduce(+)
```

在前面的每个例子中，中性/身份元素是什么？

前面的代码是 F#代码。`|>`符号只是一个管道符号，就像我们在 Unix 终端中使用的一样。它允许我们将整数列表`[1,2,3]`或列表字符串`["a", "b", "c"]`导入`List.reduce(+)`。大于符号只是指示数据流的方向，即从左到右。

#### 使用带分治算法的幺半群

幺半群经常用于解决大型计算。幺半群帮助我们将计算分解成若干部分。我们可以在单独的核心或单独的服务器上运行较小的计算，并将结果重新组合/减少/折叠为单个结果。我们经常使用并行或并发技术以及结果的增量积累。

作为一个非常简单的例子，如果我们需要添加这些数字：1+2+3+4。

我们可以在一个 CPU/核心上添加（1+2），在另一个 CPU/核心上添加（3+4）：

3 + 7 = 10

Where associativity holds, we can parallelize our computations.

### 参考透明度

确定何时使用幺半群可以帮助我们做出影响性能的设计决策。

在第一天，我们被要求添加 1+2+3。然后，在第二天，我们被要求再增加 1 个。我们不必再加 1+2+3。我们可以简单地存储它并将新的 1 添加到其中：6+1=7。

考虑到没有任何东西是免费的，我们为了获得不必添加 1+2+3 的性能提升付出了什么代价？存储问题是，哪个成本更高？这个问题的答案将告诉我们是否要利用引用透明性。仅仅因为我们能做一些事情并不意味着我们总是应该做。

### 不处理任何数据

如果我们没有数据，但被要求减少数据，该怎么办？类似地，如果我们没有数据，但要求我们以增量方式添加数据，该怎么办？

这就是 identity 元素派上用场的时候了！它可以是缺失数据的初始值。

### 幺半群的更多例子

列表是幺半群。合并它们的操作只是连接。许多类型的容器也是幺半群，包括单子。

### 什么不是幺半群？

整数不是幺半群，但是加法下的整数（一种组合它们的方法）是幺半群。

整数（从 1 开始的整数）和加法下的偶数都不是幺半群。添加的中性元素是什么？答案是零。

发票不是幺半群：

![](../Images/0b8f0dc3-8f8b-4661-bfbc-136ea1ba44c6.png)

我们如何合并两张发票？

![](../Images/412e3faf-2ded-4b05-99c7-1c1353b2a4a8.png)

添加发票意味着什么？我们是要把颜色合并起来，还是要把它们弄碎？如果我们把它们堆叠起来，除了从列表中去掉最上面的那一个，我们还能做什么呢？我们如何组合客户地址？当然，我们可以添加工单编号，1000+1000=2000，但这对我们有什么价值？

我们怎么可能添加发票？也许如果我们选择一些统计性质的领域？

## 幺半群例子

这里我们将讨论三种类型的幺半群：

*   名称幺半群
*   整数片幺半群
*   行项幺半群

这是正确的。我们要把发票变成一个幺半群！

### 名称幺半群

让我们看看我们能用一个名字做些什么。首先，我们定义了一个有两种方法的接口，`Append`和`Zero.`我们将我们的名称包装在`nameContainer.`中

我们的`nameContainer`是一个具有单个字符串字段`name`的结构。我们的`Append`方法将给定名称附加到它正在构建的长名称字符串中，该字符串生活在神奇的`nameContainer`中。我们的名称字符串的零态射是一个空字符串。

`src/monoid/name_monoid.go`的内容如下：

```go
package monoid

type NameMonoid interface {
   Append(s string) NameMonoid
   Zero() string
}

func WrapName(s string) NameMonoid {
   return nameContainer{name: s}
}

type nameContainer struct {
   name string
}

func (s nameContainer) Append(name string) NameMonoid {
   s.name = s.name + name
   return s
}

func (nameContainer) Zero() string {
   return ""
}

func (s nameContainer) String() string {
   return s.name
}
```

以下是`main.go`的样子：

```go
package main

import (
   "monoid"
 "fmt"
)

func main() {

   const name = "Alice"
 stringMonoid := monoid.WrapName(name)
   fmt.Println("NameMonoid")
   fmt.Println("Initial state:", stringMonoid)
   fmt.Println("Zero:", stringMonoid.Zero())
   fmt.Println("1st application:", stringMonoid.Append(name))
   fmt.Println("Chain applications:", stringMonoid.Append(name).Append(name))
```

#### 名称幺半群终端会话

让我们运行我们的幺半群：

![](../Images/00863fff-a211-46a6-b700-096d647b1250.png)

在这里，我们运行了我们的应用程序并得到了很好的结果。初始状态为 Alice，**零**值为空字符串；在第一次追加后，我们得到**AliceAlice，**，当我们链接另一个后，我们得到**AliceAlice。**

##### 整数片幺半群

让我们看看我们能用一片整数做些什么。

首先，我们定义了一个接口，它有两个方法，`Append`和`Zero.`我们将 int 封装在`intContainer`中。`intContainer`是一个具有单个 int 字段`ints`的结构。我们的`Append`方法将给定的 int 切片附加到`ints`的切片上，该切片是生活在魔法`intContainer`中的`ints`的构建。切片的`Zero`态射是`nil`。

以下是`src/monoid/int_monoid.go`的内容：

```go
package monoid

type IntMonoid interface {
   Zero() []int
   Append(i ...int) IntMonoid
   Reduce() int
}

func WrapInt(ints []int) IntMonoid {
return intContainer{ints: ints}
}

type intContainer struct {
   ints []int
}

func (intContainer) Zero() []int {
return nil
}

func (i intContainer) Append(ints ...int) IntMonoid {
   i.ints = append(i.ints, ints...)
return i
}

func (i intContainer) Reduce() int {
   total := 0
 for _, item := range i.ints {
      total += item
   }
return total
}

```

除了`Reduce`方法之外，这与名称幺半群的逻辑几乎相同。`Reduce`方法允许我们将所有整数与二进制运算符加法组合，并得出`intMonoid`容器中所有整数的总和。

`main.go`的内容如下：

```go
ints := []int{1, 2, 3}
intMonoid := monoid.WrapInt(ints)
fmt.Println("\nIntMonoid")
fmt.Println("Initial state:", intMonoid)
fmt.Println("Zero:", intMonoid.Zero())
fmt.Println("1st application:", intMonoid.Append(ints...))
fmt.Println("Chain applications:", intMonoid.Append(ints...).Append(ints...))
fmt.Println("Reduce chain:", intMonoid.Append(ints...).Append(ints...).Reduce())
```

我们调用了我们为`nameMonoid`所做的相同方法列表，并得到了正确的结果。有趣的一行是最后一行，在这里我们链接我们的附录，然后调用 Reduce 来总结我们的 int：

![](../Images/4e8a85ac-c638-49da-a812-1693649b8ac4.png)

整数片幺半群终端会话

##### Lineitem 切片幺半群

让我们看看我们可以用一部分行项目做些什么。

首先，我们定义了一个有三种方法的接口，`Append`、`Zero`和`Reduce.`我们将行项目包装在`lineitemContainer.`中。我们的`lineitemContainer`是一个结构，有三个字段对应于发票的行项目：

```go
type Lineitem struct {
   Quantity   int
   Price     int
   ListPrice  int
}
```

我们的`Append`方法将给定的行项目附加到它正在构建的、生活在魔法`lineitemContainer`中的行项目片段中。

切片的`Zero`态射是`nil`。

`src/monoid/lineitem_monoid.go`文件将具有以下代码：

```go
package monoid

type LineitemMonoid interface {
   Zero() []int
   Append(i ...int) LineitemMonoid
   Reduce() int
}

func WrapLineitem(lineitems []Lineitem) lineitemContainer {
return lineitemContainer{lineitems: lineitems}
}

type Lineitem struct {
   Quantity   int
   Price     int
   ListPrice  int
}

type lineitemContainer struct {
   lineitems []Lineitem
}

func (lineitemContainer) Zero() []Lineitem {
return nil
}

func (i lineitemContainer) Append(lineitems ...Lineitem) lineitemContainer {
   i.lineitems = append(i.lineitems, lineitems...)
return i
}

func (i lineitemContainer) Reduce() Lineitem {
   totalQuantity := 0
 totalPrice := 0
 totalListPrice := 0
 for _, item := range i.lineitems {
      totalQuantity += item.Quantity
      totalPrice += item.Price
      totalListPrice += item.ListPrice
   }
return Lineitem{totalQuantity, totalPrice, totalListPrice}
}
```

这与`Int`切片幺半群的逻辑几乎相同，除了`Reduce`方法。`Reduce`方法允许我们将所有行项目字段与二进制运算符 addition 组合，并得出`lineitemMonoid`容器中所有行项目项的总和。

`main.go`文件将具有以下代码：

```go
lineitems := []monoid.Lineitem{
   {1, 12978, 22330},
   {2, 530, 786},
   {5, 270, 507},
}
lineitemMonoid := monoid.WrapLineitem(lineitems)
fmt.Println("\nLineItemMonoid")
fmt.Println("Initial state:", lineitemMonoid)
fmt.Println("Zero:", lineitemMonoid.Zero())
fmt.Println("1st application:", lineitemMonoid.Append(lineitems...))
fmt.Println("Chain applications:", lineitemMonoid.Append(lineitems...).Append(lineitems...))
fmt.Println("Reduce chain:", lineitemMonoid.Append(lineitems...).Append(lineitems...).Reduce())
```

这和我们用其他幺半群验证的一样。我们的 feeder 值 line items 是三个 line item 元组的一部分。验证`Reduce`的数学运算是否有效。

##### 整数片幺半群终端会话

查看最后一行输出，我们可以看到我们调用了`Reduce`函数来求和总数（`totalQuantity`、`totalPrice`和`totalListPrice`：

![](../Images/43b2d198-4888-4d14-b678-1d996b294807.png)

为了快速手动验证，让我们看一下`totalQuantity`--*1+2+5+1+2+5+1+2+5=24*。看起来不错！

## 总结

在本章中，我们学习了如何使用工具来解决 Go 中由于缺乏对泛型的支持而出现的问题。通过从正确定义的基类型开始，我们能够使用此工具在 Go 代码中生成类似下划线的特性。不再担心潜在的泛型支持会降低运行时可执行文件的速度（就像 Java 一样），我们欣喜若狂地看到了意想不到的生产力提升。

我们继续进入纯 FP 领域，在那里我们解决了功能组合的概念。在我们的工具带`g.f(x) == g(f(x))`中，我们学习了函子，并学习了如何转换项目列表。我们把地图拴在一起，甚至学会了律师如何使用健忘函子为他们的客户在法庭上打赢官司。

我们用幺半群结束了这一章。我们不仅学习了幺半群的代数定律，而且还实现了它们。我们链接了`Append`方法，甚至写了几个简化。

在下一章中，我们将继续沿着纯粹启蒙的道路前进，继续追求更简单的代码和改进的错误处理。